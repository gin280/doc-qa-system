# Test Design: Story 4.1 - 添加上传速率限制

**Story ID**: 4.1  
**Date**: 2025-01-15  
**Designer**: Quinn (Test Architect)

---

## Test Strategy Overview

- **Total test scenarios**: 18
- **Unit tests**: 8 (44%)
- **Integration tests**: 8 (44%)
- **E2E tests**: 2 (12%)
- **Priority distribution**: P0: 12, P1: 4, P2: 2

**Testing Philosophy**: 
此 Story 的测试策略遵循 "Shift Left" 原则，重点在单元和集成测试层面验证速率限制逻辑。核心测试目标:
1. 验证限流逻辑正确性（单元）
2. 验证 API 集成正确性（集成）
3. 验证降级策略和错误处理（单元 + 集成）
4. 验证用户体验（集成 + E2E）

---

## Test Scenarios by Acceptance Criteria

### AC1: 上传端点速率限制

**Acceptance Criteria**:
- [x] 上传API添加速率限制: 10次/分钟 (per user)
- [x] 使用Upstash Rate Limit实现
- [x] 基于用户ID进行限制 (已登录用户)
- [x] 速率限制配置可通过环境变量调整

#### Test Scenarios

| ID           | Level       | Priority | Test                                    | Justification                          | Mitigates Risk |
|--------------|-------------|----------|-----------------------------------------|----------------------------------------|----------------|
| 4.1-UNIT-001 | Unit        | P0       | 验证 checkUploadRateLimit 基本功能     | 纯函数逻辑，隔离测试核心限流算法       | -              |
| 4.1-UNIT-002 | Unit        | P0       | 验证限流配置 (10次/分钟)               | 确保配置参数正确                       | -              |
| 4.1-UNIT-003 | Unit        | P0       | 验证基于 userId 的限流键生成           | 确保不同用户独立限流                   | -              |
| 4.1-INT-001  | Integration | P0       | 验证上传端点集成限流中间件             | 验证限流逻辑正确集成到 API             | -              |
| 4.1-INT-002  | Integration | P0       | 验证 10 次请求全部成功                 | 验证限流阈值设置正确                   | -              |
| 4.1-INT-003  | Integration | P0       | 验证第 11 次请求返回 429               | 边界测试，验证限流触发点               | -              |
| 4.1-INT-004  | Integration | P1       | 验证不同用户独立限流                   | 多用户场景，确保限流隔离               | TECH-001       |

**Coverage**: ✅ AC1 完全覆盖

---

### AC2: 超限响应处理

**Acceptance Criteria**:
- [x] 超过限制返回 HTTP 429 状态码
- [x] 响应包含 `Retry-After` 头 (秒数)
- [x] 响应体包含友好的错误消息 (中文)
- [x] 响应体包含限制详情 (当前次数、限制次数、重置时间)

#### Test Scenarios

| ID           | Level       | Priority | Test                                    | Justification                          | Mitigates Risk |
|--------------|-------------|----------|-----------------------------------------|----------------------------------------|----------------|
| 4.1-INT-005  | Integration | P0       | 验证 429 响应状态码                     | HTTP 标准合规性测试                    | -              |
| 4.1-INT-006  | Integration | P0       | 验证 Retry-After 头存在且正确          | 客户端重试逻辑依赖此头                 | -              |
| 4.1-INT-007  | Integration | P0       | 验证响应体错误消息为中文                | 用户体验测试                           | BUS-001        |
| 4.1-INT-008  | Integration | P0       | 验证响应体包含限制详情                 | 透明度和可调试性测试                   | BUS-001        |
| 4.1-E2E-001  | E2E         | P1       | 用户连续上传触发限制并看到友好提示     | 完整用户旅程测试                       | BUS-001        |

**Coverage**: ✅ AC2 完全覆盖

---

### AC3: 测试覆盖

**Acceptance Criteria**:
- [x] 单元测试: 验证速率限制逻辑
- [x] 集成测试: 验证限制生效 (连续11次请求)
- [x] 集成测试: 验证重置时间后可以继续上传
- [x] 边界测试: 第10次成功、第11次失败

#### Test Scenarios

| ID           | Level       | Priority | Test                                    | Justification                          | Mitigates Risk |
|--------------|-------------|----------|-----------------------------------------|----------------------------------------|----------------|
| 4.1-UNIT-004 | Unit        | P0       | Mock Redis 响应测试限流逻辑            | 单元测试核心算法，不依赖外部服务       | -              |
| 4.1-INT-003  | Integration | P0       | 连续 11 次请求，第 11 次失败           | **已在 AC1 中定义**                    | -              |
| 4.1-INT-009  | Integration | P1       | 1 分钟后限制重置测试                   | 验证时间窗口逻辑正确                   | -              |

**Coverage**: ✅ AC3 完全覆盖

---

### AC4: 日志和监控

**Acceptance Criteria**:
- [x] 记录超限事件到日志 (用户ID、IP、时间)
- [x] 日志级别为 `warn`
- [x] 日志包含 `rateLimitExceeded` 标记便于监控

#### Test Scenarios

| ID           | Level       | Priority | Test                                    | Justification                          | Mitigates Risk |
|--------------|-------------|----------|-----------------------------------------|----------------------------------------|----------------|
| 4.1-UNIT-005 | Unit        | P0       | 验证日志记录函数调用                   | 隔离测试日志逻辑                       | OPS-002        |
| 4.1-UNIT-006 | Unit        | P0       | 验证日志内容包含必要字段               | 确保日志可用于监控和调试               | OPS-002        |
| 4.1-INT-010  | Integration | P1       | 触发限制后验证日志实际输出             | 端到端验证日志流程                     | OPS-002        |

**Coverage**: ✅ AC4 完全覆盖

---

### Additional: 风险缓解测试

基于 Risk Profile (4.1-risk-20250115.md) 中识别的风险，额外设计测试。

#### Risk-Driven Test Scenarios

| ID           | Level       | Priority | Test                                    | Justification                          | Mitigates Risk |
|--------------|-------------|----------|-----------------------------------------|----------------------------------------|----------------|
| 4.1-UNIT-007 | Unit        | P0       | Redis 超时场景测试（降级策略）         | 验证 OPS-001 缓解措施生效              | OPS-001        |
| 4.1-UNIT-008 | Unit        | P0       | Redis 错误场景测试（降级策略）         | 验证 OPS-001 缓解措施生效              | OPS-001        |
| 4.1-INT-011  | Integration | P0       | Redis 不可用时系统仍可用               | 完整验证降级流程                       | OPS-001        |
| 4.1-INT-012  | Integration | P2       | 性能测试: 延迟 < 50ms (P95)            | 验证 PERF-001 性能要求                 | PERF-001       |
| 4.1-E2E-002  | E2E         | P2       | 多账号攻击模拟                         | 记录 TECH-001 行为，为后续改进提供数据 | TECH-001       |

**Coverage**: ✅ 所有 High 和 Medium 风险都有对应测试

---

## Risk Coverage Matrix

将测试场景映射到已识别的风险：

| Risk ID   | Risk Title                        | Score | Test IDs                             | Coverage Status |
|-----------|-----------------------------------|-------|--------------------------------------|-----------------|
| OPS-001   | Redis 服务不可用                  | 6     | 4.1-UNIT-007, 4.1-UNIT-008, 4.1-INT-011 | ✅ 充分覆盖    |
| TECH-001  | 多账号攻击绕过                    | 4     | 4.1-INT-004, 4.1-E2E-002             | ⚠️  部分覆盖   |
| PERF-001  | Redis 延迟影响                    | 4     | 4.1-INT-012                          | ✅ 有覆盖      |
| OPS-002   | 日志量激增                        | 4     | 4.1-UNIT-005, 4.1-UNIT-006, 4.1-INT-010 | ✅ 充分覆盖  |
| DATA-001  | Redis 数据丢失                    | 2     | -                                    | ⚠️  无需测试（依赖 Upstash SLA）|
| BUS-001   | 合法用户误限制                    | 3     | 4.1-INT-007, 4.1-INT-008, 4.1-E2E-001 | ✅ 充分覆盖  |

**覆盖度评估**: 
- ✅ 所有 P0 风险有测试覆盖
- ⚠️  TECH-001 和 DATA-001 为接受风险，部分覆盖或无覆盖可接受

---

## Detailed Test Specifications

### Unit Tests (8 scenarios)

#### 4.1-UNIT-001: 验证 checkUploadRateLimit 基本功能

**Priority**: P0  
**Level**: Unit  
**File**: `tests/unit/lib/rateLimit.test.ts`

**Setup**:
```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { checkUploadRateLimit } from '@/lib/rateLimit'
```

**Test Steps**:
1. Mock Upstash Rate Limit 返回成功响应
2. 调用 `checkUploadRateLimit('user_test_123')`
3. 验证返回值结构

**Expected Results**:
```typescript
{
  success: true,
  limit: 10,
  remaining: 9,  // 或其他正数
  reset: <timestamp>
}
```

**Assertions**:
- `result.success === true`
- `result.limit === 10`
- `result.remaining >= 0`
- `typeof result.reset === 'number'`

---

#### 4.1-UNIT-002: 验证限流配置 (10次/分钟)

**Priority**: P0  
**Level**: Unit  
**File**: `tests/unit/lib/rateLimit.test.ts`

**Test Steps**:
1. 读取 `uploadRateLimit` 配置
2. 验证 limiter 类型为 `slidingWindow`
3. 验证参数: `10` requests per `1 m`

**Expected Results**:
- Limiter 配置: `Ratelimit.slidingWindow(10, '1 m')`
- Prefix: `'ratelimit:upload'`

---

#### 4.1-UNIT-003: 验证基于 userId 的限流键生成

**Priority**: P0  
**Level**: Unit  
**File**: `tests/unit/lib/rateLimit.test.ts`

**Test Steps**:
1. 调用 `checkUploadRateLimit('user_123')`
2. 验证 Redis key 为 `ratelimit:upload:upload:user_123`

**Expected Results**:
- 不同 userId 生成不同的 key
- Key 格式一致

---

#### 4.1-UNIT-004: Mock Redis 响应测试限流逻辑

**Priority**: P0  
**Level**: Unit  
**File**: `tests/unit/lib/rateLimit.test.ts`

**Test Steps**:
1. Mock `uploadRateLimit.limit()` 返回 `success: false`
2. 调用 `checkUploadRateLimit('user_456')`
3. 验证返回超限状态

**Expected Results**:
```typescript
{
  success: false,
  limit: 10,
  remaining: 0,
  reset: <timestamp>
}
```

---

#### 4.1-UNIT-005: 验证日志记录函数调用

**Priority**: P0  
**Level**: Unit  
**File**: `tests/unit/api/upload-logging.test.ts`

**Test Steps**:
1. Mock `console.warn`
2. 模拟超限场景
3. 验证 `console.warn` 被调用

**Expected Results**:
- `console.warn` 被调用 1 次
- 调用参数包含 `event: 'rateLimitExceeded'`

---

#### 4.1-UNIT-006: 验证日志内容包含必要字段

**Priority**: P0  
**Level**: Unit  
**File**: `tests/unit/api/upload-logging.test.ts`

**Test Steps**:
1. Mock `console.warn`
2. 触发超限日志
3. 验证日志对象包含所有必要字段

**Expected Log Object**:
```typescript
{
  event: 'rateLimitExceeded',
  userId: 'user_123',
  ip: '192.168.1.1',
  endpoint: '/api/documents/upload',
  timestamp: '2025-01-15T...'
}
```

---

#### 4.1-UNIT-007: Redis 超时场景测试（降级策略）

**Priority**: P0  
**Level**: Unit  
**File**: `tests/unit/lib/rateLimit.test.ts`

**Test Steps**:
1. Mock Redis 操作超时（抛出 TimeoutError）
2. 调用 `checkUploadRateLimit('user_789')`
3. 验证降级策略生效

**Expected Results**:
- 函数不抛出异常
- 返回降级响应（允许通过或使用内存限流）
- 记录告警日志

**Mitigates**: OPS-001 (High Risk)

---

#### 4.1-UNIT-008: Redis 错误场景测试（降级策略）

**Priority**: P0  
**Level**: Unit  
**File**: `tests/unit/lib/rateLimit.test.ts`

**Test Steps**:
1. Mock Redis 连接错误（抛出 ConnectionError）
2. 调用 `checkUploadRateLimit('user_101')`
3. 验证降级策略生效

**Expected Results**:
- 函数不抛出异常
- 系统仍然可用（降级模式）
- 告警日志包含错误详情

**Mitigates**: OPS-001 (High Risk)

---

### Integration Tests (8 scenarios)

#### 4.1-INT-001: 验证上传端点集成限流中间件

**Priority**: P0  
**Level**: Integration  
**File**: `tests/integration/api/upload-rate-limit.test.ts`

**Setup**:
```typescript
import { POST as uploadDocument } from '@/app/api/documents/upload/route'
import { createMockRequest, createMockSession } from '@/tests/helpers'
```

**Test Steps**:
1. 创建认证的测试请求
2. 调用上传 API
3. 验证速率限制逻辑被执行

**Expected Results**:
- 响应包含 `X-RateLimit-*` 头
- 响应正常（未超限时）

---

#### 4.1-INT-002: 验证 10 次请求全部成功

**Priority**: P0  
**Level**: Integration  
**File**: `tests/integration/api/upload-rate-limit.test.ts`

**Test Steps**:
1. 连续发送 10 次上传请求（同一用户）
2. 验证所有请求都返回 200 或 201

**Expected Results**:
```typescript
for (let i = 1; i <= 10; i++) {
  const res = await uploadDocument(req)
  expect(res.status).not.toBe(429)
  expect(res.headers.get('X-RateLimit-Remaining')).toBe(String(10 - i))
}
```

---

#### 4.1-INT-003: 验证第 11 次请求返回 429 (边界测试)

**Priority**: P0  
**Level**: Integration  
**File**: `tests/integration/api/upload-rate-limit.test.ts`

**Test Steps**:
1. 连续发送 11 次上传请求
2. 验证前 10 次成功，第 11 次失败

**Expected Results**:
- Request 1-10: `status !== 429`
- Request 11: `status === 429`
- Request 11 响应体包含错误消息

**Critical**: 这是最重要的边界测试

---

#### 4.1-INT-004: 验证不同用户独立限流

**Priority**: P1  
**Level**: Integration  
**File**: `tests/integration/api/upload-rate-limit.test.ts`

**Test Steps**:
1. 用户 A 上传 10 次
2. 用户 B 上传 10 次
3. 验证两个用户都不被限制

**Expected Results**:
- 用户 A: 10 次全部成功
- 用户 B: 10 次全部成功
- 限流隔离生效

**Mitigates**: TECH-001 (验证单用户限制有效)

---

#### 4.1-INT-005: 验证 429 响应状态码

**Priority**: P0  
**Level**: Integration  
**File**: `tests/integration/api/upload-rate-limit.test.ts`

**Test Steps**:
1. 触发速率限制（11 次请求）
2. 验证响应状态码

**Expected Results**:
```typescript
const response = await uploadDocument(req11)
expect(response.status).toBe(429)
```

---

#### 4.1-INT-006: 验证 Retry-After 头存在且正确

**Priority**: P0  
**Level**: Integration  
**File**: `tests/integration/api/upload-rate-limit.test.ts`

**Test Steps**:
1. 触发速率限制
2. 读取 `Retry-After` 头
3. 验证值为正整数（秒）

**Expected Results**:
```typescript
const retryAfter = response.headers.get('Retry-After')
expect(retryAfter).toBeTruthy()
expect(Number(retryAfter)).toBeGreaterThan(0)
expect(Number(retryAfter)).toBeLessThanOrEqual(60)
```

---

#### 4.1-INT-007: 验证响应体错误消息为中文

**Priority**: P0  
**Level**: Integration  
**File**: `tests/integration/api/upload-rate-limit.test.ts`

**Test Steps**:
1. 触发速率限制
2. 解析响应体
3. 验证错误消息为中文

**Expected Results**:
```typescript
const body = await response.json()
expect(body.error).toBe('上传过于频繁，请稍后再试')
```

**Mitigates**: BUS-001 (用户体验)

---

#### 4.1-INT-008: 验证响应体包含限制详情

**Priority**: P0  
**Level**: Integration  
**File**: `tests/integration/api/upload-rate-limit.test.ts`

**Test Steps**:
1. 触发速率限制
2. 解析响应体
3. 验证 `details` 字段

**Expected Results**:
```typescript
const body = await response.json()
expect(body.details).toMatchObject({
  limit: 10,
  remaining: 0,
  retryAfter: expect.any(Number),
  resetAt: expect.any(String)  // ISO timestamp
})
```

**Mitigates**: BUS-001 (透明度和可调试性)

---

#### 4.1-INT-009: 1 分钟后限制重置测试

**Priority**: P1  
**Level**: Integration  
**File**: `tests/integration/api/upload-rate-limit.test.ts`

**Test Steps**:
1. 上传 11 次（触发限制）
2. 等待 61 秒（或使用 fake timers）
3. 再次上传，验证成功

**Expected Results**:
- 第 11 次请求: 429
- 等待 61 秒后
- 第 12 次请求: 成功 (200/201)

**Note**: 使用 `vi.useFakeTimers()` 加速测试

---

#### 4.1-INT-010: 触发限制后验证日志实际输出

**Priority**: P1  
**Level**: Integration  
**File**: `tests/integration/api/upload-rate-limit.test.ts`

**Test Steps**:
1. Mock `console.warn`
2. 触发速率限制
3. 验证日志输出

**Expected Results**:
- `console.warn` 被调用
- 日志包含完整的必要字段

**Mitigates**: OPS-002 (日志验证)

---

#### 4.1-INT-011: Redis 不可用时系统仍可用

**Priority**: P0  
**Level**: Integration  
**File**: `tests/integration/api/upload-rate-limit.test.ts`

**Test Steps**:
1. Mock Upstash Rate Limit 抛出错误
2. 尝试上传文档
3. 验证请求成功（降级模式）

**Expected Results**:
- 请求不返回 500 错误
- 请求成功（200/201）或返回业务错误
- 降级告警日志存在

**Mitigates**: OPS-001 (Critical - 系统可用性)

---

#### 4.1-INT-012: 性能测试 - 延迟 < 50ms (P95)

**Priority**: P2  
**Level**: Integration (Performance)  
**File**: `tests/performance/upload-rate-limit-perf.test.ts`

**Test Steps**:
1. 记录添加限流前的基准延迟（如果可能）
2. 发送 100 次上传请求
3. 测量每次请求的 "速率限制检查" 延迟
4. 计算 P95 延迟

**Expected Results**:
- P95 延迟 < 50ms
- 平均延迟 < 30ms

**Mitigates**: PERF-001 (性能要求)

**Note**: 需要在真实 Redis 环境运行，或使用 Redis mock 但标记为手动性能测试

---

### E2E Tests (2 scenarios)

#### 4.1-E2E-001: 用户连续上传触发限制并看到友好提示

**Priority**: P1  
**Level**: E2E  
**File**: `tests/e2e/upload-rate-limit.spec.ts`

**Setup**:
- 使用真实浏览器（Playwright/Puppeteer）
- 登录测试用户

**Test Steps**:
1. 用户访问上传页面
2. 连续选择并上传 11 个文件
3. 观察 UI 反馈

**Expected Results**:
- 前 10 次上传: 显示成功
- 第 11 次上传: 显示错误提示
- 错误提示为中文: "上传过于频繁，请稍后再试"
- 显示重试时间

**User Journey Validation**:
- 验证完整的用户体验流程
- 确保错误消息对用户友好

**Mitigates**: BUS-001 (用户体验)

---

#### 4.1-E2E-002: 多账号攻击模拟

**Priority**: P2  
**Level**: E2E  
**File**: `tests/e2e/multi-account-attack.spec.ts`

**Setup**:
- 创建 3 个测试账号
- 准备测试文件

**Test Steps**:
1. 账号 A: 上传 10 次
2. 账号 B: 上传 10 次
3. 账号 C: 上传 10 次
4. 记录总请求数和成功数

**Expected Results**:
- 总请求数: 30
- 总成功数: 30
- 单账号限制生效，但总量未被限制

**Purpose**: 
- 记录 TECH-001 风险的实际行为
- 为后续添加 IP 限制提供基线数据

**Mitigates**: TECH-001 (部分 - 记录行为)

---

## Recommended Execution Order

### Phase 1: 快速验证（单元测试）

**目标**: 在 Code Review 前验证核心逻辑

1. 4.1-UNIT-001: 基本功能 ✅
2. 4.1-UNIT-002: 配置验证 ✅
3. 4.1-UNIT-003: Key 生成 ✅
4. 4.1-UNIT-004: Mock Redis ✅
5. 4.1-UNIT-007: Redis 超时降级 🔴 (Critical)
6. 4.1-UNIT-008: Redis 错误降级 🔴 (Critical)

**预计时间**: ~10 分钟

---

### Phase 2: 集成验证（P0 集成测试）

**目标**: QA Gate 前验证 API 集成

7. 4.1-INT-001: 集成验证 ✅
8. 4.1-INT-002: 10 次成功 ✅
9. 4.1-INT-003: 第 11 次失败 🔴 (边界测试)
10. 4.1-INT-005: 429 状态码 ✅
11. 4.1-INT-006: Retry-After 头 ✅
12. 4.1-INT-007: 中文错误消息 ✅
13. 4.1-INT-008: 限制详情 ✅
14. 4.1-INT-011: Redis 不可用降级 🔴 (Critical)

**预计时间**: ~15 分钟

---

### Phase 3: 日志和监控验证

**目标**: 确保可观测性

15. 4.1-UNIT-005: 日志调用 ✅
16. 4.1-UNIT-006: 日志内容 ✅
17. 4.1-INT-010: 实际日志输出 ✅

**预计时间**: ~5 分钟

---

### Phase 4: 扩展测试（P1-P2）

**目标**: 完整性和性能验证

18. 4.1-INT-004: 多用户隔离 ✅
19. 4.1-INT-009: 时间重置 ✅
20. 4.1-INT-012: 性能测试 ⚡ (如有时间)
21. 4.1-E2E-001: 用户体验 ✅ (如有时间)
22. 4.1-E2E-002: 多账号攻击 🔬 (观察性测试)

**预计时间**: ~20 分钟

---

## Test Data Requirements

### Mock 用户数据

```typescript
const testUsers = {
  user_normal: {
    id: 'user_test_normal_123',
    email: 'normal@example.com',
    session: { /* valid session */ }
  },
  user_attacker: {
    id: 'user_test_attacker_456',
    email: 'attacker@example.com',
    session: { /* valid session */ }
  },
  user_multi_a: {
    id: 'user_test_multi_a',
    email: 'multi_a@example.com',
    session: { /* valid session */ }
  },
  user_multi_b: {
    id: 'user_test_multi_b',
    email: 'multi_b@example.com',
    session: { /* valid session */ }
  },
  user_multi_c: {
    id: 'user_test_multi_c',
    email: 'multi_c@example.com',
    session: { /* valid session */ }
  }
}
```

### 测试文件

```typescript
const testFiles = {
  small: new File(['small content'], 'small.txt', { type: 'text/plain' }),
  medium: new File([new ArrayBuffer(1024 * 100)], 'medium.pdf', { type: 'application/pdf' }),
  large: new File([new ArrayBuffer(1024 * 1024 * 5)], 'large.pdf', { type: 'application/pdf' })
}
```

### Redis Mock 响应

```typescript
const mockRedisResponses = {
  success: {
    success: true,
    limit: 10,
    remaining: 5,
    reset: Date.now() + 60000
  },
  rateLimited: {
    success: false,
    limit: 10,
    remaining: 0,
    reset: Date.now() + 30000
  },
  error: new Error('Redis connection failed'),
  timeout: new Error('Operation timeout')
}
```

---

## Test Environment Requirements

### 开发环境

**Required**:
- Node.js 18+
- Vitest 配置
- Mock 工具 (vi.mock)
- 测试用 Redis (Upstash 或 local Redis)

**Optional**:
- Playwright (for E2E)
- k6 (for performance testing)

---

### CI/CD 环境

**Must Have**:
- 单元测试和集成测试在 CI 中运行
- 测试失败阻止 merge

**Optional**:
- 性能测试在每日 nightly build 运行
- E2E 测试在 staging 环境运行

---

## Coverage Goals

### 代码覆盖率目标

| Component                             | Target Coverage | Rationale                              |
|---------------------------------------|-----------------|----------------------------------------|
| `src/lib/rateLimit.ts`               | ≥ 90%           | 核心限流逻辑，高覆盖率必需             |
| `src/app/api/documents/upload/route.ts` (限流部分) | ≥ 85% | API 集成点，重点覆盖限流分支 |
| 日志逻辑                              | ≥ 80%           | 监控和可观测性代码                     |

### 功能覆盖率目标

- ✅ 所有 AC 有测试覆盖: 100%
- ✅ 所有边界情况有测试: 100%
- ✅ 所有 High Risk 有缓解测试: 100%
- ⚠️  Medium/Low Risk: > 75%

---

## Test Automation Strategy

### 自动化优先级

**Tier 1: 必须自动化 (CI/CD)**
- 所有单元测试 (4.1-UNIT-001 ~ 4.1-UNIT-008)
- 所有 P0 集成测试 (4.1-INT-001 ~ 4.1-INT-008, 4.1-INT-011)

**Tier 2: 应该自动化 (Nightly)**
- P1 集成测试 (4.1-INT-004, 4.1-INT-009, 4.1-INT-010)
- 性能测试 (4.1-INT-012)

**Tier 3: 可以手动 (按需)**
- E2E 测试 (4.1-E2E-001, 4.1-E2E-002)

---

## Quality Checklist

在提交 QA Gate 前，确认:

- [ ] 所有 P0 测试通过 (18/18)
- [ ] 代码覆盖率 ≥ 85% (限流相关代码)
- [ ] 边界测试 (第 10 vs 第 11 次) 通过
- [ ] Redis 降级测试通过 (OPS-001)
- [ ] 性能测试通过 (延迟 < 50ms P95)
- [ ] 日志输出验证通过
- [ ] 至少一个 E2E 测试执行验证

---

## Test Execution Report Template

```markdown
# Test Execution Report: Story 4.1

**Date**: {date}
**Executor**: {name}

## Summary

- Total Tests: 18
- Passed: {X}
- Failed: {Y}
- Skipped: {Z}

## P0 Tests Status

- Unit Tests: {X/8} ✅
- Integration Tests: {Y/8} ✅
- E2E Tests: {Z/2} ✅

## Coverage

- Line Coverage: {X}%
- Branch Coverage: {Y}%
- Function Coverage: {Z}%

## Critical Test Results

### OPS-001 Mitigation (Redis 降级)
- 4.1-UNIT-007: ✅ PASS
- 4.1-UNIT-008: ✅ PASS
- 4.1-INT-011: ✅ PASS

### Boundary Test
- 4.1-INT-003 (第 11 次失败): ✅ PASS

## Failed Tests

{List any failed tests with details}

## Performance Metrics

- Rate Limit Check Latency (P95): {X} ms
- Target: < 50ms
- Status: {PASS/FAIL}

## Recommendations

{Any recommendations based on test results}
```

---

## Integration with Quality Gate

### Gate YAML Block

```yaml
# test_design (paste into gate file):
test_design:
  scenarios_total: 18
  by_level:
    unit: 8
    integration: 8
    e2e: 2
  by_priority:
    p0: 12
    p1: 4
    p2: 2
  coverage_gaps: []  # No gaps - all ACs covered
  risk_coverage:
    ops_001: covered  # Redis降级测试
    tech_001: partial # 单用户限制已测试，多账号攻击记录性测试
    perf_001: covered # 性能测试
    ops_002: covered  # 日志测试
    bus_001: covered  # 用户体验测试
```

---

## Summary for Review Task

**测试设计完成** ✅

**关键测试场景**:
- 🔴 **Critical**: Redis 降级测试 (4.1-UNIT-007/008, 4.1-INT-011)
- 🔴 **Critical**: 边界测试 (4.1-INT-003)
- ✅ **Required**: 所有 AC 覆盖 (18 个测试场景)
- ⚡ **Performance**: 延迟 < 50ms (4.1-INT-012)

**覆盖度**:
- AC 覆盖率: 100% ✅
- 风险覆盖率: 100% (High/Medium risks) ✅
- 代码覆盖率目标: ≥ 85% ✅

**推荐执行顺序**:
1. Phase 1: 单元测试 (10 min)
2. Phase 2: P0 集成测试 (15 min)
3. Phase 3: 日志验证 (5 min)
4. Phase 4: 扩展测试 (20 min, optional)

**下一步**: 实施测试并生成执行报告

---

**Hook Line for Review Task**:
```
Test design matrix: docs/qa/assessments/4.1-test-design-20250115.md
P0 tests identified: 12
```

