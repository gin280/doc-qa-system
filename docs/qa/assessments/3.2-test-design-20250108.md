# Test Design: Story 3.2 - RAG向量检索实现

**Date**: 2025-01-08  
**Designer**: Quinn (测试架构师)  
**Story**: 3.2 - RAG向量检索实现

---

## Test Strategy Overview

- **Total Test Scenarios**: 67
- **Unit Tests**: 32 (48%)
- **Integration Tests**: 25 (37%)
- **E2E Tests**: 10 (15%)
- **Priority Distribution**: 
  - P0: 28 scenarios (42%) - 核心功能和关键风险
  - P1: 24 scenarios (36%) - 重要功能和错误处理
  - P2: 15 scenarios (22%) - 边界条件和优化验证

**测试重点**:
1. **检索质量验证** - 人工评估 + 自动化回归
2. **性能测试** - 延迟、并发、负载
3. **故障容错** - LLM API、Redis、pgvector
4. **安全测试** - API密钥保护、隐私合规

---

## Test Scenarios by Acceptance Criteria

### AC1: 创建查询向量化服务

#### Unit Tests

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 3.2-UNIT-001 | Unit | P0 | 正常查询向量化成功 | 核心功能验证 |
| 3.2-UNIT-002 | Unit | P0 | 向量维度验证（1536维） | 防止维度不匹配 (TECH-002) |
| 3.2-UNIT-003 | Unit | P1 | 输入验证：空字符串被拒绝 | 边界条件 |
| 3.2-UNIT-004 | Unit | P1 | 输入验证：超长查询（>1000字符）被拒绝 | 边界条件 |
| 3.2-UNIT-005 | Unit | P1 | 错误处理：LLM API返回空向量 | 错误路径 |
| 3.2-UNIT-006 | Unit | P0 | 错误处理：API超时（>3秒） | TECH-001风险缓解 |
| 3.2-UNIT-007 | Unit | P0 | 错误处理：API配额超限 | 成本控制 |
| 3.2-UNIT-008 | Unit | P1 | 性能：向量化耗时 < 300ms | 性能目标验证 |

**Test Implementation Example**:

```typescript
// tests/unit/services/rag/queryVectorizer.test.ts

describe('QueryVectorizer', () => {
  let vectorizer: QueryVectorizer
  let mockLLMRepo: jest.Mocked<ILLMRepository>

  beforeEach(() => {
    mockLLMRepo = {
      generateEmbeddings: jest.fn()
    } as any
    
    vectorizer = new QueryVectorizer()
    // Inject mock
  })

  // 3.2-UNIT-001
  it('should vectorize query successfully', async () => {
    const mockVector = new Array(1536).fill(0.1)
    mockLLMRepo.generateEmbeddings.mockResolvedValue([mockVector])

    const result = await vectorizer.vectorizeQuery('什么是React?')

    expect(result).toHaveLength(1536)
    expect(mockLLMRepo.generateEmbeddings).toHaveBeenCalledWith(['什么是React?'])
  })

  // 3.2-UNIT-002
  it('should reject vector with wrong dimension', async () => {
    const wrongVector = new Array(1024).fill(0.1) // 错误维度
    mockLLMRepo.generateEmbeddings.mockResolvedValue([wrongVector])

    await expect(
      vectorizer.vectorizeQuery('test')
    ).rejects.toThrow('Invalid vector dimension: 1024')
  })

  // 3.2-UNIT-006
  it('should handle API timeout', async () => {
    mockLLMRepo.generateEmbeddings.mockRejectedValue(
      new Error('timeout')
    )

    await expect(
      vectorizer.vectorizeQuery('test')
    ).rejects.toThrow('EMBEDDING_TIMEOUT')
  })

  // 3.2-UNIT-008
  it('should complete within 300ms', async () => {
    const mockVector = new Array(1536).fill(0.1)
    mockLLMRepo.generateEmbeddings.mockResolvedValue([mockVector])

    const start = Date.now()
    await vectorizer.vectorizeQuery('test')
    const elapsed = Date.now() - start

    expect(elapsed).toBeLessThan(300)
  })
})
```

---

### AC2: 实现向量相似度检索

#### Unit Tests

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 3.2-UNIT-009 | Unit | P0 | pgvector检索返回Top-K结果 | 核心检索功能 |
| 3.2-UNIT-010 | Unit | P0 | 相似度阈值过滤（minScore=0.7） | 质量保证 |
| 3.2-UNIT-011 | Unit | P1 | 过滤条件：documentId限定 | 权限隔离 |
| 3.2-UNIT-012 | Unit | P1 | 过滤条件：userId权限验证 | 安全性 |
| 3.2-UNIT-013 | Unit | P1 | 结果排序：相似度降序 | 结果质量 |
| 3.2-UNIT-014 | Unit | P0 | 查询延迟 < 200ms（本地测试） | 性能目标 |
| 3.2-UNIT-015 | Unit | P2 | Top-K边界：最大20 | 边界条件 |
| 3.2-UNIT-016 | Unit | P1 | 错误处理：pgvector查询失败 | 错误路径 |

**Test Implementation Example**:

```typescript
// tests/unit/infrastructure/vector/pgvector.search.test.ts

describe('PgVectorRepository.search', () => {
  let repository: PgVectorRepository
  let mockDb: any

  beforeEach(() => {
    mockDb = createMockDrizzleClient()
    repository = new PgVectorRepository()
  })

  // 3.2-UNIT-009
  it('should return top-K results', async () => {
    const queryVector = new Array(1536).fill(0.5)
    mockDb.mockReturnChunks(5) // Mock 5 chunks

    const results = await repository.search(queryVector, { topK: 5 })

    expect(results).toHaveLength(5)
    expect(results[0].score).toBeGreaterThan(results[1].score) // 降序
  })

  // 3.2-UNIT-010
  it('should filter by minScore threshold', async () => {
    const queryVector = new Array(1536).fill(0.5)
    mockDb.mockReturnChunksWithScores([0.9, 0.8, 0.65, 0.5, 0.3])

    const results = await repository.search(queryVector, { 
      topK: 5, 
      minScore: 0.7 
    })

    expect(results).toHaveLength(2) // 仅0.9和0.8通过
    expect(results.every(r => r.score >= 0.7)).toBe(true)
  })

  // 3.2-UNIT-011
  it('should filter by documentId', async () => {
    const queryVector = new Array(1536).fill(0.5)
    mockDb.mockReturnChunks(3, { documentId: 'doc-123' })

    const results = await repository.search(queryVector, {
      filter: { documentId: 'doc-123' }
    })

    expect(results.every(r => 
      r.metadata?.documentId === 'doc-123'
    )).toBe(true)
  })

  // 3.2-UNIT-014
  it('should complete search within 200ms', async () => {
    const queryVector = new Array(1536).fill(0.5)
    mockDb.mockReturnChunks(5)

    const start = Date.now()
    await repository.search(queryVector, { topK: 5 })
    const elapsed = Date.now() - start

    expect(elapsed).toBeLessThan(200)
  })
})
```

---

### AC3: 创建RAG检索服务

#### Unit Tests

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 3.2-UNIT-017 | Unit | P0 | 完整检索流程成功 | 端到端服务测试 |
| 3.2-UNIT-018 | Unit | P0 | 并行执行：权限验证+向量化 | PERF-003验证 |
| 3.2-UNIT-019 | Unit | P1 | 输入验证：空查询被拒绝 | 边界条件 |
| 3.2-UNIT-020 | Unit | P0 | 权限验证：用户无权访问文档 | 安全性 |
| 3.2-UNIT-021 | Unit | P0 | 文档状态验证：非READY状态 | 数据一致性 |
| 3.2-UNIT-022 | Unit | P1 | 结果去重：相同chunk只返回一次 | AC9要求 |
| 3.2-UNIT-023 | Unit | P1 | 结果排序：分数+索引双重排序 | 结果质量 |
| 3.2-UNIT-024 | Unit | P0 | 错误处理：无相关内容 | 用户体验 |

**Test Implementation Example**:

```typescript
// tests/unit/services/rag/retrievalService.test.ts

describe('RetrievalService', () => {
  let service: RetrievalService
  let mockVectorRepo: jest.Mocked<IVectorRepository>
  let mockDb: any

  beforeEach(() => {
    mockVectorRepo = createMockVectorRepo()
    mockDb = createMockDb()
    service = new RetrievalService()
  })

  // 3.2-UNIT-017
  it('should complete full retrieval flow', async () => {
    mockDb.mockDocument({ id: 'doc-1', status: 'READY', userId: 'user-1' })
    mockVectorRepo.search.mockResolvedValue([
      { id: 'chunk-1', score: 0.9, metadata: { content: '...' } }
    ])

    const result = await service.retrieveContext(
      '什么是React?',
      'doc-1',
      'user-1'
    )

    expect(result.chunks).toHaveLength(1)
    expect(result.query).toBe('什么是React?')
    expect(result.cached).toBe(false)
  })

  // 3.2-UNIT-018
  it('should execute verification and vectorization in parallel', async () => {
    mockDb.mockDocument({ id: 'doc-1', status: 'READY', userId: 'user-1' })
    const verifyTime = 100
    const vectorizeTime = 200

    const start = Date.now()
    await service.retrieveContext('test', 'doc-1', 'user-1')
    const elapsed = Date.now() - start

    // 并行执行应该接近max(verifyTime, vectorizeTime)
    expect(elapsed).toBeLessThan(verifyTime + vectorizeTime)
    expect(elapsed).toBeGreaterThan(Math.max(verifyTime, vectorizeTime))
  })

  // 3.2-UNIT-020
  it('should reject access to unauthorized document', async () => {
    mockDb.mockDocument({ id: 'doc-1', userId: 'other-user' })

    await expect(
      service.retrieveContext('test', 'doc-1', 'current-user')
    ).rejects.toThrow('DOCUMENT_NOT_FOUND')
  })

  // 3.2-UNIT-022
  it('should deduplicate chunks by ID', async () => {
    mockVectorRepo.search.mockResolvedValue([
      { id: 'chunk-1', score: 0.9, metadata: { content: '...' } },
      { id: 'chunk-1', score: 0.85, metadata: { content: '...' } }, // 重复
      { id: 'chunk-2', score: 0.8, metadata: { content: '...' } }
    ])

    const result = await service.retrieveContext('test', 'doc-1', 'user-1')

    expect(result.chunks).toHaveLength(2) // 去重后
    expect(new Set(result.chunks.map(c => c.id)).size).toBe(2)
  })
})
```

---

### AC5: Redis查询缓存实现

#### Unit Tests

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 3.2-UNIT-025 | Unit | P1 | 缓存键生成：MD5哈希一致性 | 缓存命中 |
| 3.2-UNIT-026 | Unit | P0 | 缓存读取：命中返回结果 | 核心缓存功能 |
| 3.2-UNIT-027 | Unit | P0 | 缓存读取：未命中返回null | 缓存未命中处理 |
| 3.2-UNIT-028 | Unit | P1 | 缓存写入：TTL=30分钟 | 缓存策略 |
| 3.2-UNIT-029 | Unit | P1 | 缓存失效：清除文档相关缓存 | DATA-001缓解 |
| 3.2-UNIT-030 | Unit | P0 | 降级处理：Redis不可用不影响主流程 | OPS-001缓解 |
| 3.2-UNIT-031 | Unit | P2 | 查询规范化：大小写和空格 | 缓存命中率优化 |
| 3.2-UNIT-032 | Unit | P1 | 错误处理：Redis连接超时 | 错误路径 |

**Test Implementation Example**:

```typescript
// tests/unit/services/rag/queryCacheService.test.ts

describe('QueryCacheService', () => {
  let service: QueryCacheService
  let mockRedis: jest.Mocked<Redis>

  beforeEach(() => {
    mockRedis = createMockRedis()
    service = new QueryCacheService()
  })

  // 3.2-UNIT-026
  it('should return cached result on hit', async () => {
    const cachedResult = {
      chunks: [{ id: 'chunk-1', content: '...' }],
      totalFound: 1,
      cached: false
    }
    mockRedis.get.mockResolvedValue(cachedResult)

    const result = await service.getCachedResult('doc-1', '什么是React?')

    expect(result).not.toBeNull()
    expect(result?.cached).toBe(true) // 标记为来自缓存
    expect(result?.chunks).toEqual(cachedResult.chunks)
  })

  // 3.2-UNIT-028
  it('should set cache with 30min TTL', async () => {
    const result = { chunks: [], totalFound: 0 }
    
    await service.setCachedResult('doc-1', 'test', result)

    expect(mockRedis.setex).toHaveBeenCalledWith(
      expect.any(String),
      30 * 60, // 30分钟
      expect.any(String)
    )
  })

  // 3.2-UNIT-029
  it('should invalidate all document caches', async () => {
    mockRedis.keys.mockResolvedValue([
      'rag:query:doc-1:hash1',
      'rag:query:doc-1:hash2'
    ])

    await service.invalidateDocumentCache('doc-1')

    expect(mockRedis.del).toHaveBeenCalledWith(
      'rag:query:doc-1:hash1',
      'rag:query:doc-1:hash2'
    )
  })

  // 3.2-UNIT-030
  it('should gracefully handle Redis unavailable', async () => {
    mockRedis.get.mockRejectedValue(new Error('Connection refused'))

    const result = await service.getCachedResult('doc-1', 'test')

    expect(result).toBeNull() // 降级返回null
    // 不应该抛出错误
  })
})
```

---

### AC6-AC10: API端点和集成场景

#### Integration Tests

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 3.2-INT-001 | Integration | P0 | POST /api/chat/query - 完整RAG检索成功 | 端到端功能 |
| 3.2-INT-002 | Integration | P0 | 检索结果格式符合RetrievalResult接口 | 契约测试 |
| 3.2-INT-003 | Integration | P0 | Top-K和阈值过滤正确应用 | 参数验证 |
| 3.2-INT-004 | Integration | P1 | 缓存命中：相同问题第二次调用 | 缓存功能 |
| 3.2-INT-005 | Integration | P1 | 缓存未命中：不同问题 | 缓存隔离 |
| 3.2-INT-006 | Integration | P0 | 权限验证：用户A无法访问用户B的文档 | 安全性 |
| 3.2-INT-007 | Integration | P0 | 文档状态验证：PENDING状态返回400 | 数据一致性 |
| 3.2-INT-008 | Integration | P0 | 向量化失败：返回503错误 | TECH-001验证 |
| 3.2-INT-009 | Integration | P1 | 向量化超时：返回504错误 | 超时处理 |
| 3.2-INT-010 | Integration | P1 | pgvector检索失败：返回500错误 | 错误处理 |
| 3.2-INT-011 | Integration | P0 | 无相关内容：返回友好消息 | 用户体验 |
| 3.2-INT-012 | Integration | P0 | 速率限制：超过30次/分钟 | 防滥用 |
| 3.2-INT-013 | Integration | P1 | 性能：P95延迟 < 500ms | PERF-002验证 |
| 3.2-INT-014 | Integration | P1 | 并发10请求：无冲突 | 并发安全 |
| 3.2-INT-015 | Integration | P0 | API密钥未泄露到响应 | SEC-002验证 |

**Test Implementation Example**:

```typescript
// tests/integration/api/rag-retrieval.test.ts

describe('POST /api/chat/query - RAG Retrieval', () => {
  let testUser: User
  let testDocument: Document

  beforeAll(async () => {
    await setupTestDatabase()
    testUser = await createTestUser()
    testDocument = await createTestDocument(testUser.id, {
      status: 'READY',
      chunks: await createTestChunks(10) // 10个测试chunks
    })
  })

  afterAll(async () => {
    await cleanupTestDatabase()
  })

  // 3.2-INT-001
  it('should complete full RAG retrieval successfully', async () => {
    const response = await request(app)
      .post('/api/chat/query')
      .set('Authorization', `Bearer ${testUser.token}`)
      .send({
        documentId: testDocument.id,
        question: '什么是React Hooks?',
        conversationId: 'test-conv-1'
      })

    expect(response.status).toBe(200)
    expect(response.body).toMatchObject({
      success: true,
      retrieval: {
        chunks: expect.any(Array),
        totalFound: expect.any(Number),
        cached: false,
        retrievalTime: expect.any(Number)
      }
    })
    expect(response.body.retrieval.chunks.length).toBeGreaterThan(0)
    expect(response.body.retrieval.chunks.length).toBeLessThanOrEqual(5)
  })

  // 3.2-INT-003
  it('should apply Top-K and minScore filters', async () => {
    const response = await request(app)
      .post('/api/chat/query')
      .set('Authorization', `Bearer ${testUser.token}`)
      .send({
        documentId: testDocument.id,
        question: 'test query'
      })

    const chunks = response.body.retrieval.chunks
    expect(chunks.length).toBeLessThanOrEqual(5) // Top-K=5
    expect(chunks.every(c => c.score >= 0.7)).toBe(true) // minScore=0.7
  })

  // 3.2-INT-004
  it('should return cached result on second identical query', async () => {
    const query = '什么是useState?'

    // 第一次调用
    const response1 = await request(app)
      .post('/api/chat/query')
      .set('Authorization', `Bearer ${testUser.token}`)
      .send({ documentId: testDocument.id, question: query })

    expect(response1.body.retrieval.cached).toBe(false)

    // 第二次调用（相同问题）
    const response2 = await request(app)
      .post('/api/chat/query')
      .set('Authorization', `Bearer ${testUser.token}`)
      .send({ documentId: testDocument.id, question: query })

    expect(response2.body.retrieval.cached).toBe(true)
    expect(response2.body.retrieval.retrievalTime).toBeLessThan(
      response1.body.retrieval.retrievalTime
    )
  })

  // 3.2-INT-006
  it('should reject access to other user document', async () => {
    const otherUser = await createTestUser()
    const otherDocument = await createTestDocument(otherUser.id)

    const response = await request(app)
      .post('/api/chat/query')
      .set('Authorization', `Bearer ${testUser.token}`)
      .send({
        documentId: otherDocument.id,
        question: 'test'
      })

    expect(response.status).toBe(404)
    expect(response.body.error).toContain('不存在或无权访问')
  })

  // 3.2-INT-008
  it('should handle LLM API failure gracefully', async () => {
    // Mock LLM API failure
    jest.spyOn(LLMRepository.prototype, 'generateEmbeddings')
      .mockRejectedValueOnce(new Error('API Error'))

    const response = await request(app)
      .post('/api/chat/query')
      .set('Authorization', `Bearer ${testUser.token}`)
      .send({
        documentId: testDocument.id,
        question: 'test'
      })

    expect(response.status).toBe(503)
    expect(response.body.error).toContain('AI服务暂时不可用')
  })

  // 3.2-INT-013
  it('should meet P95 latency target < 500ms', async () => {
    const latencies: number[] = []

    // 执行100次请求
    for (let i = 0; i < 100; i++) {
      const start = Date.now()
      await request(app)
        .post('/api/chat/query')
        .set('Authorization', `Bearer ${testUser.token}`)
        .send({
          documentId: testDocument.id,
          question: `test query ${i}`
        })
      latencies.push(Date.now() - start)
    }

    // 计算P95
    latencies.sort((a, b) => a - b)
    const p95 = latencies[Math.floor(latencies.length * 0.95)]

    expect(p95).toBeLessThan(500)
  })

  // 3.2-INT-015
  it('should not leak API key in response or logs', async () => {
    const response = await request(app)
      .post('/api/chat/query')
      .set('Authorization', `Bearer ${testUser.token}`)
      .send({
        documentId: testDocument.id,
        question: 'test'
      })

    // 检查响应中无API密钥
    const responseStr = JSON.stringify(response.body)
    expect(responseStr).not.toContain('sk-')
    expect(responseStr).not.toContain('OPENAI_API_KEY')
    
    // 检查日志（需要日志mock）
    const logs = getTestLogs()
    expect(logs.some(log => log.includes('sk-'))).toBe(false)
  })
})
```

---

### AC9: 检索质量验证

#### E2E Tests + Manual Tests

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 3.2-E2E-001 | E2E | P0 | 完整用户流程：选择文档→提问→查看检索结果 | 端到端验证 |
| 3.2-E2E-002 | E2E | P1 | 检索结果显示在UI（临时格式） | UI集成 |
| 3.2-E2E-003 | E2E | P1 | 缓存命中时响应更快 | 用户体验 |
| 3.2-E2E-004 | E2E | P0 | 错误消息友好显示 | 用户体验 |
| 3.2-MANUAL-001 | Manual | P0 | 人工质量评估：20个测试问题 | PERF-001缓解 |
| 3.2-MANUAL-002 | Manual | P1 | 不同文档类型检索质量 | 覆盖多样性 |
| 3.2-MANUAL-003 | Manual | P1 | 边缘问题表述质量 | 健壮性 |

**Manual Test Protocol**:

```markdown
## 人工质量评估协议 (3.2-MANUAL-001)

### 目标
验证Top-5检索准确率 >= 85%

### 测试数据准备
准备3个测试文档：
1. 技术文档（React官方文档，~50页）
2. 业务文档（产品需求文档，~30页）
3. 学术文档（研究论文，~20页）

### 测试问题（每个文档7-8个问题）

**技术文档问题**：
1. 什么是React Hooks？（事实性）
2. 如何使用useState管理状态？（操作性）
3. useEffect和useLayoutEffect的区别是什么？（比较性）
4. 为什么需要useCallback优化性能？（解释性）
5. React 18有哪些新特性？（事实性）
6. 如何避免useEffect的无限循环？（操作性）
7. 自定义Hook的最佳实践有哪些？（操作性）

**业务文档问题**：
1. 产品的核心功能是什么？（事实性）
2. 如何创建新用户账户？（操作性）
3. 免费版和付费版有什么区别？（比较性）
4. 为什么要实现这个功能？（解释性）
5. 产品的目标用户是谁？（事实性）

**学术文档问题**：
1. 研究的主要假设是什么？（事实性）
2. 实验方法是如何设计的？（操作性）
3. 这项研究与以往研究的不同在哪？（比较性）
4. 为什么选择这种研究方法？（解释性）

### 评估标准

对每个问题的Top-5结果：
- ✅ **相关** (2分): chunk内容直接回答问题或提供关键信息
- ⚠️ **部分相关** (1分): chunk包含相关关键词但信息不完整
- ❌ **不相关** (0分): chunk与问题无关

### 计算方法
准确率 = (相关结果数 + 0.5 × 部分相关结果数) / 总结果数

**目标**: >= 85%

### 评估表格

| 问题 | Chunk1 | Chunk2 | Chunk3 | Chunk4 | Chunk5 | 得分 | 准确率 |
|-----|--------|--------|--------|--------|--------|------|-------|
| Q1  | ✅(2)  | ✅(2)  | ⚠️(1)  | ❌(0)  | ❌(0)  | 5    | 50%   |
| ... | ...    | ...    | ...    | ...    | ...    | ...  | ...   |

**最终准确率**: (总得分 / (问题数 × 10)) × 100%
```

---

### Performance and Load Tests

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 3.2-PERF-001 | Performance | P0 | 向量化延迟：P50/P95/P99 | 性能基线 |
| 3.2-PERF-002 | Performance | P0 | 检索延迟：P50/P95/P99 | 性能基线 |
| 3.2-PERF-003 | Performance | P0 | 端到端延迟：P50/P95/P99 | PERF-002验证 |
| 3.2-PERF-004 | Performance | P1 | 并发10请求：延迟分布 | 并发性能 |
| 3.2-PERF-005 | Performance | P1 | 并发50请求：延迟分布 | 高并发 |
| 3.2-PERF-006 | Performance | P0 | 负载测试：1K向量规模 | 基线负载 |
| 3.2-PERF-007 | Performance | P1 | 负载测试：10K向量规模 | 成长期负载 |
| 3.2-PERF-008 | Performance | P2 | 负载测试：100K向量规模 | 规模化准备 |
| 3.2-PERF-009 | Performance | P1 | 稳定性测试：24小时持续查询 | 长期稳定性 |
| 3.2-PERF-010 | Performance | P1 | 缓存命中率测试：模拟重复查询 | BUS-002验证 |

**Performance Test Implementation**:

```typescript
// tests/performance/rag-retrieval.benchmark.ts

describe('RAG Retrieval Performance Benchmarks', () => {
  let testUser: User
  let testDocument: Document

  beforeAll(async () => {
    testUser = await createTestUser()
    testDocument = await createTestDocument(testUser.id, {
      status: 'READY',
      chunks: await createTestChunks(1000) // 1K chunks
    })
  })

  // 3.2-PERF-003
  it('should measure end-to-end latency distribution', async () => {
    const latencies: number[] = []
    const iterations = 100

    for (let i = 0; i < iterations; i++) {
      const start = performance.now()
      await request(app)
        .post('/api/chat/query')
        .set('Authorization', `Bearer ${testUser.token}`)
        .send({
          documentId: testDocument.id,
          question: `test query ${i}`
        })
      latencies.push(performance.now() - start)
    }

    latencies.sort((a, b) => a - b)
    const p50 = latencies[Math.floor(iterations * 0.5)]
    const p95 = latencies[Math.floor(iterations * 0.95)]
    const p99 = latencies[Math.floor(iterations * 0.99)]

    console.log('Latency Distribution:')
    console.log(`  P50: ${p50.toFixed(2)}ms`)
    console.log(`  P95: ${p95.toFixed(2)}ms`)
    console.log(`  P99: ${p99.toFixed(2)}ms`)

    // 目标验证
    expect(p95).toBeLessThan(500)
    expect(p99).toBeLessThan(1000)

    // 记录基线
    recordPerformanceBaseline('rag-retrieval-e2e', {
      p50, p95, p99,
      vectorCount: 1000,
      date: new Date()
    })
  })

  // 3.2-PERF-005
  it('should handle 50 concurrent requests', async () => {
    const concurrency = 50
    const latencies: number[] = []

    const promises = Array.from({ length: concurrency }, async (_, i) => {
      const start = performance.now()
      await request(app)
        .post('/api/chat/query')
        .set('Authorization', `Bearer ${testUser.token}`)
        .send({
          documentId: testDocument.id,
          question: `concurrent query ${i}`
        })
      const elapsed = performance.now() - start
      latencies.push(elapsed)
    })

    await Promise.all(promises)

    const avgLatency = latencies.reduce((a, b) => a + b) / latencies.length
    const maxLatency = Math.max(...latencies)

    console.log(`Concurrent ${concurrency} requests:`)
    console.log(`  Avg latency: ${avgLatency.toFixed(2)}ms`)
    console.log(`  Max latency: ${maxLatency.toFixed(2)}ms`)

    // 并发下延迟应该合理增加，但不应该线性增长
    expect(avgLatency).toBeLessThan(1000)
    expect(maxLatency).toBeLessThan(2000)
  })

  // 3.2-PERF-007
  it('should measure performance with 10K vectors', async () => {
    // 创建10K chunks的大文档
    const largeDocument = await createTestDocument(testUser.id, {
      status: 'READY',
      chunks: await createTestChunks(10000)
    })

    const latencies: number[] = []
    const iterations = 20

    for (let i = 0; i < iterations; i++) {
      const start = performance.now()
      await request(app)
        .post('/api/chat/query')
        .set('Authorization', `Bearer ${testUser.token}`)
        .send({
          documentId: largeDocument.id,
          question: `test query ${i}`
        })
      latencies.push(performance.now() - start)
    }

    const p95 = latencies.sort((a, b) => a - b)[Math.floor(iterations * 0.95)]

    console.log(`10K vectors P95 latency: ${p95.toFixed(2)}ms`)

    // 10K向量规模下仍应保持合理性能
    expect(p95).toBeLessThan(800) // 允许比1K慢一些
  })

  // 3.2-PERF-010
  it('should measure cache hit rate with repeated queries', async () => {
    const uniqueQueries = [
      '什么是React?',
      '如何使用useState?',
      '什么是useEffect?',
      'React性能优化方法',
      '自定义Hook最佳实践'
    ]

    let cacheHits = 0
    let totalRequests = 0

    // 每个查询执行5次
    for (const query of uniqueQueries) {
      for (let i = 0; i < 5; i++) {
        const response = await request(app)
          .post('/api/chat/query')
          .set('Authorization', `Bearer ${testUser.token}`)
          .send({ documentId: testDocument.id, question: query })

        if (response.body.retrieval.cached) {
          cacheHits++
        }
        totalRequests++
      }
    }

    const hitRate = (cacheHits / totalRequests) * 100

    console.log(`Cache hit rate: ${hitRate.toFixed(2)}%`)
    console.log(`Cache hits: ${cacheHits}/${totalRequests}`)

    // 期望：第2-5次调用应该命中缓存
    // 理论命中率: 80% (每5次调用中有4次命中)
    expect(hitRate).toBeGreaterThan(30) // 目标: > 30%
  })
})
```

---

### Failure and Fault Tolerance Tests

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 3.2-FAULT-001 | Integration | P0 | LLM API完全不可用 | TECH-001验证 |
| 3.2-FAULT-002 | Integration | P0 | LLM API间歇性超时 | 稳定性 |
| 3.2-FAULT-003 | Integration | P0 | LLM API返回429限流 | 配额管理 |
| 3.2-FAULT-004 | Integration | P0 | Redis完全不可用 | OPS-001验证 |
| 3.2-FAULT-005 | Integration | P1 | Redis间歇性连接失败 | 降级验证 |
| 3.2-FAULT-006 | Integration | P1 | pgvector查询超时 | 数据库故障 |
| 3.2-FAULT-007 | Integration | P1 | 数据库连接池耗尽 | PERF-004验证 |
| 3.2-FAULT-008 | Integration | P1 | 网络延迟高（>2秒） | 超时处理 |

**Fault Tolerance Test Implementation**:

```typescript
// tests/integration/api/rag-fault-tolerance.test.ts

describe('RAG Retrieval Fault Tolerance', () => {
  // 3.2-FAULT-001
  it('should handle complete LLM API failure', async () => {
    // Mock所有LLM providers都失败
    jest.spyOn(OpenAIRepository.prototype, 'generateEmbeddings')
      .mockRejectedValue(new Error('Service unavailable'))
    jest.spyOn(ZhipuRepository.prototype, 'generateEmbeddings')
      .mockRejectedValue(new Error('Service unavailable'))

    const response = await request(app)
      .post('/api/chat/query')
      .set('Authorization', `Bearer ${testUser.token}`)
      .send({ documentId: testDocument.id, question: 'test' })

    expect(response.status).toBe(503)
    expect(response.body.error).toContain('AI服务暂时不可用')
  })

  // 3.2-FAULT-003
  it('should handle LLM API rate limiting', async () => {
    jest.spyOn(LLMRepository.prototype, 'generateEmbeddings')
      .mockRejectedValue(new Error('quota exceeded'))

    const response = await request(app)
      .post('/api/chat/query')
      .set('Authorization', `Bearer ${testUser.token}`)
      .send({ documentId: testDocument.id, question: 'test' })

    expect(response.status).toBe(429)
    expect(response.body.error).toContain('配额')
  })

  // 3.2-FAULT-004
  it('should gracefully degrade when Redis is unavailable', async () => {
    // Mock Redis完全不可用
    jest.spyOn(Redis.prototype, 'get')
      .mockRejectedValue(new Error('Connection refused'))
    jest.spyOn(Redis.prototype, 'setex')
      .mockRejectedValue(new Error('Connection refused'))

    // 第一次请求（无缓存）
    const response1 = await request(app)
      .post('/api/chat/query')
      .set('Authorization', `Bearer ${testUser.token}`)
      .send({ documentId: testDocument.id, question: 'test' })

    expect(response1.status).toBe(200) // 降级成功
    expect(response1.body.retrieval.cached).toBe(false)

    // 第二次相同请求（仍无缓存，因为Redis不可用）
    const response2 = await request(app)
      .post('/api/chat/query')
      .set('Authorization', `Bearer ${testUser.token}`)
      .send({ documentId: testDocument.id, question: 'test' })

    expect(response2.status).toBe(200)
    expect(response2.body.retrieval.cached).toBe(false)
  })

  // 3.2-FAULT-007
  it('should handle database connection pool exhaustion', async () => {
    // 模拟并发请求耗尽连接池
    const concurrentRequests = 30 // 超过连接池大小

    const results = await Promise.allSettled(
      Array.from({ length: concurrentRequests }, () =>
        request(app)
          .post('/api/chat/query')
          .set('Authorization', `Bearer ${testUser.token}`)
          .send({ documentId: testDocument.id, question: 'test' })
      )
    )

    const successful = results.filter(r => r.status === 'fulfilled').length
    const failed = results.filter(r => r.status === 'rejected').length

    console.log(`Connection pool test: ${successful} succeeded, ${failed} failed`)

    // 至少应该有一半成功
    expect(successful).toBeGreaterThan(concurrentRequests / 2)
  })
})
```

---

### Security Tests

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 3.2-SEC-001 | Integration | P0 | API密钥不在响应中 | SEC-002验证 |
| 3.2-SEC-002 | Integration | P0 | API密钥不在日志中 | SEC-002验证 |
| 3.2-SEC-003 | Integration | P0 | API密钥不在错误消息中 | SEC-002验证 |
| 3.2-SEC-004 | Integration | P1 | 查询内容脱敏（日志仅50字符） | SEC-001验证 |
| 3.2-SEC-005 | Integration | P0 | 跨用户访问被阻止 | 安全隔离 |

**Security Test Implementation**:

```typescript
// tests/integration/security/api-key-protection.test.ts

describe('API Key Security', () => {
  // 3.2-SEC-001
  it('should never expose API key in response', async () => {
    const response = await request(app)
      .post('/api/chat/query')
      .set('Authorization', `Bearer ${testUser.token}`)
      .send({ documentId: testDocument.id, question: 'test' })

    const responseStr = JSON.stringify(response.body)
    
    // 检查常见API密钥模式
    expect(responseStr).not.toMatch(/sk-[a-zA-Z0-9]{20,}/) // OpenAI
    expect(responseStr).not.toMatch(/OPENAI_API_KEY/)
    expect(responseStr).not.toMatch(/api[_-]?key/i)
  })

  // 3.2-SEC-002
  it('should not log API keys', async () => {
    const logSpy = jest.spyOn(logger, 'info')
    const errorSpy = jest.spyOn(logger, 'error')

    await request(app)
      .post('/api/chat/query')
      .set('Authorization', `Bearer ${testUser.token}`)
      .send({ documentId: testDocument.id, question: 'test' })

    const allLogs = [
      ...logSpy.mock.calls.map(call => JSON.stringify(call)),
      ...errorSpy.mock.calls.map(call => JSON.stringify(call))
    ].join('\n')

    expect(allLogs).not.toMatch(/sk-[a-zA-Z0-9]{20,}/)
    expect(allLogs).not.toContain(process.env.OPENAI_API_KEY)
  })

  // 3.2-SEC-004
  it('should sanitize query content in logs', async () => {
    const logSpy = jest.spyOn(logger, 'info')
    const longQuery = 'a'.repeat(200) // 超过50字符

    await request(app)
      .post('/api/chat/query')
      .set('Authorization', `Bearer ${testUser.token}`)
      .send({ documentId: testDocument.id, question: longQuery })

    const logs = logSpy.mock.calls.map(call => JSON.stringify(call)).join('\n')
    
    // 日志应该只包含前50字符
    expect(logs).not.toContain(longQuery)
    expect(logs).toContain('a'.repeat(50))
  })
})
```

---

## Test Execution Order

### Phase 1: Foundation (Day 1-2)
**Goal**: 验证核心功能和单元逻辑

1. Unit Tests - Service Layer (3.2-UNIT-001 to 3.2-UNIT-032)
   - queryVectorizer tests
   - pgvector.repository tests
   - retrievalService tests
   - queryCacheService tests

**Exit Criteria**: 所有单元测试通过，代码覆盖率 > 80%

---

### Phase 2: Integration (Day 3-4)
**Goal**: 验证API端点和组件集成

2. Integration Tests - API Layer (3.2-INT-001 to 3.2-INT-015)
   - 完整API流程测试
   - 缓存功能测试
   - 权限和安全测试
   - 错误处理测试

**Exit Criteria**: 所有集成测试通过，P95延迟 < 500ms

---

### Phase 3: Quality & Performance (Day 5)
**Goal**: 验证检索质量和性能目标

3. Manual Quality Assessment (3.2-MANUAL-001)
   - 20个测试问题人工评估
   - Top-5准确率 >= 85%

4. Performance Benchmarks (3.2-PERF-001 to 3.2-PERF-010)
   - 延迟分布测试
   - 并发性能测试
   - 负载测试

**Exit Criteria**: 
- Top-5准确率 >= 85%
- P95延迟 < 500ms
- 缓存命中率 > 30%

---

### Phase 4: Resilience (Day 6)
**Goal**: 验证故障容错和安全性

5. Fault Tolerance Tests (3.2-FAULT-001 to 3.2-FAULT-008)
   - LLM API故障测试
   - Redis故障测试
   - 数据库故障测试

6. Security Tests (3.2-SEC-001 to 3.2-SEC-005)
   - API密钥保护测试
   - 隐私合规测试

**Exit Criteria**: 所有故障场景正确降级，无安全漏洞

---

### Phase 5: E2E & Smoke (Day 7)
**Goal**: 端到端验证和生产就绪

7. E2E Tests (3.2-E2E-001 to 3.2-E2E-004)
   - 完整用户流程
   - UI集成验证

8. Smoke Tests (Pre-deployment)
   - 关键路径快速验证
   - 生产环境配置验证

**Exit Criteria**: 所有E2E测试通过，准备上线

---

## Test Data Management

### Test Fixtures

```typescript
// tests/fixtures/test-documents.ts

export const testDocuments = {
  react_guide: {
    filename: 'react-official-guide.pdf',
    chunks: 50,
    topics: ['hooks', 'components', 'state', 'effects'],
    sampleQuestions: [
      '什么是React Hooks?',
      '如何使用useState?',
      'useEffect的依赖数组是什么?'
    ]
  },
  
  product_spec: {
    filename: 'product-requirements.docx',
    chunks: 30,
    topics: ['features', 'users', 'pricing'],
    sampleQuestions: [
      '产品的核心功能是什么?',
      '目标用户群体有哪些?'
    ]
  },
  
  research_paper: {
    filename: 'machine-learning-paper.pdf',
    chunks: 20,
    topics: ['methodology', 'results', 'conclusions'],
    sampleQuestions: [
      '研究的主要假设是什么?',
      '实验结果如何?'
    ]
  }
}

export async function createTestDocument(
  userId: string,
  config: {
    type: keyof typeof testDocuments
    status?: DocumentStatus
  }
): Promise<Document> {
  const docConfig = testDocuments[config.type]
  
  // 创建文档记录
  const document = await db.insert(documents).values({
    userId,
    filename: docConfig.filename,
    fileSize: 1024 * 100,
    fileType: 'application/pdf',
    storagePath: `/test/${docConfig.filename}`,
    status: config.status || 'READY',
    chunksCount: docConfig.chunks
  }).returning()

  // 创建测试chunks
  const chunks = await Promise.all(
    Array.from({ length: docConfig.chunks }, (_, i) => ({
      documentId: document[0].id,
      chunkIndex: i,
      content: `Test chunk ${i} about ${docConfig.topics.join(', ')}`,
      embeddingId: `emb-${i}`,
      metadata: { pageNumber: Math.floor(i / 5) + 1 }
    }))
  )

  await db.insert(documentChunks).values(chunks)

  return document[0]
}
```

---

## Quality Indicators

### Good Test Coverage Shows:

✅ **Functionality**
- All AC requirements have corresponding tests
- Happy path and error paths covered
- Edge cases identified and tested

✅ **Performance**
- Latency targets validated (P50, P95, P99)
- Concurrency limits tested
- Load testing at multiple scales

✅ **Resilience**
- External dependency failures handled
- Graceful degradation verified
- Circuit breakers tested

✅ **Security**
- API keys protected
- Cross-user isolation verified
- Privacy compliance validated

✅ **Quality**
- Human quality assessment >= 85%
- Cache hit rate >= 30%
- Error rate < 5%

---

## Red Flags to Watch For

❌ **Quality Issues**
- Top-5准确率 < 80%
- 大量"未找到相关内容"
- 检索结果明显不相关

❌ **Performance Issues**
- P95延迟 > 1秒
- 并发性能线性下降
- 缓存命中率 < 20%

❌ **Reliability Issues**
- 错误率 > 10%
- 频繁API超时
- 降级逻辑未生效

❌ **Security Issues**
- API密钥出现在任何输出
- 用户可访问他人文档
- 日志包含完整查询内容

---

## Integration with Quality Gates

### Test Results Feed Into Gate Decision:

**PASS Contribution**:
- All P0 tests pass
- Top-5 accuracy >= 85%
- P95 latency < 500ms
- No security vulnerabilities

**CONCERNS Triggers**:
- P1 test failures (1-3个)
- Top-5 accuracy 80-85%
- P95 latency 500-800ms
- Cache hit rate 20-30%

**FAIL Triggers**:
- Any P0 test failure
- Top-5 accuracy < 80%
- P95 latency > 1秒
- Security vulnerability found
- API key leaked

---

## Key Test Principles

1. **Quality First**: 检索准确率是最重要的指标
2. **Fast Feedback**: 单元测试快速验证逻辑
3. **Realistic Data**: 使用真实文档测试
4. **Measure Everything**: 延迟、准确率、缓存命中率
5. **Fail Fast**: P0测试失败立即停止
6. **Security Paranoid**: 多重检查API密钥保护

---

**Test Design Completed**: 2025-01-08  
**Total Scenarios**: 67 (32 Unit + 25 Integration + 10 E2E/Manual)  
**Estimated Execution Time**: ~8 hours (automated) + 4 hours (manual)  
**Designer**: Quinn (测试架构师)
