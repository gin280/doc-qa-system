# 测试设计: Story 4.8 - 批处理并行优化

**日期**: 2025-01-15  
**设计者**: Quinn (测试架构师)  
**Story**: 4.8 - 批处理并行优化  
**Epic**: 4 - 系统质量改进

---

## 测试策略概览

- **总测试场景数**: 18
- **单元测试**: 11 场景 (61%)
- **集成测试**: 5 场景 (28%)
- **性能测试**: 2 场景 (11%)
- **优先级分布**:
  - P0: 8 场景 (核心功能和安全)
  - P1: 7 场景 (重要功能)
  - P2: 3 场景 (边界情况)

---

## 测试场景（按验收标准分组）

### AC1: 实现并行批处理逻辑 ✅

#### 场景 1: 并发限制验证

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 4.8-UNIT-001 | Unit | P0 | 验证最多3个批次并发执行 | 核心并发控制逻辑，防止API过载 |

**测试步骤**:
```typescript
// Mock 10个批次，每个批次耗时100ms
// 预期: 任意时刻最多3个批次同时执行
// 验证: 通过记录执行时间戳，计算并发数
```

**预期结果**:
- 并发数永远不超过3
- 总耗时约 400ms (10批次 / 3并发 ≈ 4轮 × 100ms)

#### 场景 2: 批次顺序无关性验证

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 4.8-UNIT-002 | Unit | P1 | 验证批次可以按任意顺序完成 | 确保并行处理的正确性 |

**测试步骤**:
```typescript
// Mock 5个批次，设置不同的完成时间
// 批次2最快(50ms)，批次1最慢(200ms)
// 验证: 所有批次都正确完成，不依赖顺序
```

#### 场景 3: 小规模文档处理（3批次）

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 4.8-INT-001 | Integration | P1 | 处理50个chunks (3批次) | 验证基本并行流程 |

**测试步骤**:
```typescript
// 1. 准备50个chunks
// 2. 调用 embedAndStoreChunks
// 3. 验证: 所有chunks被处理，向量正确存储
```

#### 场景 4: 中规模文档处理（10批次）

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 4.8-INT-002 | Integration | P0 | 处理200个chunks (10批次) | 验证多轮并发调度 |

**测试步骤**:
```typescript
// 1. 准备200个chunks
// 2. 调用 embedAndStoreChunks
// 3. 验证: 并发控制正常，所有批次完成
```

#### 场景 5: 大规模文档处理（50批次）

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 4.8-INT-003 | Integration | P1 | 处理1000个chunks (50批次) | 验证大规模场景稳定性 |

**测试步骤**:
```typescript
// 1. 准备1000个chunks
// 2. 调用 embedAndStoreChunks
// 3. 验证: 长时间运行稳定，无内存泄漏
```

#### 场景 6: 单批次处理（边界）

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 4.8-UNIT-003 | Unit | P2 | 处理1个批次 (20个chunks) | 边界条件：并行退化为单次 |

**测试步骤**:
```typescript
// 1. 准备20个chunks (1批次)
// 2. 验证: 并行逻辑正确处理单批次情况
```

---

### AC2: 保持错误处理健壮性 ✅

#### 场景 7: 单个批次失败不影响其他批次

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 4.8-UNIT-004 | Unit | P0 | 批次2失败，其他批次继续 | 核心错误隔离逻辑 |

**测试步骤**:
```typescript
// Mock 5个批次
// 批次2 Mock抛出 EMBEDDING_ERROR
// 验证: 
// - 批次1, 3, 4, 5 继续执行
// - failedBatches = [1] (0-indexed)
```

#### 场景 8: 多个批次失败处理

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 4.8-UNIT-005 | Unit | P0 | 3个批次失败，收集所有失败信息 | 错误收集和报告 |

**测试步骤**:
```typescript
// Mock 10个批次，批次2, 5, 8失败
// 验证: 
// - successCount = 7
// - failedBatches = [1, 4, 7]
// - 抛出错误包含所有失败批次号
```

#### 场景 9: 所有批次失败

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 4.8-UNIT-006 | Unit | P1 | 全部批次失败，正确报告 | 极端失败情况 |

**测试步骤**:
```typescript
// Mock 5个批次全部失败
// 验证: 
// - successCount = 0
// - failedBatches = [0,1,2,3,4]
// - 抛出 EmbeddingError 包含完整信息
```

#### 场景 10: 不同类型错误混合

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 4.8-UNIT-007 | Unit | P1 | 混合 TIMEOUT、QUOTA_EXCEEDED、DIMENSION_MISMATCH | 多种错误类型共存 |

**测试步骤**:
```typescript
// Mock 6个批次:
// - 批次1: EMBEDDING_TIMEOUT
// - 批次3: QUOTA_EXCEEDED
// - 批次5: DIMENSION_MISMATCH
// 验证: 所有错误类型都被正确记录
```

#### 场景 11: 维度验证在并行中正确执行

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 4.8-INT-004 | Integration | P0 | 并行批次中检测维度不匹配 | 确保维度验证不被并行影响 |

**测试步骤**:
```typescript
// Mock 批次2返回错误维度 (512维而非1024)
// 验证: 
// - 批次2失败并抛出 DIMENSION_MISMATCH
// - 其他批次继续处理
```

---

### AC3: 保持日志可观测性 ✅

#### 场景 12: 并行处理日志完整性

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 4.8-UNIT-008 | Unit | P1 | 验证所有关键日志点存在 | 生产环境可观测性 |

**测试步骤**:
```typescript
// 捕获 console.log 输出
// 验证日志包含:
// - "开始并行处理, 总批次=10, 并发数=3"
// - "批次 X 开始" (对每个批次)
// - "批次 X 完成 (Xs)" (对每个批次)
// - "所有批次完成, 总耗时=Xs, 成功=Y, 失败=Z"
```

#### 场景 13: 批次时间记录准确性

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 4.8-UNIT-009 | Unit | P2 | 验证每个批次耗时记录正确 | 性能监控基础 |

**测试步骤**:
```typescript
// Mock 批次1耗时 100ms, 批次2耗时 200ms
// 验证日志:
// - "批次 1 完成 (0.1s)"
// - "批次 2 完成 (0.2s)"
```

---

### AC4: 性能测试验证提升效果 ✅

#### 场景 14: 小文档性能提升验证 (3批次)

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 4.8-PERF-001 | Performance | P0 | 50 chunks: 性能提升 ≥35% | 验证小规模性能目标 |

**测试步骤**:
```typescript
// 1. 准备50个chunks (3批次)
// 2. 顺序处理测量时间 T1
// 3. 并行处理测量时间 T2
// 4. 计算提升率: (T1-T2)/T1
// 验证: 提升率 ≥ 0.35 (35%)
```

**预期结果**:
- 顺序处理: ~15秒
- 并行处理: ~9秒
- 提升率: 40%

#### 场景 15: 中大文档性能提升验证 (10-50批次)

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 4.8-PERF-002 | Performance | P0 | 200/1000 chunks: 性能提升 ≥35% | 验证中大规模性能目标 |

**测试步骤**:
```typescript
// 测试两种规模:
// 1. 200 chunks (10批次)
// 2. 1000 chunks (50批次)
// 每种规模验证性能提升 ≥35%
```

**预期结果**:
- 200 chunks: 60秒 → 36秒 (40%提升)
- 1000 chunks: 300秒 → 180秒 (40%提升)

---

### AC5: 单元测试覆盖并行逻辑 ✅

#### 场景 16: Mock API延迟验证并行效果

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 4.8-UNIT-010 | Unit | P1 | Mock不同延迟，验证并行优势 | 证明并行有效性 |

**测试步骤**:
```typescript
// Mock LLM API每批次100ms延迟
// 6个批次:
// - 顺序: 6 × 100ms = 600ms
// - 并行(3并发): 2轮 × 100ms = 200ms
// 验证: 并行耗时约 200ms
```

#### 场景 17: 并发控制逻辑正确性

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 4.8-UNIT-011 | Unit | P0 | 通过时间戳验证并发数 | 核心并发控制 |

**测试步骤**:
```typescript
// 记录每个批次的开始和结束时间戳
// 计算任意时刻的并发数
// 验证: max(并发数) ≤ 3
```

#### 场景 18: 功能开关验证

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 4.8-INT-005 | Integration | P2 | ENABLE_PARALLEL_EMBEDDING=false 回退顺序处理 | 回滚能力 |

**测试步骤**:
```typescript
// 1. 设置环境变量 ENABLE_PARALLEL_EMBEDDING=false
// 2. 调用 embedAndStoreChunks
// 3. 验证: 使用顺序处理逻辑
```

---

## 覆盖率分析

### 按验收标准映射

| AC | 测试场景数 | P0场景 | 覆盖状态 |
|----|-----------|--------|---------|
| AC1: 并行批处理逻辑 | 6 | 2 | ✅ 完全覆盖 |
| AC2: 错误处理健壮性 | 5 | 3 | ✅ 完全覆盖 |
| AC3: 日志可观测性 | 2 | 0 | ✅ 完全覆盖 |
| AC4: 性能验证 | 2 | 2 | ✅ 完全覆盖 |
| AC5: 单元测试覆盖 | 3 | 1 | ✅ 完全覆盖 |

### 测试层级分布

**单元测试 (11场景 - 61%)**:
- 并发控制逻辑
- 错误处理逻辑
- 日志记录
- Mock API延迟测试

**集成测试 (5场景 - 28%)**:
- 不同规模文档处理
- 与真实LLM API集成
- 维度验证集成
- 功能开关

**性能测试 (2场景 - 11%)**:
- 小/中/大文档性能基准测试
- 性能提升验证

### 风险覆盖

| 风险 | 相关测试场景 | 覆盖状态 |
|------|-------------|---------|
| API速率限制触发 | 4.8-UNIT-001, 4.8-INT-002 | ✅ |
| 单批次失败影响全局 | 4.8-UNIT-004, 4.8-UNIT-005 | ✅ |
| 性能提升未达标 | 4.8-PERF-001, 4.8-PERF-002 | ✅ |
| 维度验证失效 | 4.8-INT-004 | ✅ |
| 并发导致数据不一致 | 4.8-UNIT-002, 4.8-INT-003 | ✅ |

---

## 推荐测试执行顺序

### 阶段1: P0单元测试 (快速失败)

1. 4.8-UNIT-001: 并发限制验证
2. 4.8-UNIT-004: 单个批次失败隔离
3. 4.8-UNIT-005: 多个批次失败处理
4. 4.8-UNIT-011: 并发控制逻辑正确性

### 阶段2: P0集成测试

5. 4.8-INT-002: 中规模文档处理 (200 chunks)
6. 4.8-INT-004: 维度验证在并行中执行

### 阶段3: P0性能测试

7. 4.8-PERF-001: 小文档性能验证
8. 4.8-PERF-002: 中大文档性能验证

### 阶段4: P1测试

9. 其余P1单元测试和集成测试

### 阶段5: P2测试（可选）

10. 边界条件和Nice-to-have场景

---

## 测试数据需求

### Mock数据

**Chunks生成器**:
```typescript
function generateMockChunks(count: number): ChunkResult[] {
  return Array.from({ length: count }, (_, i) => ({
    id: crypto.randomUUID(),
    text: `Mock chunk ${i + 1} with some content`,
    startPage: 1,
    endPage: 1,
  }))
}
```

**LLM API Mock配置**:
```typescript
// 控制延迟的Mock
const mockLLM = {
  generateEmbeddings: jest.fn().mockImplementation(async (texts) => {
    await delay(100) // 模拟API耗时
    return texts.map(() => Array(1024).fill(0.1))
  })
}

// 模拟失败的Mock
const mockLLMWithError = {
  generateEmbeddings: jest.fn()
    .mockResolvedValueOnce(validEmbeddings)  // 批次1成功
    .mockRejectedValueOnce(new Error('API Error'))  // 批次2失败
    .mockResolvedValueOnce(validEmbeddings)  // 批次3成功
}
```

### 测试环境配置

```bash
# 性能测试环境变量
ENABLE_PARALLEL_EMBEDDING=true
EMBEDDING_CONCURRENCY=3
BATCH_SIZE=20

# 使用Mock还是真实API
USE_REAL_LLM_API=false  # 单元/集成测试用Mock
USE_REAL_LLM_API=true   # 性能测试可选真实API
```

---

## 测试工具和框架

### 单元测试
- **框架**: Jest
- **Mock**: jest.fn(), jest.spyOn()
- **断言**: expect()

### 集成测试
- **数据库**: PostgreSQL (测试数据库)
- **LLM API**: Mock或真实API
- **清理**: beforeEach/afterEach hooks

### 性能测试
- **计时**: performance.now()
- **基准**: 顺序处理作为baseline
- **报告**: 生成markdown报告

---

## 覆盖率目标

### 代码覆盖率
- **目标**: ≥90% (项目标准)
- **关键文件**: `src/services/documents/embeddingService.ts`
- **重点**: 
  - `processBatchesInParallel` 函数: 100%
  - `embedAndStoreChunks` 并行分支: 100%

### 功能覆盖率
- ✅ 所有5个AC: 100%覆盖
- ✅ 所有识别的风险: 100%覆盖

---

## 成功标准

### 测试通过标准
- ✅ 所有P0测试通过
- ✅ 所有P1测试通过
- ✅ 代码覆盖率 ≥90%
- ✅ 性能提升 ≥35%验证通过

### 质量门禁
- ✅ 无高优先级缺陷
- ✅ 性能回归 <5%
- ✅ 所有现有集成测试通过（无回归）

---

## 测试文件组织

```
tests/
├── unit/
│   └── services/
│       └── documents/
│           └── embeddingService.parallel.test.ts  # 场景1-13, 16-17
│
├── integration/
│   └── embedding-parallel-integration.test.ts     # 场景3-5, 11, 18
│
└── performance/
    └── embedding-parallel.test.ts                 # 场景14-15
```

---

## 附录: 测试脚本示例

### 并发限制验证示例

```typescript
describe('processBatchesInParallel - Concurrency Control', () => {
  it('应该限制并发数为3', async () => {
    const batches = Array.from({ length: 10 }, (_, i) => [i])
    const executing: number[] = []
    let maxConcurrency = 0
    
    const processor = async (batch: number[], index: number) => {
      executing.push(index)
      maxConcurrency = Math.max(maxConcurrency, executing.length)
      
      await delay(100) // 模拟API耗时
      
      const idx = executing.indexOf(index)
      executing.splice(idx, 1)
    }
    
    await processBatchesInParallel(batches, processor, 3)
    
    expect(maxConcurrency).toBeLessThanOrEqual(3)
  })
})
```

### 性能提升验证示例

```typescript
describe('Performance Improvement', () => {
  it('应该在50 chunks时提升≥35%性能', async () => {
    const chunks = generateMockChunks(50) // 3批次
    
    // 测试顺序处理
    const sequentialStart = performance.now()
    await embedAndStoreChunksSequential(chunks)
    const sequentialTime = performance.now() - sequentialStart
    
    // 测试并行处理
    const parallelStart = performance.now()
    await embedAndStoreChunks(chunks)
    const parallelTime = performance.now() - parallelStart
    
    const improvement = (sequentialTime - parallelTime) / sequentialTime
    
    expect(improvement).toBeGreaterThanOrEqual(0.35) // 35%
    
    console.log(`
      Sequential: ${sequentialTime.toFixed(0)}ms
      Parallel: ${parallelTime.toFixed(0)}ms
      Improvement: ${(improvement * 100).toFixed(1)}%
    `)
  })
})
```

---

**测试设计完成** ✅  
**下一步**: Dev实施测试 → QA执行验证

