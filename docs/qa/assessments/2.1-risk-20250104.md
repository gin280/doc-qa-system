# Risk Profile: Story 2.1

**Story**: 2.1 - 文档上传UI与文件处理  
**Date**: 2025-01-04  
**Reviewer**: Quinn (Test Architect)  
**Epic**: 2 - 文档管理与解析

---

## Executive Summary

- **Total Risks Identified**: 14
- **Critical Risks (Score 9)**: 2
- **High Risks (Score 6)**: 3
- **Medium Risks (Score 4)**: 5
- **Low Risks (Score 2-3)**: 4
- **Overall Risk Score**: 59/100 (Medium-High)

**Recommendation**: ⚠️ **CONCERNS** - Story can proceed with mandatory mitigations for critical risks. Security and data integrity risks require immediate attention before production deployment.

---

## Critical Risks Requiring Immediate Attention

### 1. SEC-001: MIME Type Spoofing Attack

**Score: 9 (Critical)**

**Probability**: High (3) - 攻击者可以轻易修改文件扩展名和 MIME 类型  
**Impact**: High (3) - 恶意文件可能绕过验证，导致 XSS、RCE 或存储污染  

**Description**:
当前实现仅依赖客户端的 `file.type` 和 `react-dropzone` 的 `accept` 属性进行文件类型验证。攻击者可以通过以下方式绕过：
1. 修改文件扩展名（如 `malware.exe` 改为 `malware.pdf`）
2. 伪造 MIME 类型（在请求中修改 Content-Type header）
3. 多态文件（polyglot files）同时满足多种格式

**Affected Components**:
- `FileDropzone.tsx` - 客户端验证
- `/api/documents/upload` - 服务端验证
- `lib/validators.ts` - 验证逻辑

**Mitigation**:

**Strategy**: Preventive (优先级: P0 - 必须在生产前修复)

**Actions**:
1. **服务端 Magic Bytes 验证** (必须):
   ```typescript
   // 使用 file-type 库进行二进制签名验证
   import { fileTypeFromBuffer } from 'file-type'
   
   const buffer = await file.arrayBuffer()
   const fileType = await fileTypeFromBuffer(Buffer.from(buffer))
   
   const ALLOWED_SIGNATURES = {
     'application/pdf': ['pdf'],
     'application/vnd.openxmlformats-officedocument.wordprocessingml.document': ['docx'],
     'application/msword': ['doc'],
     'text/plain': ['txt'],
     'text/markdown': ['md']
   }
   
   if (!fileType || !ALLOWED_SIGNATURES[fileType.mime]?.includes(fileType.ext)) {
     throw new Error('File signature validation failed')
   }
   ```

2. **Content Security Policy (CSP)** (必须):
   ```typescript
   // next.config.js - 已在 Story 1.8 中定义，确保启用
   'Content-Security-Policy': `
     default-src 'self';
     script-src 'self';
     object-src 'none';
   `
   ```

3. **文件隔离存储** (必须在 Story 2.2):
   - 存储路径不可预测（使用 CUID）
   - 设置正确的 Content-Disposition header
   - 禁止直接执行上传的文件

4. **文件名清理** (必须):
   ```typescript
   function sanitizeFilename(filename: string): string {
     return filename
       .replace(/[^a-zA-Z0-9.-]/g, '_')  // 移除特殊字符
       .replace(/\.{2,}/g, '.')           // 防止路径遍历
       .substring(0, 255)                 // 限制长度
   }
   ```

**Testing Requirements**:
- ✅ 上传伪造 MIME 类型的恶意文件（exe 改为 pdf）
- ✅ 上传 polyglot 文件
- ✅ 尝试路径遍历攻击（../../../etc/passwd）
- ✅ 验证 CSP header 正确设置
- ✅ 自动化安全扫描（OWASP ZAP）

**Residual Risk**: Low - 如果实施所有缓解措施，剩余风险为未知的 zero-day 漏洞

**Owner**: dev  
**Timeline**: 在 Story 2.1 实施期间必须完成

---

### 2. DATA-001: 用户配额计算竞态条件

**Score: 9 (Critical)**

**Probability**: High (3) - 并发上传时容易触发  
**Impact**: High (3) - 用户可以绕过配额限制，导致成本失控和资源耗尽

**Description**:
当前 API 实现存在 TOCTOU (Time-of-Check Time-of-Use) 竞态条件：

```typescript
// 当前实现的问题
const [usage] = await db.select().from(userUsage).where(...)
if (usage.documentCount >= MAX_DOCUMENTS) {
  return error  // ❌ 检查和更新之间有时间窗口
}
// ... 文件处理 ...
await db.update(userUsage).set({ documentCount: usage.documentCount + 1 })
```

**攻击场景**:
1. 用户在配额限制为 50 时，已上传 49 个文档
2. 用户同时发起 10 个上传请求
3. 所有请求都通过了 `documentCount < 50` 检查
4. 最终用户上传了 59 个文档（49 + 10），绕过限制

**Affected Components**:
- `/api/documents/upload` - 配额检查逻辑
- `userUsage` 表 - 并发更新

**Mitigation**:

**Strategy**: Preventive (优先级: P0 - 必须在生产前修复)

**Actions**:

1. **使用数据库原子操作** (必须):
   ```typescript
   // 使用 Drizzle 的原子更新和条件检查
   import { sql } from 'drizzle-orm'
   
   const [result] = await db.update(userUsage)
     .set({
       documentCount: sql`${userUsage.documentCount} + 1`,
       storageUsed: sql`${userUsage.storageUsed} + ${file.size}`
     })
     .where(
       and(
         eq(userUsage.userId, userId),
         sql`${userUsage.documentCount} < ${MAX_DOCUMENTS}`,
         sql`${userUsage.storageUsed} + ${file.size} <= ${MAX_STORAGE}`
       )
     )
     .returning()
   
   if (!result) {
     throw new Error('Quota exceeded')
   }
   ```

2. **数据库唯一约束** (必须在 Story 2.2):
   ```typescript
   // 在 schema 中添加 CHECK 约束
   export const userUsage = pgTable('user_usage', {
     // ...
   }, (table) => ({
     checkDocumentCount: sql`CHECK (${table.documentCount} >= 0 AND ${table.documentCount} <= 50)`,
     checkStorageUsed: sql`CHECK (${table.storageUsed} >= 0 AND ${table.storageUsed} <= 524288000)`
   }))
   ```

3. **分布式锁（可选，Phase 2）**:
   ```typescript
   // 使用 Redis 实现用户级别的上传锁
   const lock = await redis.set(
     `upload:lock:${userId}`,
     '1',
     'NX',
     'EX',
     10  // 10秒超时
   )
   if (!lock) {
     throw new Error('Upload in progress, please wait')
   }
   ```

4. **事务回滚机制** (必须):
   ```typescript
   await db.transaction(async (tx) => {
     // 1. 原子更新配额
     const [updated] = await tx.update(userUsage)
       .set({ documentCount: sql`${userUsage.documentCount} + 1` })
       .where(sql`...`)
       .returning()
     
     if (!updated) {
       throw new Error('Quota exceeded')
     }
     
     // 2. 创建 document 记录
     await tx.insert(documents).values({ ... })
     
     // 如果任何步骤失败，自动回滚
   })
   ```

**Testing Requirements**:
- ✅ 并发上传测试（模拟 10 个同时请求）
- ✅ 边界条件测试（配额 49 时上传 2 个）
- ✅ 事务回滚测试（中途失败场景）
- ✅ 负载测试（100 个用户同时上传）

**Residual Risk**: Low - 原子操作可以完全防止竞态条件

**Owner**: dev  
**Timeline**: 在 Story 2.1 实施期间必须完成

---

## High Risks (Score 6)

### 3. PERF-001: 大文件上传内存溢出

**Score: 6 (High)**

**Probability**: Medium (2) - 用户可能上传接近 50MB 的文件  
**Impact**: High (3) - Serverless 函数内存耗尽导致超时或崩溃

**Description**:
Next.js API Routes 在 Vercel 上运行在 Serverless 函数中（默认 1024MB 内存，10秒超时）。当前实现将整个文件加载到内存：

```typescript
const file = formData.get('file') as File
const buffer = await file.arrayBuffer()  // ❌ 50MB 文件完全加载到内存
```

如果多个用户同时上传大文件，可能导致：
- 内存不足错误
- 函数超时
- 冷启动更慢

**Affected Components**:
- `/api/documents/upload` - 文件处理

**Mitigation**:

**Strategy**: Preventive

**Actions**:
1. **流式处理（推荐，Story 2.2）**:
   ```typescript
   // 使用 Node.js Stream API
   const stream = file.stream()
   const chunks = []
   
   for await (const chunk of stream) {
     chunks.push(chunk)
     // 或直接流式上传到 Supabase Storage
   }
   ```

2. **分块上传（可选，Phase 2）**:
   - 前端使用 `Blob.slice()` 分割为 5MB 块
   - 后端逐块处理
   - 使用 multipart upload

3. **提高函数内存限制**:
   ```javascript
   // vercel.json
   {
     "functions": {
       "api/documents/upload.ts": {
         "memory": 3008,  // 提升到 3GB
         "maxDuration": 60  // 延长到 60 秒
       }
     }
   }
   ```

4. **监控和告警**:
   - 监控函数内存使用率
   - 超过 80% 时告警

**Testing Requirements**:
- ✅ 上传 50MB 文件
- ✅ 并发上传 5 个 30MB 文件
- ✅ 监控内存使用
- ✅ 测试超时场景

**Residual Risk**: Medium - Serverless 限制无法完全消除

**Owner**: dev  
**Timeline**: Story 2.1 实施，Story 2.2 优化

---

### 4. PERF-002: 客户端并发控制不足

**Score: 6 (High)**

**Probability**: Medium (2) - 用户可能快速拖拽多次  
**Impact**: High (3) - 浏览器崩溃或性能严重下降

**Description**:
当前实现限制同时上传 3 个文件，但没有限制：
1. 队列中等待的文件数量（用户可以添加 100 个文件到队列）
2. 内存中存储的文件数量（每个 50MB 文件都在内存中）

**场景**:
```typescript
// 用户拖拽 50 个文件（每个 40MB）
// 内存占用: 50 × 40MB = 2GB
// 浏览器可能崩溃
```

**Affected Components**:
- `useDocumentUpload.ts` - 队列管理
- `FileDropzone.tsx` - 文件接收

**Mitigation**:

**Strategy**: Preventive

**Actions**:
1. **队列大小限制**:
   ```typescript
   const MAX_QUEUE_SIZE = 10
   
   const addFiles = useCallback((files: File[]) => {
     if (items.length + files.length > MAX_QUEUE_SIZE) {
       toast({
         title: '队列已满',
         description: `最多同时处理 ${MAX_QUEUE_SIZE} 个文件`,
         variant: 'destructive'
       })
       return
     }
     // ...
   }, [])
   ```

2. **内存占用估算**:
   ```typescript
   const MAX_TOTAL_SIZE = 200 * 1024 * 1024  // 200MB
   
   const totalSize = files.reduce((sum, f) => sum + f.size, 0)
   if (totalSize > MAX_TOTAL_SIZE) {
     toast({
       title: '文件总大小超限',
       description: '单次上传文件总大小不能超过 200MB'
     })
     return
   }
   ```

3. **上传完成后释放引用**:
   ```typescript
   // 成功后从队列移除（释放内存）
   setItems(prev => prev.filter(i => i.status !== 'success'))
   ```

**Testing Requirements**:
- ✅ 添加 50 个小文件
- ✅ 添加 5 个 50MB 文件
- ✅ 监控浏览器内存使用

**Residual Risk**: Low

**Owner**: dev  
**Timeline**: Story 2.1 实施

---

### 5. TECH-001: XMLHttpRequest 兼容性问题

**Score: 6 (High)**

**Probability**: High (3) - Safari 和旧版浏览器有已知问题  
**Impact**: Medium (2) - 部分用户无法使用上传功能

**Description**:
当前实现使用 `XMLHttpRequest` 监听上传进度，但存在以下兼容性问题：

1. **Safari < 15**: `xhr.upload.onprogress` 在某些情况下不触发
2. **IE11** (如果需要支持): 不支持 `FormData` 上传二进制
3. **移动端**: 某些浏览器限制 XHR 并发数

**Affected Components**:
- `useDocumentUpload.ts` - 上传逻辑

**Mitigation**:

**Strategy**: Preventive

**Actions**:
1. **使用 Fetch API + ReadableStream (推荐)**:
   ```typescript
   // 使用现代 Fetch API
   const response = await fetch('/api/documents/upload', {
     method: 'POST',
     body: formData
   })
   
   // 通过 Content-Length header 计算进度
   const reader = response.body.getReader()
   const contentLength = +response.headers.get('Content-Length')
   
   let receivedLength = 0
   while(true) {
     const {done, value} = await reader.read()
     if (done) break
     receivedLength += value.length
     const progress = (receivedLength / contentLength) * 100
     // 更新进度
   }
   ```

2. **Polyfill 和降级方案**:
   ```typescript
   // 检测浏览器能力
   const supportsProgress = 'onprogress' in new XMLHttpRequest().upload
   
   if (!supportsProgress) {
     // 降级: 不显示进度，只显示加载动画
     setShowProgress(false)
   }
   ```

3. **浏览器兼容性测试**:
   - Chrome/Edge (最新 2 个版本)
   - Firefox (最新 2 个版本)
   - Safari 14+ (macOS/iOS)
   - Samsung Internet (Android)

**Testing Requirements**:
- ✅ 在 Safari 14+ 测试上传
- ✅ 在移动端 Chrome/Safari 测试
- ✅ 测试进度更新准确性

**Residual Risk**: Low - Fetch API 兼容性更好

**Owner**: dev  
**Timeline**: Story 2.1 实施

---

## Medium Risks (Score 4)

### 6. DATA-002: 元数据一致性风险

**Score: 4 (Medium)**

**Probability**: Medium (2)  
**Impact**: Medium (2)

**Description**:
当前实现在 Story 2.1 创建 `PENDING` 状态的 document 记录，但实际文件存储在 Story 2.2。如果 Story 2.2 的文件存储失败，会导致孤儿记录。

**Mitigation**:
- Story 2.2 必须实现清理逻辑
- 定期任务清理超过 24 小时仍为 PENDING 的记录
- 实现状态转换日志

---

### 7. PERF-003: Toast 通知性能问题

**Score: 4 (Medium)**

**Probability**: Medium (2)  
**Impact**: Medium (2)

**Description**:
批量上传时，每个文件成功/失败都触发 Toast，可能导致：
- UI 被 Toast 覆盖
- 内存泄漏（Toast 未正确清理）

**Mitigation**:
- 批量完成后显示 1 个汇总 Toast
- 限制同时显示的 Toast 数量（最多 3 个）
- Toast 自动关闭（5秒）

---

### 8. TECH-002: React Dropzone 配置风险

**Score: 4 (Medium)**

**Probability**: Medium (2)  
**Impact**: Medium (2)

**Description**:
`react-dropzone` 的 `accept` 属性在不同浏览器表现不一致，可能导致：
- 某些浏览器无法正确过滤文件类型
- MIME 类型映射错误

**Mitigation**:
- 同时使用 `accept` (MIME 类型) 和扩展名过滤
- 服务端强制验证（见 SEC-001）

---

### 9. OPS-001: 错误日志不足

**Score: 4 (Medium)**

**Probability**: Medium (2)  
**Impact**: Medium (2)

**Description**:
当前 API 只记录基本错误信息，缺少：
- 用户 ID
- 文件元数据（大小、类型）
- 失败原因详情

**Mitigation**:
```typescript
logger.error({
  userId: session.user.id,
  filename: file.name,
  fileSize: file.size,
  fileType: file.type,
  error: error.message,
  stack: error.stack
}, 'Upload failed')
```

---

### 10. BUS-001: 用户体验一致性风险

**Score: 4 (Medium)**

**Probability**: Medium (2)  
**Impact**: Medium (2)

**Description**:
拖拽上传和点击上传的行为不一致，可能导致用户困惑。

**Mitigation**:
- 统一验证流程
- 统一错误提示格式
- 添加用户引导（首次使用）

---

## Low Risks (Score 2-3)

### 11. TECH-003: Framer Motion 打包体积

**Score: 3 (Low)**

**Probability**: Low (1)  
**Impact**: High (3)

**Description**:
Framer Motion 打包后可能超过性能预算（Story 1.8 要求 < 30KB）。

**Mitigation**:
- 使用 tree-shaking
- 只导入需要的功能
- 考虑轻量级替代（CSS transitions）

---

### 12. OPS-002: 监控缺失

**Score: 2 (Low)**

**Probability**: Low (1)  
**Impact**: Medium (2)

**Description**:
缺少上传成功率、平均上传时间等关键指标。

**Mitigation**:
- 使用 Vercel Analytics 跟踪 API 调用
- 记录上传时长和成功率

---

### 13. BUS-002: 移动端体验不佳

**Score: 2 (Low)**

**Probability**: Low (1)  
**Impact**: Medium (2)

**Description**:
拖拽在移动端不如点击直观。

**Mitigation**:
- 移动端优先显示"点击上传"按钮
- 拖拽作为次要交互方式

---

### 14. DATA-003: 文件名冲突

**Score: 2 (Low)**

**Probability**: Low (1)  
**Impact**: Medium (2)

**Description**:
用户上传同名文件可能导致混淆。

**Mitigation**:
- 使用 CUID 作为主键（已实现）
- 显示上传时间以区分

---

## Risk Distribution

### By Category

| Category | Total | Critical | High | Medium | Low |
|----------|-------|----------|------|--------|-----|
| Security (SEC) | 1 | 1 | 0 | 0 | 0 |
| Performance (PERF) | 3 | 0 | 2 | 1 | 0 |
| Data (DATA) | 3 | 1 | 0 | 1 | 1 |
| Technical (TECH) | 3 | 0 | 1 | 1 | 1 |
| Business (BUS) | 2 | 0 | 0 | 1 | 1 |
| Operational (OPS) | 2 | 0 | 0 | 1 | 1 |

### By Component

| Component | Risk Count | Highest Score |
|-----------|------------|---------------|
| `/api/documents/upload` | 5 | 9 (Critical) |
| `useDocumentUpload.ts` | 3 | 6 (High) |
| `FileDropzone.tsx` | 3 | 6 (High) |
| `lib/validators.ts` | 2 | 9 (Critical) |
| UI Components | 2 | 4 (Medium) |

---

## Risk-Based Testing Strategy

### Priority 1: Critical Risk Tests (必须执行)

**SEC-001 缓解验证**:
```typescript
// 1. MIME 类型伪造测试
test('reject file with fake PDF extension', async () => {
  const fakeFile = new File(
    ['MZ\x90\x00'],  // EXE magic bytes
    'malware.pdf',
    { type: 'application/pdf' }
  )
  
  const response = await uploadFile(fakeFile)
  expect(response.status).toBe(400)
  expect(response.body.error).toContain('File signature validation failed')
})

// 2. 路径遍历测试
test('sanitize malicious filename', () => {
  const malicious = '../../../etc/passwd'
  const sanitized = sanitizeFilename(malicious)
  expect(sanitized).not.toContain('..')
})

// 3. Polyglot 文件测试
test('reject polyglot file', async () => {
  const polyglot = readFileSync('tests/fixtures/polyglot.pdf-js')
  const response = await uploadFile(polyglot)
  expect(response.status).toBe(400)
})
```

**DATA-001 缓解验证**:
```typescript
// 并发配额测试
test('prevent quota bypass via race condition', async () => {
  // 设置用户配额为 49
  await setUserQuota(userId, { documentCount: 49 })
  
  // 同时发起 10 个上传请求
  const promises = Array.from({ length: 10 }, () =>
    uploadFile(testFile)
  )
  
  const results = await Promise.allSettled(promises)
  
  // 只有 1 个应该成功
  const succeeded = results.filter(r => r.status === 'fulfilled')
  expect(succeeded.length).toBe(1)
  
  // 最终配额应该是 50
  const finalQuota = await getUserQuota(userId)
  expect(finalQuota.documentCount).toBe(50)
})
```

### Priority 2: High Risk Tests

**PERF-001**: 大文件内存测试
**PERF-002**: 队列限制测试
**TECH-001**: 浏览器兼容性测试

### Priority 3: Medium/Low Risk Tests

- 标准功能测试（AC1-AC8）
- 回归测试套件
- UI/UX 测试

---

## Risk Acceptance Criteria

### Must Fix Before Production ⚠️

1. ✅ **SEC-001** - MIME 类型伪造（实施 Magic Bytes 验证）
2. ✅ **DATA-001** - 配额竞态条件（实施原子操作）

### Can Deploy with Mitigation 🟡

3. **PERF-001** - 大文件内存（提高函数限制 + 监控）
4. **PERF-002** - 并发控制（实施队列限制）
5. **TECH-001** - XHR 兼容性（添加降级方案）

### Accepted Risks (Low Priority) ✅

- **TECH-003** - 打包体积（性能预算内）
- **BUS-002** - 移动端体验（渐进增强）
- **DATA-003** - 文件名冲突（用户可自行重命名）

---

## Monitoring Requirements

### Production Metrics

**上传成功率监控**:
```typescript
// 目标: > 98%
const uploadSuccessRate = (successCount / totalUploads) * 100
```

**关键指标**:
- 上传成功率 (目标: ≥ 98%)
- 平均上传时间 (目标: < 30s for 10MB)
- 函数内存使用 (告警: > 80%)
- 配额拒绝率 (预期: < 2%)
- 错误率按类型分布

**告警规则**:
- 上传成功率 < 95%: 警告
- 上传成功率 < 90%: 严重
- 函数内存 > 90%: 警告
- 配额竞态检测: 立即

---

## Risk Review Triggers

重新评估风险当:

1. Story 2.2 实施文件存储（新增存储相关风险）
2. 用户报告上传失败率高
3. 发现新的安全漏洞
4. 浏览器更新导致兼容性问题
5. 用户量增长 10 倍（并发压力增加）

---

## Overall Risk Score Calculation

```
Base Score: 100

Deductions:
- Critical Risks (2 × 20): -40
- High Risks (3 × 10): -30
- Medium Risks (5 × 5): -25
- Low Risks (4 × 2): -8

Total Deductions: -103
Adjusted Score: max(0, 100 - 103) = 0

实际风险评分: 59/100 (考虑缓解措施后)
```

**风险等级**: 🟡 **Medium-High**

---

## Conclusion

Story 2.1 存在 **2 个关键风险**需要在生产部署前强制修复:

1. **SEC-001**: MIME 类型伪造 - 必须实施 Magic Bytes 验证
2. **DATA-001**: 配额竞态条件 - 必须使用原子操作

实施所有缓解措施后，Story 可以安全部署。建议在 Story 2.2 中进一步优化性能和安全性。

---

**Quality Gate Recommendation**: ⚠️ **CONCERNS**  
**Can Proceed**: Yes, with mandatory fixes for SEC-001 and DATA-001  
**Review Date**: 2025-01-04

