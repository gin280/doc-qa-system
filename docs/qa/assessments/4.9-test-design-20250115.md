# 测试设计: Story 4.9 - Prompt 动态调整

**日期**: 2025-01-15  
**设计者**: Quinn (测试架构师)  
**Story**: 4.9 - Prompt 动态调整

---

## 测试策略概述

### 测试重点

这是一个**性能优化**故事，核心是根据问题复杂度动态调整 LLM 的 maxTokens 参数。测试策略需要覆盖：

1. **核心算法正确性**: 复杂度评估和 token 计算逻辑
2. **系统集成**: 与现有 LLM 调用流程的集成
3. **性能验证**: 响应时间和 token 使用优化效果
4. **向后兼容**: 保持现有功能不受影响

### 测试场景统计

- **总测试场景**: 16
- **Unit 测试**: 12 (75%)
- **Integration 测试**: 4 (25%)
- **E2E 测试**: 0 (0%)

### 优先级分布

- **P0**: 10 场景 (关键功能和安全)
- **P1**: 4 场景 (性能验证)
- **P2**: 2 场景 (边界情况)

---

## 按验收标准的测试场景

### AC1: 实现动态 maxTokens 逻辑

#### 场景 4.9-UNIT-001: calculateMaxTokens - 简单问题返回 300

**测试级别**: Unit  
**优先级**: P0  
**理由**: 核心算法逻辑，必须保证正确性

**测试描述**:
```typescript
// Given: 问题复杂度为 'simple'
// When: 调用 calculateMaxTokens('simple')
// Then: 返回 300
```

**验证点**:
- 返回值精确为 300
- 无副作用

**风险覆盖**: 防止简单问题使用过多 tokens

---

#### 场景 4.9-UNIT-002: calculateMaxTokens - 复杂问题返回 500

**测试级别**: Unit  
**优先级**: P0  
**理由**: 核心算法逻辑，必须保证正确性

**测试描述**:
```typescript
// Given: 问题复杂度为 'complex'
// When: 调用 calculateMaxTokens('complex')
// Then: 返回 500
```

**验证点**:
- 返回值精确为 500
- 保持现有详细度标准

---

#### 场景 4.9-UNIT-003: generateAnswer - 简单问题使用动态 300 tokens

**测试级别**: Unit  
**优先级**: P0  
**理由**: 验证算法集成到生成流程

**测试描述**:
```typescript
// Given: 简单问题 "什么是Redis?"
// When: 调用 generateAnswer 不指定 maxTokens
// Then: LLM 调用参数中 maxTokens = 300
```

**验证点**:
- Mock LLM streamChatCompletion
- 验证传递的 options.maxTokens === 300
- 验证 assessComplexity 被调用

**风险覆盖**: 确保动态逻辑在实际流程中生效

---

#### 场景 4.9-UNIT-004: generateAnswer - 复杂问题使用动态 500 tokens

**测试级别**: Unit  
**优先级**: P0  
**理由**: 验证算法集成到生成流程

**测试描述**:
```typescript
// Given: 复杂问题 "详细分析Redis和Memcached的优缺点"
// When: 调用 generateAnswer 不指定 maxTokens
// Then: LLM 调用参数中 maxTokens = 500
```

**验证点**:
- Mock LLM streamChatCompletion
- 验证传递的 options.maxTokens === 500
- 验证 assessComplexity 返回 'complex'

**风险覆盖**: 确保复杂问题保持详细度

---

#### 场景 4.9-UNIT-005: generateAnswer - 用户指定值优先

**测试级别**: Unit  
**优先级**: P0  
**理由**: 向后兼容性，用户控制权

**测试描述**:
```typescript
// Given: 简单问题 "什么是Redis?"
// When: 调用 generateAnswer 指定 options.maxTokens = 800
// Then: LLM 调用参数中 maxTokens = 800 (忽略动态计算)
```

**验证点**:
- 用户指定值不被动态逻辑覆盖
- assessComplexity 仍被调用（用于日志）
- 向后兼容性保持

**风险覆盖**: 防止破坏现有 API 行为

---

### AC2: 增强复杂度评估算法

#### 场景 4.9-UNIT-006: assessComplexity - 识别简单问题

**测试级别**: Unit  
**优先级**: P0  
**理由**: 核心判断逻辑准确性

**测试描述**:
```typescript
// Given: 各种简单问题
// When: 调用 assessComplexity
// Then: 返回 'simple'
```

**测试用例**:
- "什么是Redis?" → simple
- "定义微服务" → simple
- "TypeScript是什么" → simple

**验证点**:
- 短问题（<40字符）识别
- 无复杂关键词
- 单个简单问题

---

#### 场景 4.9-UNIT-007: assessComplexity - 识别复杂问题（关键词）

**测试级别**: Unit  
**优先级**: P0  
**理由**: 核心判断逻辑准确性

**测试描述**:
```typescript
// Given: 包含复杂关键词的问题
// When: 调用 assessComplexity
// Then: 返回 'complex'
```

**测试用例**:
- "详细分析Redis的优缺点" → complex (关键词: 详细, 分析, 优缺点)
- "对比Redis和Memcached" → complex (关键词: 对比)
- "解释微服务的原理" → complex (关键词: 解释, 原理)

**验证点**:
- 关键词匹配逻辑
- 扩展的关键词列表生效

---

#### 场景 4.9-UNIT-008: assessComplexity - 识别复杂问题（长度）

**测试级别**: Unit  
**优先级**: P0  
**理由**: 阈值调整验证

**测试描述**:
```typescript
// Given: 超过40字符的长问题
// When: 调用 assessComplexity
// Then: 返回 'complex'
```

**测试用例**:
- "在微服务架构中，如何确保数据一致性和服务间通信的可靠性？" (42字) → complex

**验证点**:
- 长度阈值从 50 调整为 40
- 边界值测试: 40字符正好触发

**风险覆盖**: 防止阈值设置不当

---

#### 场景 4.9-UNIT-009: assessComplexity - 识别复杂问题（多问号）

**测试级别**: Unit  
**优先级**: P1  
**理由**: 新增判断逻辑

**测试描述**:
```typescript
// Given: 包含多个问号的问题
// When: 调用 assessComplexity
// Then: 返回 'complex'
```

**测试用例**:
- "什么是Docker？它解决了什么问题？" → complex
- "为什么选择TypeScript？它有什么优势？" → complex

**验证点**:
- 多问号检测逻辑
- 支持中文和英文问号

---

#### 场景 4.9-UNIT-010: assessComplexity - 识别复杂问题（列表标识）

**测试级别**: Unit  
**优先级**: P1  
**理由**: 新增判断逻辑

**测试描述**:
```typescript
// Given: 包含列表标识符的问题
// When: 调用 assessComplexity
// Then: 返回 'complex'
```

**测试用例**:
- "请列举：1. Redis的特点" → complex
- "分析：一、性能；二、可靠性" → complex

**验证点**:
- 列表标识符正则匹配
- 支持多种列表格式（数字、中文序号、符号）

---

### AC3: 添加日志和监控

#### 场景 4.9-UNIT-011: 日志记录 - 复杂度和动态 tokens

**测试级别**: Unit  
**优先级**: P1  
**理由**: 可观测性验证

**测试描述**:
```typescript
// Given: 执行 generateAnswer
// When: 完成生成
// Then: 日志包含复杂度和 tokens 信息
```

**验证点**:
- 日志包含 `complexity` 字段
- 日志包含 `dynamicMaxTokens` 字段
- 日志包含 `finalMaxTokens` 字段
- 日志包含 `userSpecifiedMaxTokens` (如果有)

**测试方法**:
- 使用 jest.spyOn(console, 'log')
- 验证日志参数对象结构

**风险覆盖**: 确保监控数据完整

---

### AC4: 单元测试覆盖动态逻辑

#### 场景 4.9-UNIT-012: 测试覆盖率验证

**测试级别**: Unit  
**优先级**: P0  
**理由**: 质量标准

**测试描述**:
```typescript
// Given: 所有新增/修改代码
// When: 运行 jest --coverage
// Then: 覆盖率 ≥ 90%
```

**验证点**:
- `calculateMaxTokens` 方法: 100% 覆盖
- `assessComplexity` 方法: 100% 覆盖
- `generateAnswer` 动态逻辑分支: 100% 覆盖

**测试方法**:
- 生成覆盖率报告
- 检查 answerService.ts 的行覆盖率

---

### AC5: 向后兼容性验证

#### 场景 4.9-INT-001: 集成测试 - 完整问答流程（简单问题）

**测试级别**: Integration  
**优先级**: P0  
**理由**: 端到端流程验证

**测试描述**:
```typescript
// Given: 真实 LLM 实例和简单问题
// When: 执行完整 generateAnswer 流程
// Then: 
//   1. 返回正确答案
//   2. 日志显示 complexity=simple, maxTokens=300
//   3. 响应时间 < 基准时间
```

**验证点**:
- 与 LLM Repository 集成正常
- 流式响应正常
- 日志完整

**风险覆盖**: 确保系统集成无回归

---

#### 场景 4.9-INT-002: 集成测试 - 完整问答流程（复杂问题）

**测试级别**: Integration  
**优先级**: P0  
**理由**: 端到端流程验证

**测试描述**:
```typescript
// Given: 真实 LLM 实例和复杂问题
// When: 执行完整 generateAnswer 流程
// Then: 
//   1. 返回详细答案
//   2. 日志显示 complexity=complex, maxTokens=500
//   3. 保持现有详细度
```

**验证点**:
- 复杂问题仍获得充分回答
- maxTokens = 500 保持不变
- 回答质量无下降

---

#### 场景 4.9-INT-003: 集成测试 - 用户指定值优先（端到端）

**测试级别**: Integration  
**优先级**: P1  
**理由**: 向后兼容性

**测试描述**:
```typescript
// Given: 真实 LLM 实例和用户指定 maxTokens
// When: 调用 generateAnswer({ maxTokens: 800 })
// Then: 日志显示 finalMaxTokens=800
```

**验证点**:
- 用户控制权保留
- 系统尊重用户配置

---

#### 场景 4.9-INT-004: 性能验证 - 简单问题响应时间提升

**测试级别**: Integration  
**优先级**: P1  
**理由**: 性能优化目标验证

**测试描述**:
```typescript
// Given: 真实 LLM 实例
// When: 测量简单问题响应时间
// Then: 响应时间比基准快约 30%
```

**测试方法**:
- 使用真实 API 调用
- 测量 10 次取平均
- 与优化前基准对比

**预期结果**:
- 优化前: ~2.5秒 (500 tokens)
- 优化后: ~1.8秒 (300 tokens)
- 提升: ~28-30%

---

## 测试覆盖率缺口

### 无缺口

所有 5 个 AC 都有充分的测试覆盖：
- ✅ AC1: 5个测试场景（UNIT-001 到 UNIT-005）
- ✅ AC2: 5个测试场景（UNIT-006 到 UNIT-010）
- ✅ AC3: 1个测试场景（UNIT-011）
- ✅ AC4: 1个测试场景（UNIT-012）
- ✅ AC5: 4个测试场景（INT-001 到 INT-004）

---

## 风险覆盖矩阵

| 风险 | 严重度 | 测试场景 | 缓解状态 |
|------|--------|----------|----------|
| 复杂度判断不准确 | 中 | UNIT-006 到 UNIT-010 | ✅ 完全覆盖 |
| 简单问题回答过于简短 | 低 | INT-002, INT-004 | ✅ 通过集成测试验证 |
| 向后兼容性破坏 | 中 | UNIT-005, INT-003 | ✅ 专门测试 |
| 性能目标未达成 | 低 | INT-004 | ✅ 性能基准测试 |
| 日志缺失影响监控 | 低 | UNIT-011 | ✅ 日志完整性验证 |

---

## 推荐执行顺序

### 阶段 1: 核心算法验证 (P0)

1. UNIT-001, UNIT-002: calculateMaxTokens 基础逻辑
2. UNIT-006, UNIT-007, UNIT-008: assessComplexity 核心场景
3. UNIT-003, UNIT-004, UNIT-005: generateAnswer 集成

**目标**: 确保核心逻辑正确，快速失败

### 阶段 2: 增强功能验证 (P1)

4. UNIT-009, UNIT-010: assessComplexity 增强场景
5. UNIT-011: 日志完整性
6. UNIT-012: 覆盖率验证

**目标**: 验证所有新增功能

### 阶段 3: 集成和性能验证 (P0+P1)

7. INT-001, INT-002: 完整流程集成
8. INT-003: 向后兼容性
9. INT-004: 性能目标验证

**目标**: 端到端验证和性能基准

---

## 测试数据需求

### Mock 数据

**LLM Mock 响应**:
```typescript
const mockSimpleResponse = async function* () {
  yield "Redis是一个开源的内存数据结构存储系统。"
}

const mockComplexResponse = async function* () {
  yield "Redis和Memcached都是流行的内存缓存系统..."
  yield "Redis的优点包括：1. 支持多种数据结构..."
  // ... 更详细的回答
}
```

**测试问题集**:
```typescript
const testQueries = {
  simple: [
    "什么是Redis?",
    "定义微服务",
    "TypeScript是什么"
  ],
  complex: [
    "详细分析Redis和Memcached的优缺点",
    "在微服务架构中，如何确保数据一致性？",
    "为什么选择TypeScript？它有什么优势？"
  ]
}
```

### 真实 API 调用 (集成测试)

- 使用测试环境的 LLM API
- 确保有足够的 API 配额
- 测试时间窗口: 非高峰期

---

## 自动化策略

### CI/CD 集成

```yaml
# GitHub Actions 示例
- name: Run Unit Tests
  run: npm test -- tests/unit/services/rag/answerService.test.ts
  
- name: Check Coverage
  run: npm run test:coverage
  if: coverage < 90% then fail
  
- name: Run Integration Tests
  run: npm test -- tests/integration/rag/
  env:
    ZHIPU_API_KEY: ${{ secrets.ZHIPU_API_KEY }}
```

### 测试隔离

- Unit 测试: 完全 Mock，无外部依赖
- Integration 测试: 使用真实 LLM API，但可以用环境变量控制

---

## 性能基准

### 响应时间目标

| 场景 | 优化前 | 优化后 | 提升 |
|------|--------|--------|------|
| 简单问题 | ~2.5秒 | ~1.8秒 | 28% |
| 复杂问题 | ~2.5秒 | ~2.5秒 | 0% |

### Token 使用目标

| 场景 | 优化前 | 优化后 | 节省 |
|------|--------|--------|------|
| 简单问题 | 500 tokens | 300 tokens | 40% |
| 复杂问题 | 500 tokens | 500 tokens | 0% |
| 整体平均 | 500 tokens | 400 tokens | 20% |

---

## 测试环境要求

### 必需环境变量

```bash
# LLM API (集成测试)
ZHIPU_API_KEY=your_test_api_key

# 可选: Token 配置覆盖
LLM_MAX_TOKENS_SIMPLE=300
LLM_MAX_TOKENS_COMPLEX=500
```

### 依赖版本

- Node.js: 18+
- Jest: ^29.7.0
- TypeScript: ^5.3.3

---

## 质量门禁

### 测试通过标准

- ✅ 所有 P0 测试 100% 通过
- ✅ 单元测试覆盖率 ≥ 90%
- ✅ 集成测试 100% 通过
- ✅ 性能基准达标（简单问题响应时间 < 2秒）

### 回归测试

- ✅ 所有现有 answerService 测试仍然通过
- ✅ 所有现有集成测试仍然通过

---

## 关键原则总结

1. **测试金字塔**: 75% Unit, 25% Integration, 0% E2E（功能级改进无需 E2E）
2. **快速反馈**: Unit 测试提供快速失败机制
3. **真实验证**: Integration 测试验证与 LLM 的真实集成
4. **性能验证**: 集成测试验证性能目标达成
5. **向后兼容**: 专门测试用户控制权保留

---

**测试设计完成日期**: 2025-01-15  
**审核状态**: 待审核  
**预计测试执行时间**: 2小时（Unit）+ 1小时（Integration）= 3小时

