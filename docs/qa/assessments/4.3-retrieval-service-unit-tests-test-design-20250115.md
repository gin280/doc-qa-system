# 测试设计: Story 4.3 - RetrievalService 单元测试

**日期**: 2025-01-15  
**设计者**: Quinn (测试架构师)  
**Story**: 4.3 - RetrievalService 单元测试

---

## 测试策略概述

- **测试场景总数**: 45
- **单元测试**: 44 (97.8%)
- **集成测试**: 1 (2.2%)
- **E2E测试**: 0 (0%)
- **优先级分布**: P0: 35, P1: 8, P2: 2

**特殊说明**: 这是一个**元测试Story**（测试的测试），目标是为 RetrievalService 创建全面的单元测试套件。

---

## 按验收标准的测试场景

### AC1: 核心方法 retrieveContext 完整测试

#### 场景 1.1: 成功检索相关chunks

| ID | 级别 | 优先级 | 测试场景 | 验证要点 |
|----|------|--------|----------|----------|
| 4.3-UNIT-001 | Unit | P0 | 正常流程返回相关chunks | chunks长度、内容、score、documentId正确 |
| 4.3-UNIT-002 | Unit | P0 | 返回结果cached=false | 非缓存场景cached字段为false |
| 4.3-UNIT-003 | Unit | P0 | retrievalTime统计正确 | retrievalTime > 0且合理（< 1000ms in mock） |

**测试级别理由**: 纯业务逻辑，所有依赖可Mock，适合单元测试

---

#### 场景 1.2: 按相似度排序验证

| ID | 级别 | 优先级 | 测试场景 | 验证要点 |
|----|------|--------|----------|----------|
| 4.3-UNIT-004 | Unit | P0 | 按score降序排序 | chunks[0].score ≥ chunks[1].score ≥ chunks[2].score |
| 4.3-UNIT-005 | Unit | P0 | score相同时按chunkIndex升序 | 验证排序稳定性，文档顺序保持 |

**测试级别理由**: 算法逻辑验证，单元测试即可

---

#### 场景 1.3: topK参数生效验证

| ID | 级别 | 优先级 | 测试场景 | 验证要点 |
|----|------|--------|----------|----------|
| 4.3-UNIT-006 | Unit | P0 | topK=3时返回最多3个chunks | chunks.length ≤ 3 |
| 4.3-UNIT-007 | Unit | P0 | topK默认值为5 | 不传topK时默认返回5个 |
| 4.3-UNIT-008 | Unit | P1 | topK=1时返回最高分chunk | chunks.length = 1 |
| 4.3-UNIT-009 | Unit | P1 | topK > 总结果数时返回所有 | 有10个结果时topK=20返回10个 |

**测试级别理由**: 参数逻辑验证，单元测试足够

---

#### 场景 1.4: minScore参数生效验证

| ID | 级别 | 优先级 | 测试场景 | 验证要点 |
|----|------|--------|----------|----------|
| 4.3-UNIT-010 | Unit | P0 | minScore参数传递给vectorRepo | 验证search()调用参数正确 |
| 4.3-UNIT-011 | Unit | P0 | minScore默认值为0.3 | 不传minScore时默认0.3 |
| 4.3-UNIT-012 | Unit | P1 | 自定义minScore生效 | minScore=0.7时传递正确 |

**测试级别理由**: 参数传递验证，单元测试即可

---

### AC2: 输入验证边界情况测试

#### 场景 2.1: 空查询验证

| ID | 级别 | 优先级 | 测试场景 | 验证要点 |
|----|------|--------|----------|----------|
| 4.3-UNIT-013 | Unit | P0 | 空字符串抛出INVALID_QUERY | query='' 抛出错误 |
| 4.3-UNIT-014 | Unit | P0 | 纯空格抛出INVALID_QUERY | query='   ' 抛出错误 |
| 4.3-UNIT-015 | Unit | P0 | 错误消息友好 | message包含'cannot be empty' |

**测试级别理由**: 输入验证逻辑，单元测试覆盖

---

#### 场景 2.2: 超长查询验证

| ID | 级别 | 优先级 | 测试场景 | 验证要点 |
|----|------|--------|----------|----------|
| 4.3-UNIT-016 | Unit | P0 | 1001字符抛出INVALID_QUERY | 超过1000字符限制 |
| 4.3-UNIT-017 | Unit | P0 | 1000字符通过验证 | 边界值正好1000通过 |
| 4.3-UNIT-018 | Unit | P1 | 错误消息包含限制说明 | message包含'max 1000 characters' |

**测试级别理由**: 边界值验证，单元测试足够

---

### AC3: 文档权限验证测试

#### 场景 3.1: 文档不存在

| ID | 级别 | 优先级 | 测试场景 | 验证要点 |
|----|------|--------|----------|----------|
| 4.3-UNIT-019 | Unit | P0 | 文档不存在抛出DOCUMENT_NOT_FOUND | db查询返回[] |
| 4.3-UNIT-020 | Unit | P0 | 错误消息适当模糊 | 'not found or access denied'不泄露信息 |

**测试级别理由**: 权限逻辑，可Mock数据库

---

#### 场景 3.2: 用户无权限

| ID | 级别 | 优先级 | 测试场景 | 验证要点 |
|----|------|--------|----------|----------|
| 4.3-UNIT-021 | Unit | P0 | 其他用户文档抛出错误 | userId不匹配返回[] |
| 4.3-UNIT-022 | Unit | P0 | 使用AND条件查询 | 验证where使用and(eq(id), eq(userId)) |

**测试级别理由**: 数据库查询逻辑，Mock验证

---

#### 场景 3.3: 文档状态检查

| ID | 级别 | 优先级 | 测试场景 | 验证要点 |
|----|------|--------|----------|----------|
| 4.3-UNIT-023 | Unit | P0 | PROCESSING状态抛出DOCUMENT_NOT_READY | status='PROCESSING'不可查询 |
| 4.3-UNIT-024 | Unit | P0 | FAILED状态抛出DOCUMENT_NOT_READY | status='FAILED'不可查询 |
| 4.3-UNIT-025 | Unit | P0 | READY状态通过验证 | status='READY'可以查询 |
| 4.3-UNIT-026 | Unit | P1 | 错误消息提示等待处理 | message包含'not ready yet' |

**测试级别理由**: 状态机逻辑，单元测试覆盖

---

### AC4: 缓存逻辑测试

#### 场景 4.1: 缓存命中

| ID | 级别 | 优先级 | 测试场景 | 验证要点 |
|----|------|--------|----------|----------|
| 4.3-UNIT-027 | Unit | P0 | 缓存命中时直接返回 | getCachedResult返回非null |
| 4.3-UNIT-028 | Unit | P0 | 缓存命中不调用向量化 | queryVectorizer.vectorizeQuery未被调用 |
| 4.3-UNIT-029 | Unit | P0 | 缓存命中不调用检索 | vectorRepo.search未被调用 |
| 4.3-UNIT-030 | Unit | P0 | 返回结果cached=true | 缓存结果的cached字段为true |

**测试级别理由**: 缓存逻辑编排，Mock验证行为

---

#### 场景 4.2: 缓存未命中

| ID | 级别 | 优先级 | 测试场景 | 验证要点 |
|----|------|--------|----------|----------|
| 4.3-UNIT-031 | Unit | P0 | 缓存未命中执行检索 | getCachedResult返回null时执行全流程 |
| 4.3-UNIT-032 | Unit | P0 | 检索后写入缓存 | setCachedResult被调用 |
| 4.3-UNIT-033 | Unit | P0 | 缓存参数正确 | setCachedResult(documentId, query, result) |

**测试级别理由**: 缓存未命中场景，Mock验证

---

#### 场景 4.3: 缓存开关

| ID | 级别 | 优先级 | 测试场景 | 验证要点 |
|----|------|--------|----------|----------|
| 4.3-UNIT-034 | Unit | P0 | useCache=false跳过缓存检查 | getCachedResult未被调用 |
| 4.3-UNIT-035 | Unit | P0 | useCache=false跳过缓存写入 | setCachedResult未被调用 |
| 4.3-UNIT-036 | Unit | P1 | 缓存服务disabled时不使用 | isEnabled()=false时跳过缓存 |

**测试级别理由**: 配置逻辑，单元测试验证

---

#### 场景 4.4: 缓存失败处理

| ID | 级别 | 优先级 | 测试场景 | 验证要点 |
|----|------|--------|----------|----------|
| 4.3-UNIT-037 | Unit | P0 | 缓存写入失败不影响主流程 | setCachedResult reject不抛出 |
| 4.3-UNIT-038 | Unit | P1 | 缓存读取失败降级到检索 | getCachedResult reject时继续检索 |

**测试级别理由**: 错误处理逻辑，单元测试验证降级行为

---

### AC5: 无相关内容场景测试

| ID | 级别 | 优先级 | 测试场景 | 验证要点 |
|----|------|--------|----------|----------|
| 4.3-UNIT-039 | Unit | P0 | 空结果抛出NO_RELEVANT_CONTENT | vectorRepo.search返回[] |
| 4.3-UNIT-040 | Unit | P0 | 错误消息友好可操作 | message='No relevant content found' |

**测试级别理由**: 边界场景验证，单元测试覆盖

---

### AC6: 错误处理测试

#### 场景 6.1: 错误传播

| ID | 级别 | 优先级 | 测试场景 | 验证要点 |
|----|------|--------|----------|----------|
| 4.3-UNIT-041 | Unit | P0 | QueryVectorizationError正确传播 | 不包装，直接抛出 |
| 4.3-UNIT-042 | Unit | P0 | RetrievalError正确传播 | 不包装，直接抛出 |

**测试级别理由**: 错误处理逻辑，单元测试验证

---

#### 场景 6.2: 未知错误包装

| ID | 级别 | 优先级 | 测试场景 | 验证要点 |
|----|------|--------|----------|----------|
| 4.3-UNIT-043 | Unit | P0 | 未知错误包装为RETRIEVAL_ERROR | 其他Error转换为RetrievalError |
| 4.3-UNIT-044 | Unit | P1 | 错误日志包含上下文 | 日志包含documentId, userId, query前50字符 |

**测试级别理由**: 错误包装逻辑，单元测试验证

---

### AC7: Mock 外部依赖

**注**: 这不是单独的测试场景，而是所有测试的基础设施要求

**Mock清单**:
- ✅ Mock db (Drizzle ORM 链式API)
- ✅ Mock queryVectorizer
- ✅ Mock vectorRepo
- ✅ Mock queryCacheService
- ✅ 每个测试独立，beforeEach重置Mock

---

### AC8: 辅助方法测试

| ID | 级别 | 优先级 | 测试场景 | 验证要点 |
|----|------|--------|----------|----------|
| 4.3-UNIT-045 | Unit | P1 | invalidateDocumentCache调用缓存服务 | 正确传递documentId |

**测试级别理由**: 方法委托，单元测试验证调用

---

### 集成测试: Mock验证

| ID | 级别 | 优先级 | 测试场景 | 验证要点 |
|----|------|--------|----------|----------|
| 4.3-INT-001 | Integration | P2 | Mock行为与真实系统一致性验证 | 对比单元测试和集成测试的结果 |

**测试级别理由**: 
- 验证Mock的准确性需要真实系统对比
- 降低假阴性风险
- 可选但推荐

**建议**:
创建一个简单的集成测试，使用真实依赖运行一次 retrieveContext，记录：
- db查询返回的数据结构
- queryVectorizer返回的向量格式
- vectorRepo.search返回的结果格式
- 与Mock数据对比，确保一致

---

## 优先级分类汇总

### P0 (Critical) - 35个场景

**必须通过的核心场景**:
- 所有正常流程测试 (6个)
- 所有输入验证测试 (5个)
- 所有权限验证测试 (8个)
- 核心缓存逻辑测试 (10个)
- 关键错误处理测试 (6个)

**不通过影响**: 无法保证RetrievalService基本功能正确性

---

### P1 (High) - 8个场景

**重要但非阻塞的场景**:
- 边界值细节验证 (4个)
- 错误消息质量验证 (3个)
- 辅助方法验证 (1个)

**不通过影响**: 功能可用但用户体验或边界情况处理不完善

---

### P2 (Medium) - 2个场景

**Nice-to-have的场景**:
- 集成测试验证Mock (1个)
- 高级缓存场景 (可能包含在P0中)

**不通过影响**: 测试质量保障不够全面，但基本功能测试完整

---

## 测试执行顺序

### 阶段1: 基础设施搭建 (1小时)
1. 创建测试文件和基本结构
2. 配置所有Mock
3. 准备测试数据

### 阶段2: P0测试实施 (4小时)
**执行顺序**（Fail Fast原则）:
1. **输入验证测试** (15分钟) - 最简单，快速验证Mock配置
2. **文档权限验证测试** (30分钟) - 验证数据库Mock
3. **正常流程测试** (1小时) - 核心功能
4. **缓存逻辑测试** (1.5小时) - 最复杂的组合
5. **错误处理测试** (1小时) - 确保异常安全

### 阶段3: P1测试实施 (1.5小时)
- 补充边界值和细节验证

### 阶段4: 覆盖率验证和补充 (1小时)
1. 运行覆盖率报告
2. 识别未覆盖分支
3. 补充测试用例

### 阶段5: P2测试（可选，0.5小时）
- 集成测试对比

---

## 测试数据准备

### Mock Document

```typescript
const mockDocument = {
  id: 'doc-test-123',
  userId: 'user-test-456',
  status: 'READY',
  filename: 'test-document.pdf',
  createdAt: new Date('2025-01-01'),
  updatedAt: new Date('2025-01-01')
}
```

### Mock Vector (1024维)

```typescript
const mockVector = new Array(1024).fill(0).map((_, i) => 
  Math.sin(i / 100) // 生成有规律的测试向量
)
```

### Mock Vector Search Results

```typescript
const mockVectorResults = [
  {
    id: 'chunk-1',
    score: 0.85,
    metadata: {
      documentId: 'doc-test-123',
      chunkIndex: 0,
      content: 'First chunk content with relevant information.',
      pageNumber: 1,
      section: 'Introduction'
    }
  },
  {
    id: 'chunk-2',
    score: 0.75,
    metadata: {
      documentId: 'doc-test-123',
      chunkIndex: 1,
      content: 'Second chunk with related details.',
      pageNumber: 1,
      section: 'Introduction'
    }
  },
  {
    id: 'chunk-3',
    score: 0.65,
    metadata: {
      documentId: 'doc-test-123',
      chunkIndex: 2,
      content: 'Third chunk with some context.',
      pageNumber: 2,
      section: 'Background'
    }
  }
]
```

### Mock Cached Result

```typescript
const mockCachedResult: RetrievalResult = {
  chunks: [
    {
      id: 'chunk-cached-1',
      documentId: 'doc-test-123',
      chunkIndex: 0,
      content: 'Cached chunk content',
      score: 0.9,
      metadata: { pageNumber: 1, section: 'Intro' }
    }
  ],
  totalFound: 1,
  query: 'test query from cache',
  documentId: 'doc-test-123',
  cached: true,
  retrievalTime: 5 // 缓存命中非常快
}
```

---

## 覆盖率目标和验证

### 目标

- **行覆盖率**: ≥ 90%
- **分支覆盖率**: ≥ 85%
- **函数覆盖率**: 100%

### 关键覆盖点

**必须覆盖的分支**:
1. ✅ 输入验证: 空查询 / 超长查询 / 正常查询
2. ✅ 缓存: enabled & useCache=true / enabled & useCache=false / disabled
3. ✅ 缓存: hit / miss / error
4. ✅ 文档权限: 不存在 / 无权限 / 状态非READY / 正常
5. ✅ 向量检索: 空结果 / 有结果 / 错误
6. ✅ 错误处理: 各种错误类型的传播和包装

**难以覆盖的分支**（可能需要特殊测试）:
- 并行执行中一个Promise reject另一个resolve的情况
- 缓存异步写入catch分支

### 验证方法

```bash
# 运行带覆盖率的测试
npm test -- tests/unit/services/rag/retrievalService.test.ts --coverage

# 查看详细报告
open coverage/lcov-report/services/rag/retrievalService.ts.html

# 检查未覆盖的行
grep -A 5 "0$" coverage/lcov.info | grep retrievalService
```

---

## 风险缓解映射

测试设计如何缓解已识别的风险：

### TECH-002: 测试覆盖不足
**缓解措施**: 
- 45个测试场景覆盖所有AC
- 覆盖率目标明确（≥90%行, ≥85%分支）
- 包含边界值和错误路径

### BUS-002: Mock不当
**缓解措施**:
- 4.3-INT-001 集成测试验证Mock准确性
- Mock数据结构与真实系统对齐
- Mock调用参数精确验证

### TECH-001: Drizzle Mock复杂
**缓解措施**:
- 详细的Mock设置示例
- 验证链式调用顺序
- 4.3-UNIT-022 验证where条件正确

### TECH-003: 测试脆弱
**缓解措施**:
- 测试公共接口行为（retrieveContext输入输出）
- 不测试私有方法实现细节
- Mock验证限制在关键交互

### MNT-001: 测试难维护
**缓解措施**:
- 提取Mock设置辅助函数
- 清晰的测试数据Builder
- 注释说明关键Mock意图

---

## 成功标准

### 必须达成

- ✅ 所有P0测试（35个）通过
- ✅ 行覆盖率 ≥ 90%
- ✅ 分支覆盖率 ≥ 85%
- ✅ 函数覆盖率 = 100%
- ✅ 所有Mock配置正确且独立
- ✅ 测试执行时间 < 5秒

### 推荐达成

- ✅ 所有P1测试（8个）通过
- ✅ 行覆盖率 ≥ 95%
- ✅ 集成测试验证Mock准确性
- ✅ 测试代码可读性好，有注释

### Nice-to-have

- ✅ P2测试通过
- ✅ 突变测试验证测试质量
- ✅ 测试执行时间 < 3秒

---

## 测试维护指南

### 何时更新测试

1. **RetrievalService实现变更** - 添加/修改测试用例
2. **新增错误码** - 添加错误处理测试
3. **依赖API变更** - 更新Mock配置
4. **性能优化** - 更新执行时间预期

### 测试代码质量标准

- 每个测试场景独立，可单独运行
- Mock在beforeEach中重置，避免污染
- 使用描述性的测试名称（中文可读）
- 关键Mock有注释说明意图
- 复杂测试有Given-When-Then注释

---

## 总结

### 测试策略亮点

1. **全面覆盖**: 45个测试场景覆盖所有AC和边界情况
2. **优先级明确**: P0/P1/P2分类，Fail Fast执行
3. **Mock准确**: 集成测试验证Mock与真实系统一致
4. **可维护**: 辅助函数、清晰数据、充分注释
5. **目标清晰**: 覆盖率、执行时间、质量标准明确

### 预期成果

完成后，RetrievalService将有：
- ✅ 覆盖率≥90%的单元测试套件
- ✅ 所有关键路径和错误场景的验证
- ✅ 可维护且不脆弱的测试代码
- ✅ 快速执行（<5秒）的测试反馈
- ✅ 防止回归的安全网

---

**设计完成日期**: 2025-01-15  
**审核者**: Quinn (测试架构师)

