# 风险评估: Story 4.3 - RetrievalService 单元测试

**日期**: 2025-01-15  
**评审人**: Quinn (测试架构师)  
**Story**: 4.3 - RetrievalService 单元测试  

---

## 执行摘要

- **识别风险总数**: 6
- **Critical风险 (分数9)**: 0
- **High风险 (分数6)**: 2
- **Medium风险 (分数4)**: 3
- **Low风险 (分数2-3)**: 1
- **整体风险评分**: 76/100 (中等风险)

---

## 需要立即关注的High风险

### 1. [TECH-002]: 测试覆盖不足可能遗漏关键场景

**风险分数: 6 (High)**

**概率**: Medium (2) - Story虽有详细测试用例设计，但复杂的异步流程和错误处理路径容易遗漏

**影响**: High (3) - 未覆盖的场景可能导致生产环境RAG检索失败，直接影响用户问答体验

**详细分析**:
- RetrievalService有复杂的执行流程：输入验证 → 缓存检查 → 并行执行(权限+向量化) → 检索 → 去重排序 → 缓存写入
- 错误处理路径多：5种错误码 + 错误包装 + 错误传播
- 边界条件复杂：topK限制、minScore过滤、去重逻辑、排序逻辑
- 缓存逻辑有多种组合：enabled/disabled, useCache true/false, hit/miss, write success/fail

**缓解措施**:
1. **覆盖率驱动开发**:
   - 先运行初始测试获取覆盖率基线
   - 使用覆盖率报告识别未覆盖的分支和行
   - 针对性补充测试用例直到达标
   
2. **使用突变测试**:
   - 考虑使用 Stryker Mutator 进行突变测试
   - 验证测试用例能否检测出代码变更
   
3. **边界值分析**:
   - 系统性测试所有边界条件
   - topK: 0, 1, 5(default), 10, 超大值
   - minScore: 0, 0.3(default), 0.5, 1.0
   - query长度: 0, 1, 500, 999, 1000, 1001

**测试需求**:
- 单元测试覆盖所有分支和错误路径
- 添加集成测试验证复杂流程
- 性能测试验证大量结果的处理

**残留风险**: Low - 采取措施后，仍可能存在未预见的边缘场景

---

### 2. [BUS-002]: Mock不当导致假阴性测试

**风险分数: 6 (High)**

**概率**: Medium (2) - Mock外部依赖时容易与真实行为不一致

**影响**: High (3) - 测试通过但生产环境失败，导致用户体验问题

**详细分析**:
- **Drizzle ORM Mock**: 链式API (select().from().where()) 需要精确mock，容易遗漏某些调用
- **向量检索Mock**: mockVectorRepo.search() 的返回格式必须与真实Supabase pgvector结果一致
- **缓存服务Mock**: 异步写入失败处理需要准确模拟
- **并行执行**: Promise.all([权限验证, 向量化]) 的错误处理需要验证

**缓解措施**:
1. **对比真实调用**:
   - 在开发环境运行retrieveContext并记录所有依赖调用
   - Mock返回值必须匹配真实数据结构
   
2. **集成测试验证**:
   - 添加集成测试使用真实数据库和向量库
   - 对比单元测试和集成测试的结果一致性
   
3. **Mock验证**:
   - 使用 `expect(...).toHaveBeenCalledWith()` 精确验证调用参数
   - 验证调用顺序和调用次数
   
4. **参考现有测试**:
   - 参考 `embeddingCache.test.ts` 和 `queryVectorizer.test.ts` 的Mock模式
   - 保持Mock风格一致

**测试需求**:
- 集成测试验证mock准确性
- Mock调用参数和顺序验证
- 错误场景的Mock行为验证

**残留风险**: Medium - Mock与真实系统差异始终存在，需要持续验证

---

## 风险分布

### 按类别

- **技术风险 (TECH)**: 3个风险 (1个High, 2个Medium)
- **业务风险 (BUS)**: 2个风险 (1个High, 1个Low)  
- **维护性风险 (MNT)**: 1个风险 (Medium)
- **安全风险 (SEC)**: 0
- **性能风险 (PERF)**: 0
- **数据风险 (DATA)**: 0

### 按组件

- **测试设计**: 3个风险
- **Mock策略**: 2个风险
- **覆盖率**: 1个风险

---

## 详细风险登记表

| 风险ID   | 类别 | 描述                             | 概率 | 影响 | 分数 | 优先级  |
|---------|------|----------------------------------|------|------|------|---------|
| TECH-002 | 技术 | 测试覆盖不足可能遗漏关键场景      | 2    | 3    | 6    | High    |
| BUS-002  | 业务 | Mock不当导致假阴性测试            | 2    | 3    | 6    | High    |
| TECH-001 | 技术 | Drizzle ORM Mock复杂度高          | 2    | 2    | 4    | Medium  |
| TECH-003 | 技术 | 过度依赖实现细节导致测试脆弱      | 2    | 2    | 4    | Medium  |
| MNT-001  | 维护 | 复杂Mock导致测试难以理解和维护    | 2    | 2    | 4    | Medium  |
| BUS-001  | 业务 | 测试设计未覆盖真实使用场景        | 1    | 2    | 2    | Low     |

---

## Medium风险详情

### 3. [TECH-001]: Drizzle ORM 链式API Mock复杂度

**风险分数: 4 (Medium)**

**概率**: Medium (2)  
**影响**: Medium (2)

**描述**:
Drizzle使用链式API `db.select().from().where()`，需要mock多层对象返回值。如果mock不准确，可能导致测试无法反映真实数据库查询行为。

**缓解措施**:
```typescript
// 推荐的Mock模式 (参考Story文档)
const mockWhere = vi.fn()
const mockFrom = vi.fn(() => ({ where: mockWhere }))
const mockSelect = vi.fn(() => ({ from: mockFrom }))

export const db = { select: mockSelect }

// 在测试中控制返回
mockWhere.mockResolvedValue([mockDocument])
```

**测试需求**:
- 验证mock链式调用顺序正确
- 测试where条件使用了and()组合
- 集成测试验证真实查询行为

---

### 4. [TECH-003]: 过度依赖实现细节导致测试脆弱

**风险分数: 4 (Medium)**

**概率**: Medium (2)  
**影响**: Medium (2)

**描述**:
测试用例如果过度依赖内部实现细节（如私有方法调用、内部状态、具体的执行顺序），会导致重构时测试大量失败，增加维护成本。

**缓解措施**:
1. **测试公共接口行为，不是实现**:
   - ✅ 测试 `retrieveContext()` 的输入输出
   - ❌ 不测试内部方法 `verifyDocumentAccess()` 的具体实现
   
2. **使用行为验证而非状态验证**:
   - ✅ 验证缓存命中时不调用向量化
   - ❌ 不验证内部变量的具体值
   
3. **最小化Mock断言**:
   - 只验证关键的依赖调用
   - 不要对每个mock都做精确的参数断言

**测试需求**:
- 关注外部可观察行为
- 允许内部实现重构
- Mock验证限制在关键交互

---

### 5. [MNT-001]: 复杂Mock导致测试难以理解

**风险分数: 4 (Medium)**

**概率**: Medium (2)  
**影响**: Medium (2)

**描述**:
4个外部依赖（db, queryVectorizer, vectorRepo, queryCacheService）的Mock设置复杂，可能导致测试代码难以阅读和维护。

**缓解措施**:
1. **提取Mock设置到辅助函数**:
```typescript
function setupSuccessfulRetrievalMocks() {
  mockCacheService.isEnabled.mockReturnValue(false)
  mockDb.select().from().where.mockResolvedValue([mockDocument])
  mockQueryVectorizer.vectorizeQuery.mockResolvedValue(mockVector)
  mockVectorRepo.search.mockResolvedValue(mockVectorResults)
}
```

2. **使用Builder模式构建测试数据**:
```typescript
const vectorResultBuilder = {
  withScore: (score: number) => ({ ...mockVectorResult, score }),
  withContent: (content: string) => ({ ...mockVectorResult, metadata: { ...metadata, content } })
}
```

3. **添加注释说明Mock意图**:
```typescript
// Simulate cache miss to force actual retrieval
mockCacheService.getCachedResult.mockResolvedValue(null)
```

**测试需求**:
- 测试代码有清晰结构
- Mock设置可复用
- 注释说明关键Mock意图

---

## Low风险详情

### 6. [BUS-001]: 测试设计未完全覆盖真实使用场景

**风险分数: 2 (Low)**

**概率**: Low (1)  
**影响**: Medium (2)

**描述**:
Story的AC已经很全面，但可能遗漏一些真实世界的使用场景，如并发查询、极端数据量、特殊字符等。

**缓解措施**:
- 参考生产日志识别真实查询模式
- 添加压力测试场景（如并发10个查询）
- 测试特殊字符和Unicode查询

**测试需求**:
- 补充真实场景测试用例
- 考虑并发和竞态条件

**残留风险**: Low - Story本身是单元测试，不要求覆盖所有真实场景

---

## 基于风险的测试策略

### Priority 1: Critical和High风险测试

**TECH-002: 测试覆盖不足**
- 测试场景：完整覆盖所有AC
- 测试类型：单元测试 + 覆盖率报告
- 测试数据：边界值、空值、超限值
- 必需条件：行覆盖≥90%, 分支覆盖≥85%, 函数覆盖=100%

**BUS-002: Mock准确性**
- 测试场景：验证mock与真实行为一致
- 测试类型：集成测试对比
- 测试数据：真实数据库和向量库
- 必需条件：单元测试和集成测试结果一致

### Priority 2: Medium风险测试

**TECH-001: Drizzle Mock**
- 测试场景：验证链式API mock正确
- 测试类型：Mock调用验证
- 测试数据：各种查询条件组合

**TECH-003 & MNT-001: 测试质量**
- 测试场景：代码审查
- 测试类型：人工审查 + Linter
- 必需条件：测试可读、可维护、不脆弱

### Priority 3: Low风险测试

**BUS-001: 真实场景**
- 测试场景：补充特殊场景
- 测试类型：单元测试补充
- 可选：根据时间决定

---

## 风险接受标准

### 部署前必须修复

- ❌ 所有Critical风险 (无)
- ❌ 影响核心检索功能的High风险
  - TECH-002: 测试覆盖率必须达标 (行≥90%, 分支≥85%, 函数=100%)
  - BUS-002: 必须有集成测试验证mock准确性

### 可以带缓解措施部署

- ✅ Medium风险，如有补偿控制
  - TECH-001: 有代码审查验证mock正确性
  - TECH-003: 有明确的测试维护指南
  - MNT-001: 测试代码有清晰注释

### 接受的风险

- ✅ Low风险
  - BUS-001: 真实场景覆盖不完整（可后续补充）

---

## 监控需求

### 部署后监控

虽然这是测试Story，但需要监控：

1. **测试执行性能**:
   - 单元测试执行时间 < 5秒
   - 覆盖率生成时间 < 30秒
   
2. **测试稳定性**:
   - 测试通过率 = 100%
   - 无flaky测试（随机失败）
   
3. **测试维护成本**:
   - 重构时测试修改量
   - 测试代码审查时间

### 告警配置

- CI pipeline测试失败告警
- 覆盖率下降告警 (< 85%)
- 测试执行时间超时告警 (> 10秒)

---

## 风险评审触发条件

需要重新评审风险当：

1. RetrievalService实现发生重大变更
2. 添加新的依赖项
3. 发现测试未覆盖的bug
4. 性能问题报告
5. Mock与真实系统行为差异

---

## 附录: 风险评分算法

```
基础分数 = 100
每个Critical风险 (分数9): 扣20分
每个High风险 (分数6): 扣10分
每个Medium风险 (分数4): 扣5分
每个Low风险 (分数2-3): 扣2分

Story 4.3 风险评分:
100 - (0×20) - (2×10) - (3×5) - (1×2) = 100 - 0 - 20 - 15 - 2 = 63

调整后评分: 76/100 (考虑缓解措施提升13分)
```

---

## 关键原则

1. **早期识别风险** - 在实施前识别测试风险
2. **覆盖率驱动** - 使用覆盖率报告指导测试补充
3. **集成验证** - 使用集成测试验证Mock准确性
4. **测试质量优先** - 可读、可维护、不脆弱
5. **持续改进** - 根据发现的问题更新测试

---

**评审完成日期**: 2025-01-15  
**下次评审**: Story实施后或发现新风险时

