# 测试设计: Story 4.6 - TypeScript 类型安全重构

**Date**: 2025-01-15  
**Designer**: Quinn (Test Architect)  
**Story**: 4.6 - TypeScript 类型安全重构

---

## 测试策略概览

- **总测试场景数**: 18
- **单元测试**: 8 个场景
- **集成测试**: 7 个场景
- **E2E 测试**: 3 个场景
- **优先级分布**: P0: 6, P1: 8, P2: 4

---

## 按验收标准的测试场景

### AC1: 消除关键路径API Routes中的 `any` 类型

#### 场景列表

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 4.6-UNIT-001 | Unit | P0 | 错误处理工具函数类型正确性 | 核心错误处理逻辑，使用频繁 |
| 4.6-INT-001 | Integration | P0 | Chat Query API 错误处理类型安全 | 关键路径 API，高频使用 |
| 4.6-INT-002 | Integration | P0 | Conversations API 错误处理类型安全 | 关键路径 API，高频使用 |
| 4.6-INT-003 | Integration | P1 | API Response 格式一致性 | 确保所有 API 响应统一 |

---

### AC2: 消除关键路径Hooks中的 `any` 类型

#### 场景列表

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 4.6-UNIT-002 | Unit | P0 | useChat Hook 类型安全 | 核心 Hook，错误处理类型正确 |
| 4.6-UNIT-003 | Unit | P0 | useConversations Hook 类型安全 | 核心 Hook，数据类型正确 |
| 4.6-INT-004 | Integration | P1 | Hooks 与 API 集成类型一致性 | 确保端到端类型安全 |

---

### AC3: 创建通用类型定义文件

#### 场景列表

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 4.6-UNIT-004 | Unit | P0 | 错误类型守卫函数正确性 | 核心类型守卫，广泛使用 |
| 4.6-UNIT-005 | Unit | P1 | API 响应类型守卫正确性 | API 响应类型验证 |
| 4.6-UNIT-006 | Unit | P2 | 事件类型别名正确性 | React 事件类型定义 |

---

### AC4: 使用 `unknown` 替代 `any`

#### 场景列表

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 4.6-INT-005 | Integration | P1 | 运行时类型守卫有效性 | 确保类型安全在运行时保持 |
| 4.6-INT-006 | Integration | P1 | 边界情况错误处理 | 验证各种错误类型的处理 |

---

### AC5: 添加类型测试

#### 场景列表

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 4.6-UNIT-007 | Unit | P1 | TypeScript 编译通过 | 编译时类型检查 |
| 4.6-INT-007 | Integration | P2 | CI 类型检查流程 | 持续集成中的类型验证 |

---

### AC6: Linter 规则强化

#### 场景列表

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 4.6-UNIT-008 | Unit | P1 | ESLint 规则验证 | 确保规则正确配置 |
| 4.6-E2E-001 | E2E | P2 | P0 文件 Lint 检查通过 | 验证核心文件无 any |

---

### AC7: 所有现有测试仍然通过

#### 场景列表

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 4.6-INT-008 | Integration | P0 | 现有单元测试回归 | 确保类型重构不破坏功能 |
| 4.6-E2E-002 | E2E | P1 | 关键用户流程回归测试 | 端到端功能验证 |
| 4.6-E2E-003 | E2E | P2 | 测试覆盖率未降低 | 质量指标验证 |

---

## 详细测试场景

### 4.6-UNIT-001: 错误处理工具函数类型正确性

**Level**: Unit  
**Priority**: P0  
**Requirement**: AC1, AC3  
**Justification**: 错误处理是所有 API 的核心逻辑，必须确保类型安全

**Test Scenarios**:

1. **isErrorWithMessage 类型守卫**
   ```typescript
   describe('isErrorWithMessage', () => {
     it('应该正确识别带 message 的错误', () => {
       const error = { message: 'test error' }
       expect(isErrorWithMessage(error)).toBe(true)
     })
     
     it('应该拒绝不带 message 的对象', () => {
       const error = { code: 'ERR' }
       expect(isErrorWithMessage(error)).toBe(false)
     })
     
     it('应该处理 null 和 undefined', () => {
       expect(isErrorWithMessage(null)).toBe(false)
       expect(isErrorWithMessage(undefined)).toBe(false)
     })
   })
   ```

2. **toErrorWithMessage 转换函数**
   ```typescript
   describe('toErrorWithMessage', () => {
     it('应该保持已有 message 的错误', () => {
       const error = { message: 'original' }
       expect(toErrorWithMessage(error).message).toBe('original')
     })
     
     it('应该序列化非错误对象', () => {
       const obj = { code: 404 }
       const result = toErrorWithMessage(obj)
       expect(result.message).toContain('404')
     })
     
     it('应该处理循环引用', () => {
       const circular: any = { a: 1 }
       circular.self = circular
       expect(() => toErrorWithMessage(circular)).not.toThrow()
     })
   })
   ```

3. **getErrorMessage 便捷函数**
   ```typescript
   describe('getErrorMessage', () => {
     it('应该从 Error 对象提取消息', () => {
       const error = new Error('test')
       expect(getErrorMessage(error)).toBe('test')
     })
     
     it('应该处理字符串', () => {
       expect(getErrorMessage('simple error')).toBe('simple error')
     })
   })
   ```

**Expected Results**:
- 所有类型守卫正确工作
- 边界情况处理正确
- 无运行时错误

---

### 4.6-INT-001: Chat Query API 错误处理类型安全

**Level**: Integration  
**Priority**: P0  
**Requirement**: AC1, AC4  
**Justification**: Chat Query 是最关键的 API 端点，错误处理必须健壮

**Test Scenarios**:

1. **未知错误类型处理**
   - 模拟各种异常类型（Error, string, object, null）
   - 验证 API 始终返回有效响应
   - 检查错误消息格式正确

2. **检索错误处理**
   - 测试 `QueryVectorizationError` 各种错误码
   - 测试 `RetrievalError` 各种错误码
   - 验证对应的 HTTP 状态码正确

3. **流式响应错误处理**
   - 生成过程中出现错误
   - 验证错误消息正确发送到流
   - 确保流正确关闭

**Test Code Example**:
```typescript
describe('POST /api/chat/query - Error Handling', () => {
  it('应该安全处理未知错误类型', async () => {
    // Mock service 抛出非标准错误
    vi.spyOn(retrievalService, 'retrieveContext')
      .mockRejectedValue({ unexpected: 'error' })
    
    const response = await POST(mockRequest, { params: {} })
    const data = await response.json()
    
    expect(response.status).toBe(500)
    expect(data.error).toBeTruthy()
    expect(typeof data.error).toBe('string')
  })
  
  it('应该正确处理 QueryVectorizationError', async () => {
    const error = new QueryVectorizationError('Timeout', 'EMBEDDING_TIMEOUT')
    vi.spyOn(retrievalService, 'retrieveContext').mockRejectedValue(error)
    
    const response = await POST(mockRequest, { params: {} })
    
    expect(response.status).toBe(504)
    expect(data.error).toContain('超时')
  })
})
```

**Expected Results**:
- 所有错误情况返回有效响应
- HTTP 状态码正确映射
- 无 TypeScript 类型错误

---

### 4.6-INT-002: Conversations API 错误处理类型安全

**Level**: Integration  
**Priority**: P0  
**Requirement**: AC1, AC4  
**Justification**: Conversations API 处理用户数据，错误处理必须安全

**Test Scenarios**:

1. **GET /api/conversations/:id 错误处理**
   - 对话不存在
   - 无权访问
   - 数据库错误

2. **DELETE /api/conversations/:id 错误处理**
   - 对话不存在
   - 级联删除错误

3. **Export 相关错误处理**
   - Citations 类型处理
   - 导出格式错误

**Test Code Example**:
```typescript
describe('GET /api/conversations/:id - Type Safety', () => {
  it('应该安全处理数据库查询错误', async () => {
    vi.spyOn(db, 'select').mockRejectedValue(new Error('DB Error'))
    
    const response = await GET(mockRequest, { params: { id: 'test-id' } })
    const data = await response.json()
    
    expect(response.status).toBe(500)
    expect(data.error).toBe('获取对话详情失败')
    expect(data.details).toBeUndefined() // 生产环境不泄露细节
  })
  
  it('应该正确处理 citations 为 unknown 的情况', async () => {
    const mockMessage = { citations: { invalid: 'data' } }
    // 验证运行时类型守卫工作
    expect(Array.isArray(mockMessage.citations)).toBe(false)
  })
})
```

**Expected Results**:
- 所有错误情况处理正确
- 敏感信息不泄露
- Citations 类型安全处理

---

### 4.6-UNIT-002: useChat Hook 类型安全

**Level**: Unit  
**Priority**: P0  
**Requirement**: AC2, AC4  
**Justification**: useChat 是前端核心 Hook，类型安全直接影响用户体验

**Test Scenarios**:

1. **错误状态类型正确**
   ```typescript
   it('应该正确处理各种 API 错误', async () => {
     const { result } = renderHook(() => useChat('doc-id'))
     
     // Mock API 错误
     fetch.mockRejectOnce(new Error('Network error'))
     
     await act(async () => {
       await result.current.sendMessage('test')
     })
     
     expect(result.current.error).toBeTypeOf('string')
     expect(result.current.error).not.toBeNull()
   })
   ```

2. **消息状态类型正确**
   ```typescript
   it('消息状态应该有明确的类型', () => {
     const { result } = renderHook(() => useChat('doc-id'))
     
     // 发送消息后检查状态
     act(() => {
       result.current.sendMessage('test')
     })
     
     const lastMessage = result.current.messages[result.current.messages.length - 1]
     expect(lastMessage.status).toMatch(/^(pending|success|error)$/)
   })
   ```

**Expected Results**:
- 所有状态类型明确
- 无 `any` 类型泄露
- TypeScript 编译通过

---

### 4.6-UNIT-003: useConversations Hook 类型安全

**Level**: Unit  
**Priority**: P0  
**Requirement**: AC2, AC4  
**Justification**: useConversations 管理对话列表，类型安全确保数据完整性

**Test Scenarios**:

1. **对话数据类型正确**
   ```typescript
   it('应该返回正确类型的对话列表', async () => {
     const mockConversations = [
       { id: '1', title: 'Test', documentId: 'doc-1', ... }
     ]
     
     fetch.mockResponseOnce(JSON.stringify({ conversations: mockConversations }))
     
     const { result, waitForNextUpdate } = renderHook(() => useConversations())
     await waitForNextUpdate()
     
     expect(result.current.conversations).toHaveLength(1)
     expect(result.current.conversations[0]).toMatchObject({
       id: expect.any(String),
       title: expect.any(String),
       documentId: expect.any(String)
     })
   })
   ```

2. **Citations 类型处理**
   ```typescript
   it('应该安全处理 citations 为 unknown', async () => {
     const mockMessage = {
       id: '1',
       citations: { invalid: 'data' } // unknown 类型
     }
     
     // 应该不抛出类型错误
     expect(() => {
       const citations: unknown = mockMessage.citations
       if (Array.isArray(citations)) {
         // 处理数组情况
       }
     }).not.toThrow()
   })
   ```

3. **错误处理类型正确**
   ```typescript
   it('应该正确类型化删除对话的错误', async () => {
     fetch.mockRejectOnce(new Error('Delete failed'))
     
     await expect(deleteConversation('conv-id'))
       .rejects
       .toThrow('Delete failed')
   })
   ```

**Expected Results**:
- 所有数据类型正确
- Citations 类型安全
- 错误处理类型明确

---

### 4.6-INT-003: API Response 格式一致性

**Level**: Integration  
**Priority**: P1  
**Requirement**: AC1, AC3  
**Justification**: 统一的 API 响应格式提高可维护性和类型安全

**Test Scenarios**:

1. **所有 API 使用 ApiResponse 格式**
   - 遍历所有 API 端点
   - 验证响应格式符合 `ApiResponse<T>` 接口
   - 检查成功和失败响应格式一致

2. **类型守卫正确工作**
   ```typescript
   it('isSuccessResponse 应该正确识别成功响应', () => {
     const response: ApiResponse<{ data: string }> = {
       success: true,
       data: { data: 'test' }
     }
     
     if (isSuccessResponse(response)) {
       // TypeScript 应该知道 data 必定存在
       expect(response.data).toBeDefined()
     }
   })
   
   it('isErrorResponse 应该正确识别错误响应', () => {
     const response: ApiResponse<any> = {
       success: false,
       error: { error: 'Test error' }
     }
     
     if (isErrorResponse(response)) {
       // TypeScript 应该知道 error 必定存在
       expect(response.error.error).toBe('Test error')
     }
   })
   ```

**Expected Results**:
- 所有 API 响应格式一致
- 类型守卫正确工作
- 客户端能正确解析响应

---

### 4.6-INT-004: Hooks 与 API 集成类型一致性

**Level**: Integration  
**Priority**: P1  
**Requirement**: AC2, AC4  
**Justification**: 确保前后端类型一致，避免运行时错误

**Test Scenarios**:

1. **useChat 与 Chat Query API 类型匹配**
   - 验证请求 body 类型一致
   - 验证响应处理类型安全
   - 测试流式响应类型

2. **useConversations 与 Conversations API 类型匹配**
   - 验证对话列表类型一致
   - 验证消息类型一致
   - 测试分页响应类型

**Expected Results**:
- 前后端类型完全匹配
- 无类型断言或 `as any`
- TypeScript 编译无错误

---

### 4.6-INT-005: 运行时类型守卫有效性

**Level**: Integration  
**Priority**: P1  
**Requirement**: AC4  
**Justification**: 确保 `unknown` 替代 `any` 后运行时安全性

**Test Scenarios**:

1. **各种错误类型的守卫测试**
   - Error 对象
   - 字符串错误
   - 数字错误
   - 对象错误
   - null/undefined

2. **类型守卫性能测试**
   - 高频调用下的性能
   - 确保无明显开销

**Expected Results**:
- 所有类型正确识别
- 性能影响可忽略
- 无运行时错误

---

### 4.6-UNIT-004: 错误类型守卫函数正确性

**Level**: Unit  
**Priority**: P0  
**Requirement**: AC3  
**Justification**: 类型守卫是类型安全的核心，必须完全正确

详见 4.6-UNIT-001 的测试场景

---

### 4.6-UNIT-005: API 响应类型守卫正确性

**Level**: Unit  
**Priority**: P1  
**Requirement**: AC3  
**Justification**: API 响应类型守卫确保客户端类型安全

详见 4.6-INT-003 的测试场景

---

### 4.6-E2E-001: P0 文件 Lint 检查通过

**Level**: E2E  
**Priority**: P2  
**Requirement**: AC6  
**Justification**: 验证 ESLint 规则在 P0 文件中生效

**Test Scenarios**:

```bash
# 检查 P0 API Routes
npm run lint -- src/app/api/chat/query/route.ts
npm run lint -- src/app/api/conversations/[id]/route.ts
npm run lint -- src/app/api/conversations/route.ts

# 检查 P0 Hooks
npm run lint -- src/hooks/useChat.ts
npm run lint -- src/hooks/useConversations.ts

# 应该 0 errors, 0 warnings 关于 any 类型
```

**Expected Results**:
- P0 文件 0 个 `any` 类型错误
- ESLint 规则正确执行

---

### 4.6-E2E-002: 关键用户流程回归测试

**Level**: E2E  
**Priority**: P1  
**Requirement**: AC7  
**Justification**: 确保类型重构不破坏核心功能

**Test Scenarios**:

1. **完整的问答流程**
   - 用户登录
   - 选择文档
   - 提交问题
   - 查看流式回答
   - 验证对话保存

2. **对话管理流程**
   - 查看对话列表
   - 加载历史对话
   - 继续对话
   - 删除对话
   - 导出对话

3. **错误场景**
   - 无效输入处理
   - 网络错误恢复
   - 权限错误处理

**Expected Results**:
- 所有关键流程正常工作
- 错误处理友好
- 用户体验无降级

---

## 推荐执行顺序

### Phase 1: P0 单元测试（快速反馈）
1. 4.6-UNIT-001: 错误处理工具函数
2. 4.6-UNIT-004: 错误类型守卫
3. 4.6-UNIT-002: useChat Hook
4. 4.6-UNIT-003: useConversations Hook

### Phase 2: P0 集成测试
1. 4.6-INT-001: Chat Query API
2. 4.6-INT-002: Conversations API
3. 4.6-INT-008: 现有单元测试回归

### Phase 3: P1 测试
1. 4.6-INT-003: API Response 格式一致性
2. 4.6-INT-004: Hooks 与 API 集成
3. 4.6-INT-005: 运行时类型守卫
4. 4.6-E2E-002: 关键用户流程回归

### Phase 4: P2 测试
1. 4.6-E2E-001: P0 文件 Lint 检查
2. 4.6-E2E-003: 测试覆盖率验证

---

## 质量指标

### 测试覆盖率目标
- 新增类型工具函数: **100%**
- API Routes 错误处理: **95%+**
- Hooks 错误处理: **90%+**
- 整体覆盖率: **保持 ≥ 当前水平**

### 性能目标
- 类型守卫调用开销: **< 1ms**
- API 响应时间变化: **< 5%**
- 前端 Hook 性能: **无明显变化**

### 类型安全指标
- P0 文件 `any` 类型: **0 个**
- TypeScript 编译错误: **0 个 (生产代码)**
- ESLint `any` 错误: **0 个 (P0 文件)**

---

## 风险覆盖矩阵

| 风险ID | 测试场景 | 覆盖状态 |
|--------|---------|---------|
| TECH-001 | 4.6-INT-008 | ✅ 部分覆盖（测试文件重构需单独 Story） |
| TECH-002 | 4.6-E2E-001 | ✅ 已覆盖（识别 P1/P2 文件） |
| DATA-001 | 4.6-UNIT-007 | ✅ 已覆盖（类型检查） |
| PERF-001 | 4.6-INT-005 | ✅ 已覆盖（性能测试） |
| OPS-001 | 4.6-UNIT-008 | ✅ 已覆盖（ESLint 验证） |
| BUS-001 | 4.6-INT-004 | ✅ 已覆盖（集成测试） |
| SEC-001 | 4.6-INT-002 | ✅ 已覆盖（敏感信息检查） |
| TECH-003 | 4.6-UNIT-003 | ✅ 已覆盖（Citations 类型） |

---

## 测试环境需求

### 单元测试
- Jest 配置正确
- TypeScript 支持
- Mock 库（Vitest 或 Jest mock）

### 集成测试
- 测试数据库（与生产隔离）
- Mock 第三方服务（LLM, Redis）
- 认证 Mock

### E2E 测试
- 完整的测试环境
- 真实数据库（测试专用）
- 监控工具集成

---

## 关键原则

1. **Shift Left**: 优先单元测试，快速反馈
2. **Risk-Based**: 高风险场景优先测试
3. **Efficient Coverage**: 在合适的层级测试（避免重复）
4. **Maintainability**: 测试代码也要类型安全
5. **Fast Feedback**: P0 测试必须快速执行

---

## 后续改进建议

### Phase 2 (Story 4.7): 非 P0 文件类型安全
- 重构 Services 和 Components 中的 `any`
- 完善所有类型定义
- 建立类型安全最佳实践文档

### Phase 3: 测试文件类型重构
- 为所有测试文件添加类型定义
- 创建类型化的测试工具函数
- Mock 对象类型化

### Phase 4: 自动化类型检查
- CI 中强制 `type-check` 通过
- Pre-commit Hook 添加类型检查
- 定期类型债务审查
