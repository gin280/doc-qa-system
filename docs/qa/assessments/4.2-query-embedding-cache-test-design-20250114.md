# 测试设计: Story 4.2 - Query Embedding 缓存

**日期**: 2025-01-14  
**设计人**: Quinn (Test Architect)  
**Story**: 4.2 - 实现 Query Embedding 缓存

---

## 📊 测试策略概览

### 测试场景统计

- **测试场景总数**: 28
- **单元测试**: 17 (60.7%)
- **集成测试**: 8 (28.6%)
- **性能测试**: 3 (10.7%)
- **优先级分布**: P0: 13, P1: 10, P2: 5

### 测试层级策略

```
┌─────────────────────────────────────────────────┐
│  单元测试 (17个)                                 │
│  - EmbeddingCache核心逻辑                        │
│  - 缓存键生成和归一化                             │
│  - 错误处理和降级                                 │
│  - 指标收集                                      │
└─────────────────────────────────────────────────┘
          │
          ▼
┌─────────────────────────────────────────────────┐
│  集成测试 (8个)                                  │
│  - QueryVectorizer + EmbeddingCache             │
│  - Redis真实交互                                 │
│  - 完整缓存流程                                  │
└─────────────────────────────────────────────────┘
          │
          ▼
┌─────────────────────────────────────────────────┐
│  性能测试 (3个)                                  │
│  - 缓存命中率验证                                 │
│  - 延迟和吞吐量                                  │
│  - 性能提升验证                                  │
└─────────────────────────────────────────────────┘
```

---

## 🎯 按验收标准的测试场景

### AC1: Redis缓存实现

**验收标准**:
- [x] 使用Upstash Redis缓存query embedding
- [x] 缓存键格式: `qv:{provider}:{hash(query)}`
- [x] Hash算法使用MD5,查询归一化(trim + toLowerCase + 多空格归一)
- [x] 缓存TTL: 3600秒(1小时)
- [x] 缓存失败不影响主流程(降级到API调用)

#### 测试场景

| ID | Level | Priority | 测试场景 | 验证内容 | 风险覆盖 |
|----|-------|----------|---------|---------|---------|
| **4.2-UNIT-001** | Unit | P0 | 缓存键生成正确性 | 验证格式`qv:zhipu:{md5}` | TECH-001 |
| **4.2-UNIT-002** | Unit | P0 | 查询归一化-基础 | trim + toLowerCase正确 | TECH-001 |
| **4.2-UNIT-003** | Unit | P0 | 查询归一化-空格 | 多空格归一化为单空格 | TECH-001 |
| **4.2-UNIT-004** | Unit | P1 | 查询归一化-标点 | 中英文标点处理 | TECH-001 |
| **4.2-UNIT-005** | Unit | P0 | 相同查询生成相同hash | 多次调用结果一致 | TECH-002 |
| **4.2-UNIT-006** | Unit | P0 | 不同查询生成不同hash | 碰撞概率极低 | TECH-002 |
| **4.2-UNIT-007** | Unit | P0 | Redis setex调用正确 | TTL=3600,值序列化正确 | - |
| **4.2-UNIT-008** | Unit | P0 | 缓存失败不抛异常 | Redis错误时返回null | OPS-001 |
| **4.2-INT-001** | Integration | P0 | Redis读写完整流程 | 写入后可正确读取 | - |
| **4.2-INT-002** | Integration | P1 | TTL过期验证 | 1小时后缓存自动过期 | - |

**覆盖率**: 10/10 测试场景 ✅

---

### AC2: 缓存命中时直接使用缓存向量

**验收标准**:
- [x] 缓存命中时返回缓存的向量
- [x] 缓存命中延迟 < 10ms
- [x] 缓存未命中时调用LLM API
- [x] API调用后异步写入缓存(不阻塞响应)

#### 测试场景

| ID | Level | Priority | 测试场景 | 验证内容 | 风险覆盖 |
|----|-------|----------|---------|---------|---------|
| **4.2-UNIT-009** | Unit | P0 | 缓存命中返回向量 | get()返回缓存的number[] | - |
| **4.2-UNIT-010** | Unit | P0 | 缓存未命中返回null | Redis无数据时返回null | - |
| **4.2-UNIT-011** | Unit | P0 | 异步写入不阻塞 | set()立即返回Promise | PERF-003 |
| **4.2-INT-003** | Integration | P0 | 首次查询走API | 缓存未命中,调用LLM | - |
| **4.2-INT-004** | Integration | P0 | 二次查询走缓存 | 缓存命中,不调用LLM | - |
| **4.2-INT-005** | Integration | P0 | 向量一致性验证 | 两次返回相同向量 | DATA-001 |
| **4.2-PERF-001** | Performance | P0 | 缓存命中延迟测试 | P95延迟<10ms | PERF-002 |

**覆盖率**: 7/7 测试场景 ✅

---

### AC3: 性能目标达成

**验收标准**:
- [x] 查询响应时间平均 < 250ms(从~600ms,提升60%+)
- [x] 缓存命中率 > 60%(真实流量评估)
- [x] P95延迟 < 400ms
- [x] 单次缓存查询延迟 < 10ms

#### 测试场景

| ID | Level | Priority | 测试场景 | 验证内容 | 风险覆盖 |
|----|-------|----------|---------|---------|---------|
| **4.2-PERF-002** | Performance | P0 | 缓存命中率测试 | 真实查询分布,命中率>60% | PERF-001 |
| **4.2-PERF-003** | Performance | P1 | 性能提升验证 | 对比缓存前后响应时间 | PERF-001 |
| **4.2-INT-006** | Integration | P1 | P95延迟验证 | 100次查询P95<400ms | PERF-002 |

**覆盖率**: 3/3 测试场景 ✅

---

### AC4: 监控和可观测性

**验收标准**:
- [x] 记录缓存命中/未命中指标
- [x] 开发环境输出缓存状态日志
- [x] 实现`embeddingCache.getStats()`返回统计信息
- [x] 统计信息包含:hits, misses, hitRate, redisKeys, estimatedMemory

#### 测试场景

| ID | Level | Priority | 测试场景 | 验证内容 | 风险覆盖 |
|----|-------|----------|---------|---------|---------|
| **4.2-UNIT-012** | Unit | P1 | metrics命中计数 | recordHit()增加hits | - |
| **4.2-UNIT-013** | Unit | P1 | metrics未命中计数 | recordMiss()增加misses | - |
| **4.2-UNIT-014** | Unit | P1 | hitRate计算正确 | hits/(hits+misses) | - |
| **4.2-UNIT-015** | Unit | P1 | getStats()返回完整 | 包含所有必需字段 | - |
| **4.2-UNIT-016** | Unit | P2 | Redis keys查询 | 正确查询qv:*键数量 | - |
| **4.2-UNIT-017** | Unit | P2 | 内存估算准确 | ~4.2KB × keys | TECH-003 |
| **4.2-INT-007** | Integration | P2 | 日志输出验证 | 开发环境正确输出日志 | - |

**覆盖率**: 7/7 测试场景 ✅

---

### AC5: 测试覆盖

**验收标准**:
- [x] 单元测试覆盖embeddingCache服务(>=90%)
- [x] 集成测试验证完整缓存流程
- [x] 性能测试验证目标达成
- [x] 归一化查询测试(多空格、大小写、标点)

#### 测试场景

| ID | Level | Priority | 测试场景 | 验证内容 | 风险覆盖 |
|----|-------|----------|---------|---------|---------|
| **4.2-INT-008** | Integration | P1 | 归一化查询命中缓存 | 多种形式相同查询 | TECH-001 |

**注意**: 测试覆盖本身是元需求,主要通过上述具体测试场景实现。

**覆盖率**: 通过所有其他AC的测试实现 ✅

---

## 🛡️ 风险覆盖矩阵

基于风险评估报告,测试场景覆盖所有识别的风险:

| 风险ID | 风险描述 | 覆盖测试场景 | 缓解验证 |
|--------|---------|-------------|---------|
| **TECH-001** | 查询归一化策略不当 | 4.2-UNIT-002~006, 4.2-INT-008 | ✅ 全面测试 |
| **TECH-002** | MD5哈希碰撞 | 4.2-UNIT-005, 4.2-UNIT-006 | ✅ 验证唯一性 |
| **TECH-003** | 内存压力 | 4.2-UNIT-017 | ✅ 监控内存 |
| **PERF-001** | 命中率<60% | 4.2-PERF-002 | ✅ 验证目标 |
| **PERF-002** | Redis延迟>10ms | 4.2-PERF-001, 4.2-INT-006 | ✅ 验证延迟 |
| **PERF-003** | 异步写入阻塞 | 4.2-UNIT-011 | ✅ 验证异步 |
| **DATA-001** | 缓存数据损坏 | 4.2-INT-005 + 新增完整性测试 | ⚠️ 需补充 |
| **OPS-001** | Redis不可用 | 4.2-UNIT-008 + 新增降级测试 | ⚠️ 需补充 |

### 需要补充的测试场景

#### 数据完整性测试 (DATA-001)

| ID | Level | Priority | 测试场景 | 验证内容 |
|----|-------|----------|---------|---------|
| **4.2-UNIT-018** | Unit | P0 | 拒绝错误类型数据 | string被拒绝返回null |
| **4.2-UNIT-019** | Unit | P0 | 拒绝错误维度向量 | 512维被拒绝 |
| **4.2-UNIT-020** | Unit | P0 | 拒绝NaN/Infinity值 | 异常值被拒绝 |

#### 降级测试 (OPS-001)

| ID | Level | Priority | 测试场景 | 验证内容 |
|----|-------|----------|---------|---------|
| **4.2-INT-009** | Integration | P0 | Redis不可用降级 | 系统仍正常工作 |
| **4.2-INT-010** | Integration | P1 | Redis超时降级 | 超时后走API调用 |

**更新后总计**: 28 + 5 = **33个测试场景**

---

## 📋 详细测试规格

### 单元测试详细规格 (17 → 20个)

#### 缓存键生成测试组

```typescript
// 4.2-UNIT-001: 缓存键生成正确性
describe('generateCacheKey', () => {
  it('应该生成正确格式的缓存键', () => {
    const key = embeddingCache['generateCacheKey']('什么是AI?')
    expect(key).toMatch(/^qv:zhipu:[a-f0-9]{32}$/)
  })
})

// 4.2-UNIT-002: 查询归一化-基础
it('应该trim和toLowerCase', () => {
  const key1 = embeddingCache['generateCacheKey']('  什么是AI?  ')
  const key2 = embeddingCache['generateCacheKey']('什么是ai?')
  expect(key1).toBe(key2)
})

// 4.2-UNIT-003: 查询归一化-空格
it('应该归一化多空格', () => {
  const key1 = embeddingCache['generateCacheKey']('什么是  AI   ?')
  const key2 = embeddingCache['generateCacheKey']('什么是 ai ?')
  expect(key1).toBe(key2)
})

// 4.2-UNIT-004: 查询归一化-标点
it('应该处理中英文标点', () => {
  const queries = [
    '什么是AI?',
    '什么是AI？',  // 中文问号
    '什么是AI！',  // 中文感叹号
    '什么是AI。'   // 中文句号
  ]
  
  const keys = queries.map(q => 
    embeddingCache['generateCacheKey'](q)
  )
  
  // 所有变体应生成相同或相似的key (取决于归一化策略)
  // 当前策略: 保留标点,未来可优化
})

// 4.2-UNIT-005: 相同查询生成相同hash
it('应该保证幂等性', () => {
  const query = '什么是人工智能?'
  const key1 = embeddingCache['generateCacheKey'](query)
  const key2 = embeddingCache['generateCacheKey'](query)
  expect(key1).toBe(key2)
})

// 4.2-UNIT-006: 不同查询生成不同hash
it('应该区分不同查询', () => {
  const key1 = embeddingCache['generateCacheKey']('什么是AI?')
  const key2 = embeddingCache['generateCacheKey']('什么是ML?')
  expect(key1).not.toBe(key2)
})
```

#### Redis操作测试组

```typescript
// 4.2-UNIT-007: Redis setex调用正确
it('应该正确调用setex设置TTL', async () => {
  const query = '测试查询'
  const vector = new Array(1024).fill(0.1)
  
  await embeddingCache.set(query, vector)
  
  expect(mockRedis.setex).toHaveBeenCalledWith(
    expect.stringMatching(/^qv:zhipu:/),
    3600,  // TTL 1小时
    JSON.stringify(vector)
  )
})

// 4.2-UNIT-008: 缓存失败不抛异常
it('Redis错误时不应抛异常', async () => {
  mockRedis.get.mockRejectedValue(new Error('Redis connection failed'))
  
  const result = await embeddingCache.get('query')
  
  expect(result).toBeNull()
  // 不应抛异常
})

// 4.2-UNIT-009: 缓存命中返回向量
it('应该返回缓存的向量', async () => {
  const vector = new Array(1024).fill(0.5)
  mockRedis.get.mockResolvedValue(vector)
  
  const result = await embeddingCache.get('query')
  
  expect(result).toEqual(vector)
})

// 4.2-UNIT-010: 缓存未命中返回null
it('缓存不存在时应返回null', async () => {
  mockRedis.get.mockResolvedValue(null)
  
  const result = await embeddingCache.get('new query')
  
  expect(result).toBeNull()
})

// 4.2-UNIT-011: 异步写入不阻塞
it('set()应该异步执行', async () => {
  const slowSetex = jest.fn().mockImplementation(
    () => new Promise(resolve => setTimeout(resolve, 100))
  )
  mockRedis.setex = slowSetex
  
  const start = Date.now()
  const promise = embeddingCache.set('query', [1, 2, 3])
  const immediate = Date.now() - start
  
  expect(immediate).toBeLessThan(10)  // 应立即返回
  
  await promise  // 等待完成
  expect(slowSetex).toHaveBeenCalled()
})
```

#### 指标监控测试组

```typescript
// 4.2-UNIT-012: metrics命中计数
it('应该记录缓存命中', async () => {
  mockRedis.get.mockResolvedValue([1, 2, 3])
  
  await embeddingCache.get('query')
  
  const stats = await embeddingCache.getStats()
  expect(stats.metrics.hits).toBe(1)
})

// 4.2-UNIT-013: metrics未命中计数
it('应该记录缓存未命中', async () => {
  mockRedis.get.mockResolvedValue(null)
  
  await embeddingCache.get('query')
  
  const stats = await embeddingCache.getStats()
  expect(stats.metrics.misses).toBe(1)
})

// 4.2-UNIT-014: hitRate计算正确
it('应该正确计算命中率', async () => {
  mockRedis.get
    .mockResolvedValueOnce([1, 2, 3])  // hit
    .mockResolvedValueOnce(null)        // miss
    .mockResolvedValueOnce([1, 2, 3])  // hit
  
  await embeddingCache.get('q1')
  await embeddingCache.get('q2')
  await embeddingCache.get('q3')
  
  const stats = await embeddingCache.getStats()
  expect(stats.metrics.hitRate).toBeCloseTo(0.667, 2)  // 2/3
})

// 4.2-UNIT-015: getStats()返回完整
it('应该返回所有统计字段', async () => {
  mockRedis.keys.mockResolvedValue(['key1', 'key2'])
  
  const stats = await embeddingCache.getStats()
  
  expect(stats).toMatchObject({
    enabled: true,
    metrics: {
      hits: expect.any(Number),
      misses: expect.any(Number),
      hitRate: expect.any(Number),
      total: expect.any(Number)
    },
    redisKeys: 2,
    estimatedMemory: expect.any(String)
  })
})

// 4.2-UNIT-016: Redis keys查询
it('应该查询正确的键模式', async () => {
  mockRedis.keys.mockResolvedValue([])
  
  await embeddingCache.getStats()
  
  expect(mockRedis.keys).toHaveBeenCalledWith('qv:zhipu:*')
})

// 4.2-UNIT-017: 内存估算准确
it('应该估算内存占用', async () => {
  mockRedis.keys.mockResolvedValue(
    new Array(1000).fill('key')  // 1000个键
  )
  
  const stats = await embeddingCache.getStats()
  
  // 1000 × 4.2KB = 4.2MB / 1024 = ~4.10 MB
  expect(stats.estimatedMemory).toContain('4.')
  expect(stats.estimatedMemory).toContain('MB')
})
```

#### 数据完整性测试组 (新增)

```typescript
// 4.2-UNIT-018: 拒绝错误类型数据
it('应该拒绝非数组类型缓存', async () => {
  mockRedis.get.mockResolvedValue("invalid string data")
  
  const result = await embeddingCache.get('query')
  
  expect(result).toBeNull()
  expect(mockRedis.del).toHaveBeenCalled()  // 清除损坏数据
})

// 4.2-UNIT-019: 拒绝错误维度向量
it('应该拒绝错误维度的向量', async () => {
  mockRedis.get.mockResolvedValue(new Array(512).fill(0.1))  // 错误维度
  
  const result = await embeddingCache.get('query')
  
  expect(result).toBeNull()
  expect(mockRedis.del).toHaveBeenCalled()
})

// 4.2-UNIT-020: 拒绝NaN/Infinity值
it('应该拒绝包含无效数值的向量', async () => {
  const invalidVector = new Array(1024).fill(0.1)
  invalidVector[500] = NaN
  invalidVector[600] = Infinity
  
  mockRedis.get.mockResolvedValue(invalidVector)
  
  const result = await embeddingCache.get('query')
  
  expect(result).toBeNull()
  expect(mockRedis.del).toHaveBeenCalled()
})
```

---

### 集成测试详细规格 (8 → 10个)

#### 完整缓存流程测试

```typescript
// 4.2-INT-001: Redis读写完整流程
describe('Redis缓存集成', () => {
  it('应该完整测试写入和读取', async () => {
    const query = '什么是人工智能?'
    const vector = new Array(1024).fill(0.5)
    
    // 写入缓存
    await embeddingCache.set(query, vector)
    
    // 读取缓存
    const cached = await embeddingCache.get(query)
    
    expect(cached).toEqual(vector)
  })
})

// 4.2-INT-002: TTL过期验证
it('缓存应在1小时后过期', async () => {
  const query = '测试TTL'
  const vector = new Array(1024).fill(0.1)
  
  await embeddingCache.set(query, vector)
  
  // 立即读取应该存在
  const immediate = await embeddingCache.get(query)
  expect(immediate).toEqual(vector)
  
  // 模拟1小时后 (需要Redis测试环境或mock)
  // 实际测试可能需要缩短TTL或使用Redis EXPIRE命令
  
  // 注意: 这个测试在CI环境可能需要特殊处理
}, 3700000)  // 超过1小时的超时
```

#### QueryVectorizer集成测试

```typescript
// 4.2-INT-003: 首次查询走API
it('缓存未命中时应调用LLM API', async () => {
  const query = '新查询问题'
  
  const spy = jest.spyOn(llmRepo, 'generateEmbeddings')
  
  const vector = await queryVectorizer.vectorizeQuery(query)
  
  expect(spy).toHaveBeenCalledWith([query])
  expect(vector).toHaveLength(1024)
})

// 4.2-INT-004: 二次查询走缓存
it('缓存命中时不应调用LLM API', async () => {
  const query = '相同查询'
  
  // 第一次查询
  await queryVectorizer.vectorizeQuery(query)
  
  // 第二次查询
  const spy = jest.spyOn(llmRepo, 'generateEmbeddings')
  const start = Date.now()
  
  await queryVectorizer.vectorizeQuery(query)
  
  const elapsed = Date.now() - start
  
  expect(spy).not.toHaveBeenCalled()  // 不调用API
  expect(elapsed).toBeLessThan(50)    // 快速返回
})

// 4.2-INT-005: 向量一致性验证
it('两次查询应返回完全相同的向量', async () => {
  const query = '一致性测试'
  
  const vector1 = await queryVectorizer.vectorizeQuery(query)
  const vector2 = await queryVectorizer.vectorizeQuery(query)
  
  expect(vector1).toEqual(vector2)  // 完全相同
  
  // 验证每个元素都相等
  for (let i = 0; i < vector1.length; i++) {
    expect(vector1[i]).toBe(vector2[i])
  }
})

// 4.2-INT-006: P95延迟验证
it('100次查询P95延迟<400ms', async () => {
  const queries = [
    '什么是AI?',
    '机器学习定义',
    '深度学习',
    // ... 更多真实查询
  ]
  
  const latencies: number[] = []
  
  for (let i = 0; i < 100; i++) {
    const query = queries[i % queries.length]
    const start = Date.now()
    
    await queryVectorizer.vectorizeQuery(query)
    
    latencies.push(Date.now() - start)
  }
  
  latencies.sort((a, b) => a - b)
  const p95 = latencies[94]  // 第95个值
  
  console.log(`P95延迟: ${p95}ms`)
  expect(p95).toBeLessThan(400)
})

// 4.2-INT-007: 日志输出验证
it('开发环境应输出缓存日志', async () => {
  const originalEnv = process.env.NODE_ENV
  process.env.NODE_ENV = 'development'
  
  const consoleSpy = jest.spyOn(console, 'log')
  
  const query = '日志测试'
  await queryVectorizer.vectorizeQuery(query)  // miss
  await queryVectorizer.vectorizeQuery(query)  // hit
  
  expect(consoleSpy).toHaveBeenCalledWith(
    expect.stringContaining('[EmbeddingCache] Cache MISS')
  )
  expect(consoleSpy).toHaveBeenCalledWith(
    expect.stringContaining('[EmbeddingCache] Cache HIT')
  )
  
  process.env.NODE_ENV = originalEnv
  consoleSpy.mockRestore()
})

// 4.2-INT-008: 归一化查询命中缓存
it('多种形式的相同查询应命中缓存', async () => {
  const variations = [
    '什么是AI?',
    '什么是AI？',    // 中文标点
    '什么是  AI ?',   // 多空格
    '  什么是 ai ?  ' // 大小写+空格
  ]
  
  // 第一次查询
  await queryVectorizer.vectorizeQuery(variations[0])
  
  // 后续查询应都命中缓存
  for (const query of variations.slice(1)) {
    const start = Date.now()
    await queryVectorizer.vectorizeQuery(query)
    const elapsed = Date.now() - start
    
    expect(elapsed).toBeLessThan(50)  // 缓存命中
  }
})
```

#### 降级测试 (新增)

```typescript
// 4.2-INT-009: Redis不可用降级
it('Redis不可用时系统应正常工作', async () => {
  // 模拟Redis完全不可用
  const cacheWithoutRedis = new EmbeddingCacheService()
  cacheWithoutRedis['redis'] = null
  
  const query = '降级测试'
  
  // get应返回null不抛异常
  const cached = await cacheWithoutRedis.get(query)
  expect(cached).toBeNull()
  
  // set应静默失败不抛异常
  await expect(
    cacheWithoutRedis.set(query, [1, 2, 3])
  ).resolves.not.toThrow()
  
  // 验证queryVectorizer仍然工作
  const vector = await queryVectorizer.vectorizeQuery(query)
  expect(vector).toHaveLength(1024)
})

// 4.2-INT-010: Redis超时降级
it('Redis超时时应降级到API', async () => {
  // 模拟Redis超时
  mockRedis.get.mockImplementation(
    () => new Promise((_, reject) => 
      setTimeout(() => reject(new Error('Timeout')), 1000)
    )
  )
  
  const query = '超时测试'
  const vector = await queryVectorizer.vectorizeQuery(query)
  
  expect(vector).toHaveLength(1024)  // 仍返回正确向量
})
```

---

### 性能测试详细规格 (3个)

```typescript
// 4.2-PERF-001: 缓存命中延迟测试
describe('性能测试', () => {
  it('缓存命中P95延迟应<10ms', async () => {
    const query = '性能测试查询'
    
    // 预热缓存
    await queryVectorizer.vectorizeQuery(query)
    
    // 测试100次缓存命中
    const latencies: number[] = []
    
    for (let i = 0; i < 100; i++) {
      const start = performance.now()
      await queryVectorizer.vectorizeQuery(query)
      const elapsed = performance.now() - start
      
      latencies.push(elapsed)
    }
    
    latencies.sort((a, b) => a - b)
    const p50 = latencies[49]
    const p95 = latencies[94]
    const p99 = latencies[98]
    
    console.log(`缓存延迟 - P50: ${p50.toFixed(2)}ms, P95: ${p95.toFixed(2)}ms, P99: ${p99.toFixed(2)}ms`)
    
    expect(p95).toBeLessThan(10)
  })
})

// 4.2-PERF-002: 缓存命中率测试
it('真实查询分布命中率应>60%', async () => {
  // 模拟真实用户查询分布 (幂律分布)
  const queries = [
    // 热门查询 (20%查询占80%流量)
    ...Array(10).fill('什么是AI?'),
    ...Array(8).fill('什么是AI？'),  // 标点变体
    ...Array(7).fill('机器学习定义'),
    ...Array(6).fill('深度学习'),
    
    // 中等查询
    ...Array(3).fill('神经网络'),
    ...Array(3).fill('自然语言处理'),
    
    // 长尾查询 (每个只出现1次)
    'AI应用场景',
    '强化学习',
    '计算机视觉',
    '语音识别',
    '推荐系统',
    // ... 更多
  ]
  
  // 打乱顺序模拟真实访问
  const shuffled = queries.sort(() => Math.random() - 0.5)
  
  let cacheHits = 0
  let cacheMisses = 0
  
  for (const query of shuffled) {
    const start = Date.now()
    await queryVectorizer.vectorizeQuery(query)
    const elapsed = Date.now() - start
    
    if (elapsed < 50) {
      cacheHits++
    } else {
      cacheMisses++
    }
  }
  
  const hitRate = cacheHits / (cacheHits + cacheMisses)
  
  console.log(`缓存命中率: ${(hitRate * 100).toFixed(1)}%`)
  console.log(`命中: ${cacheHits}, 未命中: ${cacheMisses}`)
  
  expect(hitRate).toBeGreaterThan(0.6)  // >60%
})

// 4.2-PERF-003: 性能提升验证
it('应验证性能提升>50%', async () => {
  const testQueries = [
    '什么是AI?',
    '机器学习',
    '深度学习'
  ]
  
  // 测试无缓存场景 (清空缓存)
  await embeddingCache.invalidateProvider('zhipu')
  
  const withoutCacheLatencies: number[] = []
  for (const query of testQueries) {
    const start = Date.now()
    await queryVectorizer.vectorizeQuery(query)
    withoutCacheLatencies.push(Date.now() - start)
  }
  
  // 测试有缓存场景 (重复查询)
  const withCacheLatencies: number[] = []
  for (const query of testQueries) {
    const start = Date.now()
    await queryVectorizer.vectorizeQuery(query)
    withCacheLatencies.push(Date.now() - start)
  }
  
  const avgWithoutCache = withoutCacheLatencies.reduce((a, b) => a + b) / testQueries.length
  const avgWithCache = withCacheLatencies.reduce((a, b) => a + b) / testQueries.length
  
  const improvement = (avgWithoutCache - avgWithCache) / avgWithoutCache
  
  console.log(`无缓存平均: ${avgWithoutCache.toFixed(2)}ms`)
  console.log(`有缓存平均: ${avgWithCache.toFixed(2)}ms`)
  console.log(`性能提升: ${(improvement * 100).toFixed(1)}%`)
  
  expect(improvement).toBeGreaterThan(0.5)  // >50%提升
})
```

---

## 🔍 覆盖率分析

### 按验收标准覆盖

| AC | 描述 | 测试场景数 | P0测试 | 覆盖率 |
|----|------|-----------|--------|--------|
| AC1 | Redis缓存实现 | 10 | 8 | ✅ 100% |
| AC2 | 缓存命中使用 | 7 | 5 | ✅ 100% |
| AC3 | 性能目标 | 3 | 1 | ✅ 100% |
| AC4 | 监控可观测 | 7 | 0 | ✅ 100% |
| AC5 | 测试覆盖 | 6 (间接) | 3 | ✅ 100% |

### 按测试级别覆盖

| 级别 | 场景数 | P0 | P1 | P2 | 代码覆盖目标 |
|------|--------|----|----|----|-----------| 
| Unit | 20 | 11 | 4 | 5 | >=90% |
| Integration | 10 | 6 | 3 | 1 | >=80% |
| Performance | 3 | 1 | 2 | 0 | 性能验证 |
| **总计** | **33** | **18** | **9** | **6** | - |

### 按风险覆盖

| 风险类别 | 风险数 | 测试场景覆盖 | 覆盖率 |
|---------|--------|-------------|--------|
| 性能 (PERF) | 3 | 6个场景 | ✅ 100% |
| 技术 (TECH) | 3 | 8个场景 | ✅ 100% |
| 数据 (DATA) | 1 | 4个场景 | ✅ 100% |
| 运维 (OPS) | 1 | 3个场景 | ✅ 100% |

---

## 📊 推荐执行顺序

### Phase 1: 快速反馈 (P0单元测试)

**执行时间**: ~2分钟  
**目标**: 快速验证核心逻辑正确性

```bash
npm run test:unit -- tests/unit/services/rag/embeddingCache.test.ts
```

**场景**:
1. 4.2-UNIT-001~006 (缓存键生成和归一化)
2. 4.2-UNIT-007~008 (Redis操作)
3. 4.2-UNIT-009~011 (缓存命中/未命中)
4. 4.2-UNIT-018~020 (数据完整性)

**失败即停**: 如果这些测试失败,立即修复后再继续

---

### Phase 2: 集成验证 (P0集成测试)

**执行时间**: ~30秒  
**目标**: 验证组件交互和真实Redis

```bash
npm run test:integration -- tests/integration/rag/embedding-cache.test.ts
```

**场景**:
1. 4.2-INT-001 (Redis读写)
2. 4.2-INT-003~005 (QueryVectorizer集成)
3. 4.2-INT-009 (Redis降级)

---

### Phase 3: 性能验证 (性能测试)

**执行时间**: ~2分钟  
**目标**: 验证性能目标达成

```bash
npm run test:performance -- tests/performance/embedding-cache.perf.ts
```

**场景**:
1. 4.2-PERF-001 (缓存延迟<10ms)
2. 4.2-PERF-002 (命中率>60%)
3. 4.2-PERF-003 (性能提升>50%)

---

### Phase 4: 完整测试 (P1+P2测试)

**执行时间**: ~3分钟  
**目标**: 完整测试覆盖

```bash
npm test
```

**场景**: 所有剩余测试场景

---

## ✅ 质量检查清单

### 测试设计完整性

- [x] 每个AC至少有一个测试场景
- [x] 测试级别分配合理 (60% Unit, 30% Integration, 10% Performance)
- [x] 无重复测试覆盖
- [x] 关键路径有多级测试
- [x] 测试ID遵循命名规范 `{epic}.{story}-{LEVEL}-{SEQ}`
- [x] 场景原子化且独立
- [x] 所有识别风险都有测试覆盖

### 优先级分配

- [x] P0测试覆盖核心功能 (18/33 = 54.5%)
- [x] P1测试覆盖重要场景 (9/33 = 27.3%)
- [x] P2测试覆盖次要功能 (6/33 = 18.2%)
- [x] 优先级与业务风险对齐

### 可执行性

- [x] 所有测试场景都有明确的验证标准
- [x] Mock策略清晰
- [x] 测试数据准备明确
- [x] 执行顺序合理 (快速→慢速)

---

## 📈 成功标准

### 代码覆盖率目标

| 文件 | 目标覆盖率 | 验证方式 |
|------|-----------|---------|
| `embeddingCache.ts` | >=90% | Jest coverage report |
| `queryVectorizer.ts` | >=85% | Jest coverage report |

### 测试通过率目标

- **P0测试**: 100% 通过 (18/18)
- **P1测试**: >=95% 通过 (9/9)
- **P2测试**: >=90% 通过 (6/6)

### 性能验证目标

- ✅ 缓存命中率 >60% (4.2-PERF-002)
- ✅ 缓存延迟P95 <10ms (4.2-PERF-001)
- ✅ 总体性能提升 >50% (4.2-PERF-003)

---

## 🔗 相关文档

- **Story**: `docs/stories/4.2-query-embedding-cache.md`
- **架构设计**: `docs/architecture/query-embedding-cache-design.md`
- **风险评估**: `docs/qa/assessments/4.2-query-embedding-cache-risk-20250114.md`
- **测试策略**: `docs/testing/strategy.md`

---

**测试设计状态**: ✅ **Complete**  
**设计人**: Quinn (Test Architect)  
**下一步**: 由Dev实施测试用例  
**审核**: 待Scrum Master审核

---

## 输出给 trace-requirements 任务的引用

```text
Test design matrix: docs/qa/assessments/4.2-query-embedding-cache-test-design-20250114.md
P0 tests identified: 18
```

