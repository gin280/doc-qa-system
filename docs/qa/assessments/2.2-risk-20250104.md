# Risk Profile: Story 2.2 - 文件存储与元数据管理

**Story ID**: 2.2  
**Story Title**: 文件存储与元数据管理  
**Assessment Date**: 2025-01-04  
**Reviewer**: Quinn (Test Architect)  
**Epic**: 2 - 文档管理与解析

---

## Executive Summary

Story 2.2经过全面风险评估，识别出**16个风险**，其中包括**2个关键风险**(SEC-001, DATA-001)需要在生产部署前强制修复。

### 风险概览

- **Total Risks**: 16
- **Critical**: 2 (SEC-001 Service Role Key泄露, DATA-001 回滚失败)
- **High**: 4 (PERF-001, SEC-002, TECH-001, DATA-002)
- **Medium**: 6
- **Low**: 4
- **Overall Risk Score**: 51/100 (Medium-High)

### 关键风险

1. **SEC-001** (Score: 9): Service Role Key泄露风险 - 需要严格的密钥管理
2. **DATA-001** (Score: 9): 回滚机制失败导致数据不一致 - 需要分布式事务

---

## Risk Distribution

### By Category

| Category | Critical | High | Medium | Low | Total |
|----------|----------|------|--------|-----|-------|
| Security (SEC) | 1 | 1 | 1 | 1 | 4 |
| Technical (TECH) | 0 | 1 | 2 | 1 | 4 |
| Performance (PERF) | 0 | 1 | 2 | 0 | 3 |
| Data (DATA) | 1 | 1 | 1 | 1 | 4 |
| Business (BUS) | 0 | 0 | 0 | 1 | 1 |
| Operational (OPS) | 0 | 0 | 0 | 0 | 0 |

### Risk Score Distribution

```
Score 9 (Critical): ██ 2 risks
Score 6 (High):     ████ 4 risks  
Score 4 (Medium):   ██████ 6 risks
Score 3 (Low):      ████ 4 risks
```

---

## Detailed Risk Register

### Critical Risks (Score 9)

#### SEC-001: Service Role Key泄露风险

**Probability**: Medium (2) - 配置错误或代码审查疏忽  
**Impact**: High (3) - 完全绕过RLS，可访问所有用户数据  
**Risk Score**: **9 (Critical)**

**Description**:  
SUPABASE_SERVICE_ROLE_KEY如果被暴露到客户端代码、Git仓库或环境配置中，攻击者可以绕过所有Row Level Security规则，访问、修改或删除任何用户的文档。

**Affected Components**:
- `lib/supabase.ts` - supabaseAdmin实例
- `services/documents/storageService.ts` - 所有Storage操作
- `.env.local` - 环境变量配置

**Detection Method**:  
代码审查发现Service Role Key可能通过以下方式泄露：
- 打包到客户端bundle
- 提交到Git仓库
- 在日志中输出
- 在错误消息中暴露

**Mitigation Strategy**:

1. **环境变量隔离** (Preventive)
   ```typescript
   // ❌ 错误做法 - 使用NEXT_PUBLIC_前缀
   const key = process.env.NEXT_PUBLIC_SUPABASE_SERVICE_ROLE_KEY
   
   // ✅ 正确做法 - 不使用NEXT_PUBLIC_前缀
   const key = process.env.SUPABASE_SERVICE_ROLE_KEY
   ```

2. **运行时检查** (Detective)
   ```typescript
   // lib/supabase.ts
   if (typeof window !== 'undefined') {
     throw new Error('Service Role Key cannot be used in browser')
   }
   ```

3. **代码审查检查项** (Preventive)
   - [ ] Service Role Key仅在服务端使用
   - [ ] 所有StorageService调用仅在API routes中
   - [ ] 永不在客户端组件中导入StorageService
   - [ ] .env.local已加入.gitignore

4. **密钥轮换策略** (Corrective)
   - 定期轮换Service Role Key(每季度)
   - 泄露响应预案：立即轮换+审计访问日志

**Testing Requirements**:
- ✅ 单元测试: 验证Service Role Key不存在于客户端bundle
- ✅ 集成测试: 尝试在客户端使用StorageService应失败
- ✅ 安全测试: 扫描代码和日志中的密钥暴露

**Residual Risk**: Low - 实施缓解措施后仍可能有人为配置错误

**Owner**: Dev (实施) + QA (验证)  
**Timeline**: Story 2.2开发期间强制修复

---

#### DATA-001: 回滚机制失败导致数据不一致

**Probability**: High (3) - 分布式系统固有问题  
**Impact**: High (3) - Storage和数据库状态不一致  
**Risk Score**: **9 (Critical)**

**Description**:  
当文件上传到Supabase Storage成功，但数据库记录创建失败时，或反之，会导致"孤儿文件"或"幽灵记录"。当前实现的回滚机制依赖try-catch，但无法保证原子性。

**Failure Scenarios**:

1. **场景1: Storage成功，数据库失败**
   ```
   ✅ Storage.upload() → 文件已存储
   ❌ db.insert(documents) → 失败
   ⚠️ 回滚: Storage.deleteFile() → 可能失败(网络超时)
   结果: 孤儿文件残留在Storage中
   ```

2. **场景2: 数据库成功，userUsage更新失败**
   ```
   ✅ db.insert(documents) → 记录已创建
   ❌ db.update(userUsage) → 失败
   结果: 配额统计不准确
   ```

3. **场景3: 删除操作中断**
   ```
   ✅ db.delete(documents) → 记录已删除
   ❌ Storage.deleteFile() → 失败
   结果: 文件残留，用户无法通过UI访问但占用空间
   ```

**Affected Components**:
- `app/api/documents/upload/route.ts` - 上传流程
- `app/api/documents/[id]/route.ts` - 删除流程
- `services/documents/storageService.ts` - Storage操作

**Mitigation Strategy**:

1. **上传流程改进** (Preventive)
   ```typescript
   // 使用数据库事务 + 补偿事务模式
   async function uploadWithCompensation(file: File, userId: string) {
     let storagePath: string | null = null
     let documentId: string | null = null
     
     try {
       // Step 1: 上传到Storage
       storagePath = await StorageService.uploadFile(...)
       
       // Step 2: 使用数据库事务创建记录
       await db.transaction(async (tx) => {
         // 创建document记录
         const [doc] = await tx.insert(documents).values({...}).returning()
         documentId = doc.id
         
         // 原子更新userUsage
         await tx.update(userUsage)
           .set({
             documentCount: sql`${userUsage.documentCount} + 1`,
             storageUsed: sql`${userUsage.storageUsed} + ${file.size}`
           })
           .where(eq(userUsage.userId, userId))
       })
       
       return documentId
       
     } catch (error) {
       // 补偿事务: 清理已完成的操作
       if (storagePath) {
         await safeDeleteFromStorage(storagePath) // 带重试的删除
       }
       throw error
     }
   }
   
   // 安全删除(带重试)
   async function safeDeleteFromStorage(path: string, maxRetries = 3) {
     for (let i = 0; i < maxRetries; i++) {
       try {
         await StorageService.deleteFile(path)
         return
       } catch (error) {
         if (i === maxRetries - 1) {
           // 记录到清理队列供后台任务处理
           await db.insert(orphanFiles).values({ path, createdAt: new Date() })
         }
         await sleep(1000 * Math.pow(2, i))
       }
     }
   }
   ```

2. **删除流程改进** (Preventive)
   ```typescript
   // 使用幂等性删除
   async function deleteDocument(documentId: string) {
     const [doc] = await db.select()
       .from(documents)
       .where(eq(documents.id, documentId))
     
     if (!doc) return { success: true } // 幂等性
     
     // 先从Storage删除(失败不影响数据库)
     try {
       await StorageService.deleteFile(doc.storagePath)
     } catch (error) {
       console.error('Storage delete failed, will cleanup later:', error)
       // 标记为待清理
       await db.update(documents)
         .set({ metadata: { ...doc.metadata, pendingCleanup: true } })
         .where(eq(documents.id, documentId))
     }
     
     // 使用事务删除数据库记录
     await db.transaction(async (tx) => {
       await tx.delete(documents).where(eq(documents.id, documentId))
       await tx.update(userUsage)
         .set({
           documentCount: sql`${userUsage.documentCount} - 1`,
           storageUsed: sql`${userUsage.storageUsed} - ${doc.fileSize}`
         })
         .where(eq(userUsage.userId, doc.userId))
     })
   }
   ```

3. **后台清理任务** (Corrective)
   ```typescript
   // 定期清理孤儿文件(Vercel Cron Job)
   export async function cleanupOrphanFiles() {
     // 查找Storage中的文件
     const storageFiles = await StorageService.listAll()
     
     // 查找数据库中的记录
     const dbPaths = await db.select({ storagePath: documents.storagePath })
       .from(documents)
     
     const dbPathSet = new Set(dbPaths.map(d => d.storagePath))
     
     // 删除孤儿文件
     for (const file of storageFiles) {
       if (!dbPathSet.has(file.name) && isOlderThan(file, 24hours)) {
         await StorageService.deleteFile(file.name)
       }
     }
   }
   ```

4. **监控和告警** (Detective)
   - 监控Storage使用量 vs 数据库记录的总文件大小
   - 差异超过5%时触发告警
   - 定期运行一致性检查脚本

**Testing Requirements**:
- ✅ 集成测试: 模拟Storage失败时的回滚
- ✅ 集成测试: 模拟数据库失败时的回滚
- ✅ 混沌测试: 随机中断上传流程验证一致性
- ✅ 一致性测试: 验证Storage和数据库数据匹配

**Residual Risk**: Medium - 极端情况下仍可能有短暂不一致，但后台任务会修复

**Owner**: Dev (实施) + DevOps (后台任务)  
**Timeline**: Story 2.2完成前强制修复

---

### High Risks (Score 6)

#### PERF-001: 大文件上传超时

**Probability**: Medium (2) - 用户可能上传接近50MB的文件  
**Impact**: High (3) - 用户体验差，上传失败  
**Risk Score**: **6 (High)**

**Description**:  
Vercel Serverless函数默认超时为10秒(Hobby)或60秒(Pro)，但Story 2.2配置了300秒(5分钟)。大文件(40-50MB)在慢速网络下上传可能超时。

**Affected Components**:
- `app/api/documents/upload/route.ts` (maxDuration=300)
- Vercel函数配置
- 用户网络条件

**Mitigation Strategy**:

1. **Vercel配置优化** (Preventive)
   ```json
   // vercel.json
   {
     "functions": {
       "src/app/api/documents/upload/route.ts": {
         "maxDuration": 300,
         "memory": 3008  // 最大内存防止OOM
       }
     }
   }
   ```

2. **分块上传** (Preventive - Phase 2)
   - MVP阶段: 接受5分钟超时，文档限制50MB
   - Phase 2: 实施分块上传(Multipart Upload)
   - 允许暂停/恢复上传

3. **客户端超时配置** (Preventive)
   ```typescript
   // hooks/useDocumentUpload.ts
   const xhr = new XMLHttpRequest()
   xhr.timeout = 5 * 60 * 1000  // 5分钟
   ```

4. **用户提示** (Preventive)
   ```typescript
   // 上传前估算时间
   const estimatedTime = fileSize / (userBandwidth * 0.7) // 70%效率
   if (estimatedTime > 240) {
     toast({
       title: '大文件上传',
       description: '预计需要4-5分钟，请保持网络连接'
     })
   }
   ```

**Testing Requirements**:
- ✅ 性能测试: 50MB文件在慢速网络(1Mbps)下上传
- ✅ 超时测试: 验证300秒超时配置生效
- ✅ 压力测试: 多个大文件并发上传

**Residual Risk**: Low - 配置正确后风险可控

**Owner**: Dev (实施)  
**Timeline**: Task 3实现时配置

---

#### SEC-002: RLS Policy配置错误导致跨用户访问

**Probability**: Medium (2) - RLS规则复杂，易配置错误  
**Impact**: High (3) - 用户可访问他人文档  
**Risk Score**: **6 (High)**

**Description**:  
Supabase RLS policies如果配置错误，可能导致用户能上传到其他用户目录，或读取他人文件。

**Affected Components**:
- Supabase Storage RLS policies
- Storage folder结构: `{userId}/{documentId}_{filename}`

**Potential Misconfigurations**:

1. **错误1: 使用文件名而非目录判断**
   ```sql
   -- ❌ 错误配置
   CREATE POLICY "Users can read own files"
   ON storage.objects FOR SELECT
   USING (
     bucket_id = 'documents'
     AND name LIKE '%' || auth.uid()::text || '%'  -- 可被绕过!
   );
   ```

2. **错误2: 忘记验证bucket**
   ```sql
   -- ❌ 缺少bucket_id检查
   CREATE POLICY "Users can upload"
   ON storage.objects FOR INSERT
   WITH CHECK (
     (storage.foldername(name))[1] = auth.uid()::text  -- 其他bucket也会匹配!
   );
   ```

**Mitigation Strategy**:

1. **正确的RLS配置** (Preventive)
   ```sql
   -- ✅ 正确配置 - 上传
   CREATE POLICY "Users can upload to own folder"
   ON storage.objects FOR INSERT TO authenticated
   WITH CHECK (
     bucket_id = 'documents' 
     AND (storage.foldername(name))[1] = auth.uid()::text
   );
   
   -- ✅ 正确配置 - 读取
   CREATE POLICY "Users can read own files"
   ON storage.objects FOR SELECT TO authenticated
   USING (
     bucket_id = 'documents'
     AND (storage.foldername(name))[1] = auth.uid()::text
   );
   
   -- ✅ 正确配置 - 删除
   CREATE POLICY "Users can delete own files"
   ON storage.objects FOR DELETE TO authenticated
   USING (
     bucket_id = 'documents'
     AND (storage.foldername(name))[1] = auth.uid()::text
   );
   ```

2. **RLS测试套件** (Detective)
   ```typescript
   describe('Supabase RLS Policies', () => {
     it('should prevent user A from uploading to user B folder', async () => {
       const userA = createSupabaseClient(userAToken)
       const result = await userA.storage
         .from('documents')
         .upload('userB-id/malicious.txt', file)
       
       expect(result.error).toBeTruthy()
       expect(result.error.message).toContain('new row violates')
     })
     
     it('should prevent user A from reading user B files', async () => {
       const userA = createSupabaseClient(userAToken)
       const result = await userA.storage
         .from('documents')
         .download('userB-id/doc.pdf')
       
       expect(result.error).toBeTruthy()
     })
   })
   ```

3. **定期审计** (Detective)
   - 每月审计Storage RLS policies
   - 自动化测试跨用户访问
   - 监控异常访问模式

**Testing Requirements**:
- ✅ 安全测试: 尝试上传到其他用户目录
- ✅ 安全测试: 尝试读取其他用户文件
- ✅ 安全测试: 尝试删除其他用户文件
- ✅ 渗透测试: 路径遍历攻击(../../../)

**Residual Risk**: Low - RLS配置正确后风险极低

**Owner**: Dev (实施) + QA (安全测试)  
**Timeline**: Task 1配置Supabase时完成

---

#### TECH-001: Supabase Storage API变更或不稳定

**Probability**: Medium (2) - 第三方服务依赖  
**Impact**: High (3) - 文件上传完全失败  
**Risk Score**: **6 (High)**

**Description**:  
依赖Supabase Storage API，如果API变更、限流或服务不稳定，会导致文件上传失败。

**Affected Components**:
- `services/documents/storageService.ts`
- Supabase Storage SDK

**Mitigation Strategy**:

1. **版本锁定** (Preventive)
   ```json
   // package.json
   {
     "dependencies": {
       "@supabase/supabase-js": "2.39.0"  // 锁定版本
     }
   }
   ```

2. **健康检查** (Detective)
   ```typescript
   // lib/storage-health.ts
   export async function checkStorageHealth() {
     try {
       const testFile = new Blob(['health check'], { type: 'text/plain' })
       const result = await supabaseAdmin.storage
         .from('documents')
         .upload('_health/test.txt', testFile, { upsert: true })
       
       if (result.error) {
         console.error('Storage health check failed:', result.error)
         return false
       }
       
       await supabaseAdmin.storage.from('documents').remove(['_health/test.txt'])
       return true
     } catch (error) {
       return false
     }
   }
   ```

3. **降级策略** (Corrective)
   - 短期: 显示维护提示，禁用上传
   - 中期: 考虑临时存储到本地/其他云存储
   - 长期: 设计抽象层支持多个Storage提供商

4. **错误监控** (Detective)
   ```typescript
   // 集成Sentry监控Storage错误
   if (error && error.message?.includes('supabase')) {
     Sentry.captureException(error, {
       tags: { service: 'supabase-storage' },
       level: 'error'
     })
   }
   ```

**Testing Requirements**:
- ✅ 集成测试: Mock Supabase API错误响应
- ✅ 降级测试: 验证Storage不可用时的用户体验
- ✅ 监控测试: 确认错误被正确上报

**Residual Risk**: Medium - 依赖外部服务固有风险

**Owner**: Dev (实施) + DevOps (监控)  
**Timeline**: Task 2实现时加入健康检查

---

#### DATA-002: userUsage统计不准确

**Probability**: Medium (2) - 并发和错误恢复场景  
**Impact**: High (3) - 配额限制失效或误判  
**Risk Score**: **6 (High)**

**Description**:  
在并发上传、删除操作或错误恢复场景下，userUsage的documentCount和storageUsed可能与实际不一致。

**Scenarios**:

1. **并发上传竞态条件**
   ```
   User上传File A和File B同时进行:
   
   Thread 1: Read usage (documentCount=10) → Upload A → Set count=11
   Thread 2: Read usage (documentCount=10) → Upload B → Set count=11
   
   结果: 应该是12，实际是11
   ```

2. **删除失败但统计已更新**
   ```
   删除文档流程:
   ✅ userUsage.documentCount -= 1
   ❌ Storage.deleteFile() 失败
   
   结果: 统计不匹配实际存储
   ```

**Affected Components**:
- `app/api/documents/upload/route.ts` - userUsage更新
- `app/api/documents/[id]/route.ts` - 删除时的更新
- `drizzle/schema.ts` - userUsage表

**Mitigation Strategy**:

1. **使用SQL原子操作** (Preventive) ✅ 已实现
   ```typescript
   // ✅ Story 2.2已使用SQL原子操作
   await db.update(userUsage)
     .set({
       documentCount: sql`${userUsage.documentCount} + 1`,
       storageUsed: sql`${userUsage.storageUsed} + ${file.size}`
     })
     .where(eq(userUsage.userId, userId))
   ```

2. **定期校准任务** (Corrective)
   ```typescript
   // 每日运行校准任务
   export async function calibrateUserUsage() {
     const users = await db.select().from(users)
     
     for (const user of users) {
       // 计算实际值
       const [actual] = await db.select({
         count: sql<number>`count(*)`,
         size: sql<number>`sum(file_size)`
       })
       .from(documents)
       .where(eq(documents.userId, user.id))
       
       // 对比并修正
       const [current] = await db.select()
         .from(userUsage)
         .where(eq(userUsage.userId, user.id))
       
       if (actual.count !== current.documentCount ||
           actual.size !== current.storageUsed) {
         await db.update(userUsage)
           .set({
             documentCount: actual.count,
             storageUsed: actual.size
           })
           .where(eq(userUsage.userId, user.id))
         
         console.warn(`Calibrated usage for user ${user.id}`)
       }
     }
   }
   ```

3. **监控和告警** (Detective)
   ```typescript
   // API中添加一致性检查
   async function validateUserUsage(userId: string) {
     const [usage] = await db.select().from(userUsage)
       .where(eq(userUsage.userId, userId))
     
     const [actual] = await db.select({
       count: sql<number>`count(*)`,
       size: sql<number>`sum(file_size)`
     })
     .from(documents)
     .where(eq(documents.userId, userId))
     
     const countDiff = Math.abs(usage.documentCount - actual.count)
     const sizeDiff = Math.abs(usage.storageUsed - actual.size)
     
     if (countDiff > 0 || sizeDiff > 1024 * 1024) { // 1MB容差
       Sentry.captureMessage('User usage inconsistency detected', {
         level: 'warning',
         extra: { userId, countDiff, sizeDiff }
       })
     }
   }
   ```

**Testing Requirements**:
- ✅ 并发测试: 同时上传多个文件验证计数准确
- ✅ 错误恢复测试: 部分失败后统计仍正确
- ✅ 校准测试: 验证定期校准任务修复不一致

**Residual Risk**: Low - 原子操作+校准任务后风险可控

**Owner**: Dev (实施) + DevOps (校准任务)  
**Timeline**: Task 3已实现原子操作，Task 8添加校准

---

### Medium Risks (Score 4)

#### TECH-002: 网络中断导致部分上传

**Probability**: Medium (2)  
**Impact**: Medium (2)  
**Risk Score**: **4 (Medium)**

**Description**: 用户网络不稳定，导致文件部分上传后中断。

**Mitigation**:
- 指数退避重试(最多3次) ✅ 已实现
- 前端显示上传进度和状态
- 提供"重试"按钮

---

#### TECH-003: 指数退避重试机制失效

**Probability**: Medium (2)  
**Impact**: Medium (2)  
**Risk Score**: **4 (Medium)**

**Description**: 重试逻辑有Bug，导致上传失败但未正确重试。

**Mitigation**:
- 单元测试覆盖重试逻辑
- 监控重试次数和成功率
- 日志记录每次重试尝试

---

#### PERF-002: 并发上传压力

**Probability**: Medium (2)  
**Impact**: Medium (2)  
**Risk Score**: **4 (Medium)**

**Description**: 多用户同时上传大文件，Serverless函数并发达到限制。

**Mitigation**:
- Vercel Pro支持1000并发
- 前端限制单用户最多同时3个上传
- 队列机制延迟非紧急上传

---

#### PERF-003: Storage响应延迟

**Probability**: Medium (2)  
**Impact**: Medium (2)  
**Risk Score**: **4 (Medium)**

**Description**: Supabase Storage在高峰期响应慢，影响用户体验。

**Mitigation**:
- 设置合理的超时时间(5分钟)
- 显示上传进度减少焦虑
- 监控Storage P95延迟

---

#### SEC-003: 临时签名URL的安全性问题

**Probability**: Medium (2)  
**Impact**: Medium (2)  
**Risk Score**: **4 (Medium)**

**Description**: 1小时有效期的签名URL可能被截获并分享，导致文档泄露。

**Mitigation**:
- 限制签名URL有效期为1小时 ✅ 已实现
- 敏感文档考虑更短有效期(15分钟)
- IP白名单(Phase 2)
- 下载次数限制(Phase 2)

---

#### DATA-003: 文件删除后Storage和DB不同步

**Probability**: Medium (2)  
**Impact**: Medium (2)  
**Risk Score**: **4 (Medium)**

**Description**: 删除操作中Storage删除失败但DB记录已删除。

**Mitigation**:
- 使用事务保证原子性 ✅ 已计划
- 后台清理任务处理孤儿文件
- 软删除策略(Phase 2)

---

### Low Risks (Score 2-3)

#### TECH-004: 文件MIME类型检测失败

**Probability**: Low (1)  
**Impact**: Medium (2)  
**Risk Score**: **3 (Low)**

**Description**: 某些文件类型无法正确识别MIME类型。

**Mitigation**:
- 依赖Story 2.1的file-type库(Magic Bytes)
- 后备到文件扩展名验证

---

#### SEC-004: RLS Policy性能影响

**Probability**: Low (1)  
**Impact**: Medium (2)  
**Risk Score**: **3 (Low)**

**Description**: 复杂的RLS规则可能影响Storage操作性能。

**Mitigation**:
- 使用简单的RLS规则(仅检查userId目录)
- 监控Storage操作延迟
- Supabase索引优化

---

#### DATA-004: Metadata字段数据丢失

**Probability**: Low (1)  
**Impact**: Medium (2)  
**Risk Score**: **3 (Low)**

**Description**: JSONB metadata字段更新时覆盖原有数据。

**Mitigation**:
- 使用对象合并而非覆盖
- 关键元数据使用独立字段

---

#### BUS-001: Supabase存储成本超预算

**Probability**: Low (1)  
**Impact**: Medium (2)  
**Risk Score**: **3 (Low)**

**Description**: 用户上传大量文档，超出100GB免费额度。

**Mitigation**:
- 限制每用户500MB配额 ✅ 已实现
- MVP阶段1000用户最多500GB
- 监控存储使用量
- 成本告警阈值80GB

---

## Risk-Based Testing Strategy

### Priority 1: Critical Risk Tests (P0)

**必须在部署前完成的测试**:

1. **SEC-001测试套件** (预计3小时)
   ```typescript
   describe('Service Role Key Security', () => {
     it('should not expose Service Role Key in client bundle', async () => {
       const bundle = await buildClientBundle()
       expect(bundle).not.toContain('SUPABASE_SERVICE_ROLE_KEY')
       expect(bundle).not.toContain(process.env.SUPABASE_SERVICE_ROLE_KEY)
     })
     
     it('should throw error when using StorageService in browser', () => {
       // Mock window object
       global.window = {} as any
       expect(() => {
         new StorageService()
       }).toThrow('Service Role Key cannot be used in browser')
     })
   })
   ```

2. **DATA-001测试套件** (预计4小时)
   ```typescript
   describe('Rollback Mechanism', () => {
     it('should cleanup Storage file when DB insert fails', async () => {
       // Mock DB failure
       vi.spyOn(db, 'insert').mockRejectedValueOnce(new Error('DB error'))
       
       const result = await uploadDocument(file)
       
       expect(result.error).toBeTruthy()
       
       // Verify file was deleted from Storage
       const exists = await StorageService.fileExists(storagePath)
       expect(exists).toBe(false)
     })
     
     it('should maintain consistency on concurrent operations', async () => {
       // Upload 3 files concurrently
       await Promise.all([
         uploadDocument(file1),
         uploadDocument(file2),
         uploadDocument(file3)
       ])
       
       // Verify userUsage is accurate
       const [usage] = await db.select().from(userUsage)
       const [actual] = await db.select({ count: sql`count(*)` })
         .from(documents)
       
       expect(usage.documentCount).toBe(actual.count)
     })
   })
   ```

### Priority 2: High Risk Tests (P1)

1. **PERF-001: 大文件上传测试** (预计2小时)
   - 50MB文件在慢速网络(1Mbps)
   - 验证5分钟内完成

2. **SEC-002: RLS Policy测试** (预计2小时)
   - 跨用户访问测试
   - 路径遍历攻击测试

3. **TECH-001: API健康检查** (预计1小时)
   - Mock Supabase API故障
   - 验证降级提示

4. **DATA-002: 配额统计测试** (预计2小时)
   - 并发上传计数准确性
   - 校准任务修复不一致

### Priority 3: Medium Risk Tests (P2)

- TECH-002, TECH-003, PERF-002, PERF-003, SEC-003, DATA-003
- 预计共6小时

### Priority 4: Low Risk Tests (P3)

- TECH-004, SEC-004, DATA-004, BUS-001
- 预计共2小时

**Total Testing Time**: ~22小时

---

## Risk Mitigation Summary

### Must Fix Before Production (P0)

1. **SEC-001**: 实施Service Role Key保护
   - 运行时检查
   - 代码审查清单
   - Bundle扫描测试

2. **DATA-001**: 实施分布式事务和补偿机制
   - 改进上传流程(补偿事务)
   - 改进删除流程(幂等性)
   - 后台清理任务
   - 一致性监控

### Should Fix (P1)

- PERF-001: Vercel配置验证
- SEC-002: RLS Policy测试
- TECH-001: 健康检查和监控
- DATA-002: 原子操作+校准任务

### Monitor and Track (P2)

- Medium风险: 监控指标和告警
- 后续Sprint优化

---

## Risk Acceptance Criteria

### Can Deploy If

- ✅ SEC-001缓解措施已实施并测试通过
- ✅ DATA-001补偿事务机制已实施
- ✅ 后台清理任务已配置
- ✅ 所有P0测试通过

### Cannot Deploy If

- ❌ Service Role Key可在客户端访问
- ❌ 回滚测试失败
- ❌ 一致性测试失败

---

## Monitoring Requirements

### Post-Deployment Monitoring

1. **Storage Operations**
   - 上传成功率 (目标 ≥ 98%)
   - 上传延迟 P95 (目标 < 30s for 10MB)
   - 删除成功率 (目标 ≥ 99%)

2. **Data Consistency**
   - Storage vs DB size差异 (告警阈值 > 5%)
   - userUsage准确性 (每日校准)

3. **Security**
   - 跨用户访问尝试 (应为0)
   - Service Role Key使用异常

4. **Business**
   - Storage使用量 (成本告警 > 80GB)
   - 用户配额超限频率

---

## Risk Review Triggers

重新评估风险当:
- Supabase SDK重大版本升级
- 用户上传量显著增加(>1000文档/天)
- 发现新的安全漏洞
- Storage服务可用性SLA未达标

---

## Appendix: Risk Scoring Methodology

**Probability Scale**:
- High (3): >70% 可能发生
- Medium (2): 30-70% 可能发生
- Low (1): <30% 可能发生

**Impact Scale**:
- High (3): 数据泄露、系统不可用、重大功能失效
- Medium (2): 性能下降、部分功能异常
- Low (1): 轻微不便、可接受的降级

**Risk Score** = Probability × Impact

**Priority Mapping**:
- Score 9: Critical (必须修复)
- Score 6: High (应该修复)
- Score 4: Medium (监控)
- Score 2-3: Low (可接受)

---

**Risk Assessment Complete**  
**Next Step**: 开发团队审查缓解策略并实施P0修复  
**QA Review**: 准备P0和P1测试套件

