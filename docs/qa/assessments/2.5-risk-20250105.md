# Risk Profile: Story 2.5 - 文档列表与管理

**Date**: 2025-01-05  
**Reviewer**: Quinn (Test Architect)  
**Story**: 2.5 - 文档列表与管理  
**Epic**: 2 - 文档管理与解析

---

## Executive Summary

- **Total Risks Identified**: 11
- **Critical Risks (Score 9)**: 2
- **High Risks (Score 6)**: 3
- **Medium Risks (Score 4)**: 3
- **Low Risks (Score 2-3)**: 3
- **Overall Risk Score**: 64/100 (Moderate-High Risk)

### Top Concerns

1. **Cascade Delete Data Integrity** - Multi-step deletion process has high failure potential
2. **Authorization Bypass** - Four endpoints need consistent auth checks
3. **Performance - SWR Polling** - Every 5s polling creates significant load

---

## Critical Risks Requiring Immediate Attention

### 1. SEC-001: Cascade Delete Data Integrity Risk

**Score: 9 (Critical)**  
**Category**: Security & Data  
**Probability**: High (3) - Multi-step process with many failure points  
**Impact**: High (3) - Data inconsistency, cost increase, user data leaks

**Description**:
Delete operation requires 4 sequential steps:
1. Query document_chunks
2. Delete vectors from pgvector
3. Delete file from Supabase Storage  
4. Delete DB records

Failure at any step leaves orphaned data. Story 2.4 vectors are expensive; orphaned vectors increase costs. Orphaned storage files waste space.

**Affected Components**:
- `src/app/api/documents/[id]/route.ts` (DELETE handler)
- `StorageService.deleteFile()`
- `VectorRepositoryFactory.create().deleteBatch()`
- Database cascade delete

**Detection Method**: Code review of DELETE implementation plan

**Mitigation Strategy**: Preventive + Detective

**Actions**:
1. **Implement Saga Pattern**:
   - Track deletion state machine
   - Rollback on failure
   - Log each step with transaction ID

2. **Add Retry Logic**:
   ```typescript
   async deleteDocument(id: string) {
     const MAX_RETRIES = 3
     for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
       try {
         // Step 1: Soft delete in DB (mark as DELETING)
         await markAsDeleting(id)
         
         // Step 2: Delete vectors (can retry)
         await vectorRepo.deleteBatch(chunkIds)
         
         // Step 3: Delete storage (can retry)
         await storage.deleteFile(path)
         
         // Step 4: Hard delete from DB
         await db.delete(documents).where(eq(id))
         
         return { success: true }
       } catch (error) {
         if (attempt === MAX_RETRIES) throw error
         await sleep(1000 * attempt) // exponential backoff
       }
     }
   }
   ```

3. **Background Cleanup Job**:
   - Daily cron job to find documents marked DELETING > 24h
   - Retry deletion or alert admin
   - Separately find orphaned vectors/storage

4. **Add Verification Step**:
   ```typescript
   async function verifyDeletion(documentId: string) {
     const checks = {
       db: await checkDbDeleted(documentId),
       storage: await checkStorageDeleted(path),
       vectors: await checkVectorsDeleted(chunkIds)
     }
     
     if (!Object.values(checks).every(Boolean)) {
       logger.error('Incomplete deletion', { documentId, checks })
       // trigger cleanup
     }
   }
   ```

**Testing Requirements**:
- Integration test: Simulate vector delete failure → verify rollback
- Integration test: Simulate storage delete failure → verify cleanup
- Integration test: Verify no orphaned data after delete
- Load test: Multiple concurrent deletes

**Residual Risk**: Low - With retries and cleanup job, risk is contained

**Owner**: Dev  
**Timeline**: Must implement before DELETE endpoint goes live

---

### 2. SEC-002: Authorization Bypass on Document Operations

**Score: 6 (High)**  
**Category**: Security  
**Probability**: Medium (2) - Multiple endpoints, easy to miss one  
**Impact**: High (3) - Cross-user data access/modification

**Description**:
Four API endpoints handle document operations:
- `GET /api/documents` - List documents
- `PATCH /api/documents/:id` - Rename
- `DELETE /api/documents/:id` - Delete
- `GET /api/documents/:id/preview` - Preview

Each must verify:
1. User is authenticated
2. User owns the document (for :id routes)

Missing auth check in any endpoint = security vulnerability.

**Affected Components**:
- All document API routes

**Detection Method**: Code review + security testing

**Mitigation Strategy**: Preventive

**Actions**:
1. **Centralize Auth Logic**:
   ```typescript
   // src/lib/auth-helpers.ts
   export async function requireDocumentOwnership(
     documentId: string,
     session: Session
   ) {
     const [doc] = await db.select()
       .from(documents)
       .where(
         and(
           eq(documents.id, documentId),
           eq(documents.userId, session.user.id)
         )
       )
     
     if (!doc) {
       throw new UnauthorizedError('Document not found or access denied')
     }
     
     return doc
   }
   ```

2. **Consistent Error Messages**:
   - Always return 404 for unauthorized + not found (don't leak existence)
   - Log unauthorized attempts with user ID

3. **Rate Limiting**:
   - Add rate limit on failed auth attempts
   - Alert on suspicious patterns

4. **Add Middleware**:
   ```typescript
   // Apply to all /api/documents/:id/* routes
   async function documentAuthMiddleware(req, params) {
     const session = await auth()
     if (!session) throw new UnauthorizedError()
     
     if (params.id) {
       await requireDocumentOwnership(params.id, session)
     }
   }
   ```

**Testing Requirements**:
- **Integration test**: User A cannot GET user B's document
- **Integration test**: User A cannot PATCH user B's document  
- **Integration test**: User A cannot DELETE user B's document
- **Integration test**: User A cannot preview user B's document
- **Integration test**: Unauthenticated user cannot access any endpoint
- **Penetration test**: Try JWT token manipulation

**Residual Risk**: Low - Standard auth pattern with comprehensive tests

**Owner**: Dev  
**Timeline**: Must implement with API endpoints

---

## High Risks

### 3. PERF-001: SWR Polling Overhead

**Score: 6 (High)**  
**Category**: Performance  
**Probability**: High (3) - Polling is enabled by default  
**Impact**: Medium (2) - Increased load, slower response

**Description**:
```typescript
const { data } = useSWR('/api/documents', {
  refreshInterval: 5000, // Polls every 5 seconds
})
```

If user has 20 documents on screen:
- 12 API calls/minute
- 720 API calls/hour per user
- Each call queries DB with joins

With 100 concurrent users: 72,000 API calls/hour = increased DB load, API latency.

**Affected Components**:
- `src/hooks/useDocuments.ts`
- `GET /api/documents` endpoint
- Database query load

**Mitigation**:
1. **Conditional Polling**:
   ```typescript
   const hasProcessingDocs = documents.some(d => 
     ['PENDING', 'PARSING', 'EMBEDDING'].includes(d.status)
   )
   
   const { data } = useSWR('/api/documents', {
     refreshInterval: hasProcessingDocs ? 5000 : 0, // Only poll if needed
   })
   ```

2. **Optimize Query**:
   - Add index on (userId, uploadedAt)
   - Only fetch fields needed for list view
   - Consider caching for static data

3. **Future: WebSocket**:
   - Replace polling with WebSocket push
   - Server notifies client when status changes
   - Phase 2 enhancement

4. **SWR Deduplication**:
   ```typescript
   dedupingInterval: 2000 // Already planned in story
   ```

**Testing Requirements**:
- Load test: 100 concurrent users with polling
- Measure: API call frequency, DB query count, response time
- Verify: Polling stops when no processing documents

**Residual Risk**: Low - Conditional polling significantly reduces load

**Owner**: Dev  
**Timeline**: Implement with useDocuments hook

---

### 4. DATA-001: Orphaned Vector Data

**Score: 6 (High)**  
**Category**: Data Integrity  
**Probability**: Medium (2) - Delete failures happen  
**Impact**: High (3) - Cost increase, data inconsistency

**Description**:
Related to SEC-001 but focused on vector data specifically. If vector deletion fails:
- Vectors remain in pgvector (or future Pinecone)
- Storage costs accumulate
- Vector search returns deleted documents
- User confusion and data inconsistency

**Affected Components**:
- `VectorRepositoryFactory`
- pgvector database

**Mitigation**:
1. **Soft Delete Pattern**:
   ```typescript
   // Add deleted_at column to document_chunks
   await db.update(documentChunks)
     .set({ deletedAt: new Date() })
     .where(eq(documentChunks.documentId, id))
   ```

2. **Async Cleanup**:
   - Mark chunks as deleted immediately
   - Background job deletes vectors
   - Retry on failure

3. **Verification Query**:
   ```sql
   -- Find orphaned vectors (chunks deleted but vectors exist)
   SELECT c.id 
   FROM document_chunks c
   WHERE c.deleted_at IS NOT NULL
     AND EXISTS (
       SELECT 1 FROM vector_store WHERE chunk_id = c.id
     )
   ```

4. **Monitoring**:
   - Alert on vector count divergence
   - Track deletion success rate
   - Dashboard for orphaned data

**Testing Requirements**:
- Integration test: Simulate vector delete failure → verify cleanup
- Integration test: Verify vector search excludes soft-deleted chunks
- Monitoring: Track vector count vs chunk count

**Residual Risk**: Low - Soft delete + background cleanup handles failures

**Owner**: Dev  
**Timeline**: Implement with DELETE endpoint

---

### 5. TECH-001: React-PDF Integration Complexity

**Score: 4 (Medium)**  
**Category**: Technical  
**Probability**: Medium (2) - PDFs vary widely in structure  
**Impact**: Medium (2) - Preview fails for some PDFs

**Description**:
react-pdf may fail with:
- Password-protected PDFs
- Corrupted PDFs
- Unusual encodings
- Large PDFs (>50MB)
- Scanned image PDFs

User expects preview to work for all uploaded PDFs.

**Affected Components**:
- `src/components/documents/DocumentPreviewModal.tsx`
- react-pdf library

**Mitigation**:
1. **Error Boundary**:
   ```typescript
   <ErrorBoundary fallback={<PreviewError />}>
     <PDFPreview file={url} />
   </ErrorBoundary>
   ```

2. **Graceful Fallback**:
   ```typescript
   function DocumentPreviewModal({ document }) {
     const [error, setError] = useState(false)
     
     if (error) {
       return (
         <div>
           <p>Preview not available for this document</p>
           <Button onClick={() => downloadFile(document)}>
             Download to view
           </Button>
         </div>
       )
     }
     
     return <PDFViewer onError={() => setError(true)} />
   }
   ```

3. **Comprehensive Testing**:
   - Test fixtures with various PDF types
   - Password-protected PDF
   - Scanned image PDF
   - Large PDF (>10MB)
   - Corrupted PDF

4. **User Messaging**:
   - Loading state while rendering
   - Clear error message
   - Always provide download option

**Testing Requirements**:
- Unit test: Error boundary catches render errors
- Integration test: Various PDF types
- E2E test: Preview fallback to download

**Residual Risk**: Low - Fallback ensures feature is never broken

**Owner**: Dev  
**Timeline**: Implement with preview modal

---

## Medium Risks

### 6. PERF-002: Search Performance with LIKE Queries

**Score: 4 (Medium)**  
**Probability**: Medium (2)  
**Impact**: Medium (2)

**Description**:
Search uses `LIKE` query on filename:
```sql
SELECT * FROM documents 
WHERE user_id = ? AND filename LIKE '%search%'
```

Without index on filename, this is a full table scan. Slow as documents grow.

**Mitigation**:
1. **Add Database Index**:
   ```sql
   CREATE INDEX idx_documents_filename_search 
   ON documents USING gin (filename gin_trgm_ops);
   ```

2. **Debouncing** (already planned):
   - 300ms debounce reduces query frequency

3. **Client-side Search**:
   - For MVP, search on already-fetched page
   - Server-side search in Phase 2

4. **Monitor Performance**:
   - Track search query execution time
   - Alert if >100ms

**Testing Requirements**:
- Performance test: Search with 1000 documents
- Verify: Index is used (EXPLAIN ANALYZE)

**Residual Risk**: Low - Index + debounce should suffice for MVP

---

### 7. OPS-001: Multiple New Dependencies

**Score: 4 (Medium)**  
**Probability**: Medium (2)  
**Impact**: Medium (2)

**Description**:
Story adds 5+ new libraries:
- `swr` (data fetching)
- `react-pdf` (PDF rendering)
- `react-markdown` (Markdown rendering)
- `date-fns` (date formatting)
- `framer-motion` (animations)

Risk: Version conflicts, increased bundle size, maintenance burden.

**Mitigation**:
1. **Lock Versions**:
   ```json
   {
     "swr": "2.2.4",
     "react-pdf": "7.7.0",
     "react-markdown": "9.0.1"
   }
   ```

2. **Bundle Analysis**:
   ```bash
   npm run analyze
   ```
   - Monitor bundle size increase
   - Consider code splitting for react-pdf

3. **Tree Shaking**:
   - Import only needed functions
   ```typescript
   import { formatDistanceToNow } from 'date-fns' // Not entire library
   ```

4. **Document Choices**:
   - Why each library was chosen
   - Alternatives considered
   - Trade-offs

**Testing Requirements**:
- Build test: Bundle size < 500KB increase
- Build test: No version conflicts

**Residual Risk**: Low - Standard dependencies, well-maintained

---

### 8. BUS-001: Feature Complexity for MVP

**Score: 4 (Medium)**  
**Probability**: Medium (2)  
**Impact**: Medium (2)

**Description**:
Story 2.5 has 10 acceptance criteria with complex features:
- List + search + sort + pagination
- Rename + delete + preview
- Real-time status updates
- Responsive design

This is a LOT for MVP. Risk of delay or cut corners.

**Mitigation**:
1. **Phase Features**:
   - **Phase 1 (MVP)**: List, delete, basic status display
   - **Phase 2**: Preview, rename, advanced search, sorting

2. **Simplify Preview**:
   - MVP: Text-only preview (no react-pdf)
   - Phase 2: Rich preview with PDF rendering

3. **Defer Virtual Scrolling**:
   - MVP: Pagination only
   - Phase 2: Virtual scroll for >100 docs

4. **Focus on P0**:
   - Core: Users can see and delete documents
   - Enhanced: All other features

**Recommendation**:
Consider splitting into 2 stories:
- Story 2.5a: Document List & Delete (P0, 2 days)
- Story 2.5b: Document Management Enhanced (P1, 2 days)

**Residual Risk**: Medium - Still a complex story even with simplifications

---

## Low Risks

### 9. TECH-002: URL State Management Bugs

**Score: 2 (Low)**  
**Probability**: Low (1) - useSearchParams is standard  
**Impact**: Medium (2) - Broken pagination/search when sharing URLs

**Mitigation**:
- E2E tests for URL state persistence
- Test browser back/forward buttons

---

### 10. DATA-002: Preview Content Missing

**Score: 2 (Low)**  
**Probability**: Low (1) - Depends on Story 2.3  
**Impact**: Medium (2) - Preview feature broken

**Mitigation**:
- Verify Story 2.3 stores parsedContent in metadata
- Add fallback message if missing

---

### 11. SEC-003: Filename Injection Attacks

**Score: 3 (Low)**  
**Probability**: Low (1) - Good validation planned  
**Impact**: High (3) - Path traversal or XSS

**Mitigation**:
- Regex validation: `/[\/\\:*?"<>|]/`
- Length limit: 1-255 chars
- Unit tests for injection attempts

---

## Risk Distribution

### By Category

- **Security (SEC)**: 3 risks (2 high, 1 low)
- **Performance (PERF)**: 2 risks (1 high, 1 medium)
- **Data (DATA)**: 2 risks (2 high)
- **Technical (TECH)**: 2 risks (1 medium, 1 low)
- **Business (BUS)**: 1 risk (medium)
- **Operational (OPS)**: 1 risk (medium)

### By Component

- **DELETE Endpoint**: 3 risks (critical priority)
- **API Endpoints**: 2 risks (auth checks)
- **useDocuments Hook**: 1 risk (polling)
- **DocumentPreviewModal**: 1 risk (PDF rendering)
- **GET /api/documents**: 1 risk (search performance)

---

## Risk-Based Testing Strategy

### Priority 1: Critical Risk Tests (Must Have)

**Cascade Delete Integrity**:
```typescript
describe('DELETE /api/documents/:id - Cascade Delete', () => {
  it('should delete vectors, storage, and DB in order', async () => {
    // Setup: Upload document with vectors
    const doc = await uploadAndProcessDocument()
    
    // Act: Delete document
    await deleteDocument(doc.id)
    
    // Assert: All traces removed
    expect(await findVectors(doc.id)).toHaveLength(0)
    expect(await findStorage(doc.path)).toBeNull()
    expect(await findDocument(doc.id)).toBeNull()
  })
  
  it('should rollback on vector delete failure', async () => {
    // Setup: Mock vector delete failure
    mockVectorRepo.deleteBatch.mockRejectedValue(new Error('Vector service down'))
    
    // Act & Assert: Delete fails, but DB not deleted
    await expect(deleteDocument(doc.id)).rejects.toThrow()
    expect(await findDocument(doc.id)).toBeDefined()
  })
  
  it('should retry on transient failures', async () => {
    // Setup: Fail twice, succeed third time
    mockVectorRepo.deleteBatch
      .mockRejectedValueOnce(new Error('Timeout'))
      .mockRejectedValueOnce(new Error('Timeout'))
      .mockResolvedValueOnce(true)
    
    // Act: Should eventually succeed
    await deleteDocument(doc.id)
    expect(mockVectorRepo.deleteBatch).toHaveBeenCalledTimes(3)
  })
})
```

**Authorization Tests**:
```typescript
describe('Document Authorization', () => {
  it('should prevent user A from accessing user B documents', async () => {
    const userA = await createUser('a@test.com')
    const userB = await createUser('b@test.com')
    const docB = await uploadDocument(userB)
    
    // User A tries to access B's document
    const response = await fetch(`/api/documents/${docB.id}`, {
      headers: { Authorization: `Bearer ${userA.token}` }
    })
    
    expect(response.status).toBe(404) // Not 403, to avoid leaking existence
  })
  
  it('should prevent unauthorized preview', async () => {
    const response = await fetch(`/api/documents/${doc.id}/preview`)
    expect(response.status).toBe(401)
  })
})
```

### Priority 2: High Risk Tests

**SWR Polling**:
```typescript
describe('useDocuments Hook - Polling', () => {
  it('should only poll when documents are processing', () => {
    const { result } = renderHook(() => useDocuments())
    
    // All documents READY - should not poll
    expect(result.current.refreshInterval).toBe(0)
    
    // One document PARSING - should poll
    mockDocuments.push({ status: 'PARSING' })
    expect(result.current.refreshInterval).toBe(5000)
  })
})
```

**PDF Preview Fallback**:
```typescript
describe('DocumentPreviewModal', () => {
  it('should fallback to download on render error', async () => {
    mockPDF.getDocument.mockRejectedValue(new Error('Corrupt PDF'))
    
    render(<DocumentPreviewModal document={corruptPDF} />)
    
    expect(screen.getByText(/Preview not available/i)).toBeInTheDocument()
    expect(screen.getByText(/Download/i)).toBeInTheDocument()
  })
})
```

### Priority 3: Performance Tests

**Search Performance**:
```typescript
describe('GET /api/documents - Search Performance', () => {
  it('should complete search query in <100ms', async () => {
    // Setup: 1000 documents
    await seedDocuments(1000)
    
    const start = Date.now()
    const response = await fetch('/api/documents?search=test')
    const duration = Date.now() - start
    
    expect(duration).toBeLessThan(100)
    expect(response.status).toBe(200)
  })
})
```

---

## Risk Acceptance Criteria

### Must Fix Before Production

1. ✅ **SEC-001**: Cascade delete with retries and rollback
2. ✅ **SEC-002**: Centralized authorization checks
3. ✅ **DATA-001**: Soft delete pattern with cleanup

### Can Deploy with Monitoring

1. ⚠️ **PERF-001**: SWR conditional polling (monitor API load)
2. ⚠️ **TECH-001**: PDF preview with fallback (monitor error rate)

### Accepted Risks

1. ✓ **BUS-001**: Complex feature set - team committed to full scope
2. ✓ **OPS-001**: New dependencies - standard, well-maintained libraries

---

## Monitoring Requirements

Post-deployment monitoring:

### Metrics to Track

1. **Delete Operations**:
   - Success rate (target: >99%)
   - Average duration (target: <2s)
   - Failure breakdown (vector/storage/DB)
   - Orphaned data count

2. **API Performance**:
   - GET /api/documents response time (target: <500ms)
   - API call frequency (monitor polling impact)
   - Search query duration (target: <100ms)

3. **Preview Feature**:
   - Preview success rate by file type
   - PDF render errors
   - Fallback usage rate

4. **Security**:
   - Failed authorization attempts
   - Cross-user access attempts
   - Rate limit triggers

### Alerts

- Delete success rate < 95% → Immediate alert
- Orphaned vectors > 10 → Daily alert
- API p95 latency > 1s → Warning
- Authorization failures > 10/min from single user → Security alert

---

## Risk Review Triggers

Review and update risk profile when:

1. **Delete operation failure rate increases**
2. **API performance degrades**
3. **User reports preview failures**
4. **Document count per user exceeds 100** (test virtual scrolling)
5. **Security incident related to document access**

---

## Recommendations Summary

### Immediate Actions (Before Implementation)

1. **Design cascade delete with rollback pattern**
2. **Create centralized auth helper function**
3. **Plan conditional SWR polling logic**
4. **Add database index on filename**
5. **Consider feature phasing (split story)**

### Testing Focus

1. **Security**: Multi-user authorization tests
2. **Data Integrity**: Cascade delete scenarios
3. **Performance**: Load test with polling enabled
4. **Error Handling**: PDF preview edge cases

### Monitoring Setup

1. **Delete operation dashboards**
2. **API performance tracking**
3. **Security event logging**
4. **Orphaned data alerts**

---

## Conclusion

Story 2.5 presents **moderate-high risk** (score 64/100) due to:
- Complex multi-step delete operation (critical)
- Multiple authorization endpoints (high)  
- Performance implications of polling (high)

However, all risks are **well-mitigated** with proper implementation:
- Cascade delete with retries/rollback
- Centralized authorization
- Conditional polling
- Comprehensive testing

**Recommendation**: **PROCEED** with Story 2.5 implementation, with **mandatory implementation** of the critical risk mitigations (SEC-001, SEC-002, DATA-001) before considering the story complete.

Consider **splitting the story** into 2.5a (Core) and 2.5b (Enhanced) to reduce scope and risk for MVP.

---

**Risk Assessment Complete**  
**Next Step**: Present findings to team, implement critical mitigations, proceed with development
