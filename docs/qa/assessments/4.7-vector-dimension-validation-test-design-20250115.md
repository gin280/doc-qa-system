# 测试设计: Story 4.7 - 向量维度验证增强

**日期**: 2025-01-15  
**设计者**: Quinn (测试架构师)  
**Story**: 4.7 - 向量维度验证增强  
**Epic**: 4 - 系统质量改进

---

## 测试策略概览

**测试场景总数**: 24个  
**单元测试**: 21个 (87.5%)  
**集成测试**: 3个 (12.5%)  
**E2E测试**: 0个 (0%)

**优先级分布**:
- P0: 10个 (42%) - 核心维度验证和错误处理
- P1: 9个 (37%) - 配置一致性和边界情况
- P2: 5个 (21%) - 日志和文档验证

**测试覆盖目标**:
- `embeddingService` 维度验证代码: ≥ 90%
- `queryVectorizer` 维度验证代码: ≥ 90%
- `validate-vector-config`: 100%

---

## 测试场景按验收标准分组

### AC1: 增强文档向量维度验证

#### 场景 4.7-UNIT-001: 维度匹配时成功处理

**测试级别**: Unit  
**优先级**: P0  
**测试内容**: 验证当 LLM 返回正确维度 (1024D) 的向量时，embeddingService 正常处理

**理由**: 这是最基础的正常路径，必须保证核心功能可用

**前置条件**:
- Mock LLM Provider 返回 1024 维向量
- Mock 数据库插入成功
- provider = 'zhipu', EMBEDDING_DIMENSION = 1024

**测试步骤**:
```typescript
1. 准备 mockChunks (1个 chunk)
2. Mock LLM.generateEmbeddings 返回 [Array(1024).fill(0.1)]
3. 调用 embedAndStoreChunks(documentId, mockChunks)
4. 验证不抛出异常
5. 验证 LLM.generateEmbeddings 被调用 1 次
6. 验证数据库插入被调用
```

**预期结果**: ✅ 成功完成，无异常

**缓解风险**: TECH-001 (配置验证逻辑冲突)

---

#### 场景 4.7-UNIT-002: 维度不匹配时抛出错误

**测试级别**: Unit  
**优先级**: P0  
**测试内容**: 验证当向量维度不正确 (1536D) 时，抛出 DIMENSION_MISMATCH 错误

**理由**: 核心错误检测功能，防止数据不一致

**前置条件**:
- Mock LLM Provider 返回 1536 维向量 (错误维度)
- provider = 'zhipu', 期望 1024D

**测试步骤**:
```typescript
1. Mock LLM.generateEmbeddings 返回 [Array(1536).fill(0.1)]
2. 调用 embedAndStoreChunks(documentId, mockChunks)
3. 捕获异常
```

**预期结果**:
- ❌ 抛出 EmbeddingError
- 错误类型: 'DIMENSION_MISMATCH'
- 错误消息包含: "expected 1024", "got 1536"

**缓解风险**: N/A (核心功能)

---

#### 场景 4.7-UNIT-003: 空向量时抛出错误

**测试级别**: Unit  
**优先级**: P0  
**测试内容**: 验证当 LLM 返回空向量时，系统检测并拒绝

**理由**: 防止无效数据进入数据库

**前置条件**:
- Mock LLM Provider 返回空数组 []

**测试步骤**:
```typescript
1. Mock LLM.generateEmbeddings 返回 [[]]
2. 调用 embedAndStoreChunks(documentId, mockChunks)
```

**预期结果**:
- ❌ 抛出 EmbeddingError
- 错误消息包含维度信息

---

#### 场景 4.7-UNIT-004: 超长向量时抛出错误

**测试级别**: Unit  
**优先级**: P1  
**测试内容**: 验证当向量超过合理长度 (2048D) 时，系统拒绝

**理由**: 防止异常数据和资源浪费

**前置条件**:
- Mock LLM Provider 返回 2048 维向量

**测试步骤**:
```typescript
1. Mock LLM.generateEmbeddings 返回 [Array(2048).fill(0.1)]
2. 调用 embedAndStoreChunks(documentId, mockChunks)
```

**预期结果**:
- ❌ 抛出 EmbeddingError
- 错误消息包含: "expected 1024", "got 2048"

---

#### 场景 4.7-UNIT-005: 配置一致性检查 - 正确配置

**测试级别**: Unit  
**优先级**: P1  
**测试内容**: 验证 validateProviderDimension() 在配置正确时通过

**理由**: 确保配置验证逻辑正确工作

**前置条件**:
- provider = 'zhipu'
- dimension = 1024

**测试步骤**:
```typescript
1. 调用 validateProviderDimension('zhipu', 1024)
2. 验证不抛出异常
```

**预期结果**: ✅ 不抛出异常

**缓解风险**: TECH-001

---

#### 场景 4.7-UNIT-006: 配置一致性检查 - 配置不匹配

**测试级别**: Unit  
**优先级**: P1  
**测试内容**: 验证 validateProviderDimension() 检测到配置不匹配

**理由**: 防止错误配置导致系统问题

**前置条件**:
- provider = 'zhipu'
- dimension = 1536 (错误配置)

**测试步骤**:
```typescript
1. 调用 validateProviderDimension('zhipu', 1536)
```

**预期结果**:
- ❌ 抛出 EmbeddingError
- 错误类型: 'DIMENSION_MISMATCH'
- 错误消息包含: "Provider 'zhipu' requires 1024D"
- 错误消息包含: "but configured dimension is 1536D"
- 错误消息包含修复建议

**缓解风险**: TECH-001

---

#### 场景 4.7-UNIT-007: 改进的错误消息结构验证

**测试级别**: Unit  
**优先级**: P1  
**测试内容**: 验证维度不匹配错误消息包含完整信息

**理由**: 确保错误消息可操作，帮助调试

**前置条件**:
- Mock LLM 返回错误维度的向量

**测试步骤**:
```typescript
1. 触发维度不匹配错误
2. 捕获错误消息
3. 验证错误消息结构
```

**预期结果**:
- 错误消息包含: Expected dimension
- 错误消息包含: Received dimension
- 错误消息包含: Provider name
- 错误消息包含: Chunk information
- 错误消息包含: Possible causes
- 错误消息包含: Recovery steps

---

#### 场景 4.7-UNIT-008: 错误日志结构化验证

**测试级别**: Unit  
**优先级**: P2  
**测试内容**: 验证维度不匹配时记录结构化日志

**理由**: 确保可观测性，便于生产环境诊断

**前置条件**:
- Mock console.error
- 触发维度不匹配

**测试步骤**:
```typescript
1. 设置 console.error spy
2. 触发维度不匹配错误
3. 验证日志调用
```

**预期结果**:
- console.error 被调用
- 日志包含结构化数据: documentId, chunkId, chunkIndex, expectedDimension, actualDimension, provider

---

### AC2: 增强查询向量维度验证

#### 场景 4.7-UNIT-009: 查询向量维度正确时成功

**测试级别**: Unit  
**优先级**: P0  
**测试内容**: 验证 queryVectorizer 在维度正确时返回向量

**理由**: 核心功能正常路径

**前置条件**:
- Mock LLM 返回 1024 维向量

**测试步骤**:
```typescript
1. Mock LLM.generateEmbeddings 返回 [Array(1024).fill(0.1)]
2. 调用 queryVectorizer.vectorizeQuery('test query')
3. 验证返回向量
```

**预期结果**:
- ✅ 返回 1024 维向量
- 向量内容与 Mock 一致

---

#### 场景 4.7-UNIT-010: 查询向量维度错误时抛出异常

**测试级别**: Unit  
**优先级**: P0  
**测试内容**: 验证 queryVectorizer 检测到错误维度

**理由**: 防止查询时使用错误维度的向量

**前置条件**:
- Mock LLM 返回 1536 维向量 (错误)

**测试步骤**:
```typescript
1. Mock LLM.generateEmbeddings 返回 [Array(1536).fill(0.1)]
2. 调用 queryVectorizer.vectorizeQuery('test query')
```

**预期结果**:
- ❌ 抛出 QueryVectorizationError
- 错误消息包含: "Invalid vector dimension: 1536"
- 错误消息包含: "expected 1024"

---

#### 场景 4.7-UNIT-011: 使用统一 EMBEDDING_DIMENSION 常量验证

**测试级别**: Unit  
**优先级**: P1  
**测试内容**: 验证 queryVectorizer 使用了 EMBEDDING_DIMENSION 常量

**理由**: 确保配置统一，避免硬编码

**前置条件**:
- 代码审查或静态分析

**测试步骤**:
```typescript
1. 验证 queryVectorizer.ts 导入了 EMBEDDING_DIMENSION
2. 验证维度检查使用了该常量 (不是硬编码 1024)
```

**预期结果**: ✅ 使用统一常量

---

#### 场景 4.7-UNIT-012: 缓存向量维度错误检测

**测试级别**: Unit  
**优先级**: P1  
**测试内容**: 验证从缓存获取的向量维度也被验证

**理由**: 防止缓存污染导致的问题

**前置条件**:
- Mock embeddingCache 返回错误维度的向量

**测试步骤**:
```typescript
1. Mock cache.get() 返回 1536 维向量
2. 调用 queryVectorizer.vectorizeQuery('cached query')
```

**预期结果**:
- ❌ 抛出 QueryVectorizationError (如果实现了缓存验证)
- 或 ⚠️ 记录警告并重新生成向量

**注意**: 此场景取决于 embeddingCache 的实现细节

---

### AC3: 添加系统启动维度一致性检查

#### 场景 4.7-UNIT-013: getExpectedDimensionForProvider - zhipu

**测试级别**: Unit  
**优先级**: P0  
**测试内容**: 验证 zhipu provider 返回 1024 维

**理由**: 确保 provider 映射正确

**测试步骤**:
```typescript
1. 调用 getExpectedDimensionForProvider('zhipu')
2. 验证返回值
```

**预期结果**: 返回 1024

---

#### 场景 4.7-UNIT-014: getExpectedDimensionForProvider - openai

**测试级别**: Unit  
**优先级**: P1  
**测试内容**: 验证 openai provider 返回 1536 维

**理由**: 为未来支持 OpenAI 做准备

**测试步骤**:
```typescript
1. 调用 getExpectedDimensionForProvider('openai')
2. 验证返回值
```

**预期结果**: 返回 1536

---

#### 场景 4.7-UNIT-015: getExpectedDimensionForProvider - 未知 provider

**测试级别**: Unit  
**优先级**: P1  
**测试内容**: 验证未知 provider 抛出错误

**理由**: 防御性编程

**测试步骤**:
```typescript
1. 调用 getExpectedDimensionForProvider('unknown')
```

**预期结果**: 抛出错误 "Unknown provider: unknown"

---

#### 场景 4.7-UNIT-016: validateVectorDimension - 配置正确

**测试级别**: Unit  
**优先级**: P0  
**测试内容**: 验证当前配置 (zhipu + 1024) 通过验证

**理由**: 确保验证逻辑在正常情况下工作

**前置条件**:
- llmConfig.provider = 'zhipu'
- EMBEDDING_DIMENSION = 1024

**测试步骤**:
```typescript
1. 调用 validateVectorDimension()
2. 验证返回结果
```

**预期结果**:
- result.valid = true
- result.errors = []
- result.warnings 可能包含生产环境警告

---

#### 场景 4.7-UNIT-017: validateVectorDimension - 配置不匹配

**测试级别**: Unit  
**优先级**: P1  
**测试内容**: 验证配置不匹配时返回错误

**理由**: 确保配置错误被检测

**前置条件**:
- Mock llmConfig.provider = 'zhipu'
- Mock EMBEDDING_DIMENSION = 1536 (错误)

**测试步骤**:
```typescript
1. Mock 配置不匹配场景
2. 调用 validateVectorDimension()
3. 验证返回结果
```

**预期结果**:
- result.valid = false
- result.errors 包含配置不匹配错误
- 错误消息包含修复建议

**注意**: 可能需要使用 Jest 的 module mocking 来 mock 配置

---

#### 场景 4.7-UNIT-018: assertValidVectorConfig - 开发环境配置错误

**测试级别**: Unit  
**优先级**: P1  
**测试内容**: 验证开发环境配置错误时抛出异常

**理由**: 确保开发者及时发现配置问题

**前置条件**:
- process.env.NODE_ENV = 'development'
- Mock 配置错误

**测试步骤**:
```typescript
1. 设置 NODE_ENV = 'development'
2. Mock validateVectorDimension() 返回 invalid
3. 调用 assertValidVectorConfig()
```

**预期结果**: ❌ 抛出 Error

**缓解风险**: TECH-002

---

#### 场景 4.7-UNIT-019: assertValidVectorConfig - 生产环境配置错误

**测试级别**: Unit  
**优先级**: P0  
**测试内容**: 验证生产环境配置错误时仅警告

**理由**: 避免配置问题阻塞生产服务启动

**前置条件**:
- process.env.NODE_ENV = 'production'
- Mock 配置错误

**测试步骤**:
```typescript
1. 设置 NODE_ENV = 'production'
2. Mock console.error spy
3. Mock validateVectorDimension() 返回 invalid
4. 调用 assertValidVectorConfig()
```

**预期结果**:
- ✅ 不抛出异常
- ⚠️ console.error 被调用
- 日志包含配置错误信息

**缓解风险**: TECH-002

---

#### 场景 4.7-UNIT-020: assertValidVectorConfig - 配置正确

**测试级别**: Unit  
**优先级**: P1  
**测试内容**: 验证配置正确时成功通过

**理由**: 确保正常路径不受影响

**前置条件**:
- 正确的配置

**测试步骤**:
```typescript
1. Mock console.log spy
2. 调用 assertValidVectorConfig()
```

**预期结果**:
- ✅ 不抛出异常
- console.log 记录成功消息

---

### AC4: 完善单元测试覆盖

**注意**: AC4 的测试场景已经包含在上述场景中 (4.7-UNIT-001 到 4.7-UNIT-020)

#### 场景 4.7-UNIT-021: 测试覆盖率验证

**测试级别**: Unit (Meta)  
**优先级**: P0  
**测试内容**: 验证测试覆盖率达标

**理由**: 确保测试质量

**测试步骤**:
```bash
1. 运行 npm test -- --coverage
2. 检查覆盖率报告
```

**预期结果**:
- embeddingService 维度相关代码: ≥ 90%
- queryVectorizer 维度相关代码: ≥ 90%
- validate-vector-config: 100%

**缓解风险**: TEST-001

---

### AC5: 更新错误处理文档

#### 场景 4.7-UNIT-022: JSDoc 文档验证

**测试级别**: Manual Review  
**优先级**: P2  
**测试内容**: 验证 JSDoc 注释完整且准确

**理由**: 确保代码可维护性

**测试步骤**:
```
1. 审查 embeddingService.ts JSDoc
2. 审查 queryVectorizer.ts JSDoc
3. 审查 validate-vector-config.ts JSDoc
4. 验证 EmbeddingError 的 DIMENSION_MISMATCH 错误类型有文档
```

**预期结果**: ✅ 所有函数和错误类型都有完整的 JSDoc

---

### 集成测试场景

#### 场景 4.7-INT-001: 文档上传到向量化完整流程

**测试级别**: Integration  
**优先级**: P0  
**测试内容**: 端到端验证文档上传、分块、向量化、维度验证、存储流程

**理由**: 确保系统集成正确

**前置条件**:
- 测试数据库
- Mock LLM Provider
- 真实的 embeddingService, chunkingService, documentService

**测试步骤**:
```typescript
1. 上传测试文档
2. 等待处理完成
3. 查询数据库验证向量存储
4. 验证向量维度 = 1024
```

**预期结果**:
- ✅ 文档处理成功
- ✅ 向量维度正确
- ✅ 无错误日志

**缓解风险**: TECH-001

---

#### 场景 4.7-INT-002: 查询向量化到检索完整流程

**测试级别**: Integration  
**优先级**: P1  
**测试内容**: 验证查询向量化、维度验证、相似度检索流程

**理由**: 确保查询路径的维度验证不影响功能

**前置条件**:
- 已有测试向量数据
- Mock LLM Provider
- 真实的 queryVectorizer, retrievalService

**测试步骤**:
```typescript
1. 调用 queryVectorizer.vectorizeQuery('test query')
2. 验证返回向量维度
3. 使用向量进行相似度检索
4. 验证检索成功
```

**预期结果**:
- ✅ 查询向量维度正确
- ✅ 检索返回结果
- ✅ 无错误

---

#### 场景 4.7-INT-003: 配置错误时的系统行为

**测试级别**: Integration  
**优先级**: P2  
**测试内容**: 验证配置错误时系统的降级行为

**理由**: 确保配置问题不会导致系统完全不可用

**前置条件**:
- Mock 配置不一致
- 生产环境模式

**测试步骤**:
```typescript
1. 模拟配置不匹配 (zhipu + 1536维)
2. 启动应用
3. 尝试文档上传
4. 尝试查询
```

**预期结果**:
- ⚠️ 启动时记录配置警告
- ❌ 文档上传/查询失败（或使用降级逻辑）
- ✅ 应用不会崩溃

**缓解风险**: TECH-002

---

## 测试执行计划

### Phase 1: 单元测试基础 (优先执行)

**目标**: 建立测试基础设施和核心测试

**场景**:
- 4.7-UNIT-001, 002, 009, 010 (核心正常/错误路径)
- 4.7-UNIT-013, 016, 019 (配置验证核心)

**预计时间**: 1 小时

---

### Phase 2: 单元测试完整覆盖

**目标**: 完成所有单元测试场景

**场景**:
- 4.7-UNIT-003 到 008 (embeddingService 边界和日志)
- 4.7-UNIT-011, 012 (queryVectorizer 完整覆盖)
- 4.7-UNIT-014, 015, 017, 018, 020 (validate-vector-config 完整覆盖)

**预计时间**: 1.5 小时

---

### Phase 3: 集成测试

**目标**: 验证系统集成

**场景**:
- 4.7-INT-001 (P0 关键集成)
- 4.7-INT-002, 003 (P1/P2 补充)

**预计时间**: 30 分钟

---

### Phase 4: 覆盖率和文档

**目标**: 验证质量和完成文档

**场景**:
- 4.7-UNIT-021 (覆盖率检查)
- 4.7-UNIT-022 (文档审查)

**预计时间**: 20 分钟

---

## 测试数据 Fixtures

### 共享测试向量

**文件**: `tests/fixtures/vectors.ts`

```typescript
/**
 * 共享测试向量 Fixtures
 */

export const TEST_VECTORS = {
  // 正确维度
  valid1024: new Array(1024).fill(0.1),
  valid1536: new Array(1536).fill(0.1),
  
  // 错误维度
  empty: [] as number[],
  wrong512: new Array(512).fill(0.1),
  wrong768: new Array(768).fill(0.1),
  tooLong2048: new Array(2048).fill(0.1),
  
  // 特殊情况
  allZeros: new Array(1024).fill(0),
  allOnes: new Array(1024).fill(1),
  mixed: Array.from({ length: 1024 }, (_, i) => i / 1024),
}

export const TEST_CHUNKS: ChunkResult[] = [
  {
    id: 'test-chunk-1',
    chunkIndex: 0,
    content: 'Test content for embedding',
    startPos: 0,
    endPos: 26,
    length: 26
  },
  {
    id: 'test-chunk-2',
    chunkIndex: 1,
    content: 'Another test chunk',
    startPos: 27,
    endPos: 45,
    length: 18
  }
]
```

---

### Mock 工厂函数

**文件**: `tests/fixtures/mocks.ts`

```typescript
/**
 * Mock 工厂函数
 */

import { vi } from '@jest/globals'

export function createMockLLM(vectorToReturn: number[] | number[][]) {
  return {
    generateEmbeddings: vi.fn().mockResolvedValue(
      Array.isArray(vectorToReturn[0]) 
        ? vectorToReturn 
        : [vectorToReturn]
    )
  }
}

export function createMockVectorRepository() {
  return {
    insertVectors: vi.fn().mockResolvedValue(undefined),
    similaritySearch: vi.fn().mockResolvedValue([])
  }
}

export function createMockEmbeddingCache() {
  return {
    get: vi.fn().mockResolvedValue(null),
    set: vi.fn().mockResolvedValue(undefined)
  }
}

export function spyOnConsole() {
  return {
    error: vi.spyOn(console, 'error').mockImplementation(),
    warn: vi.spyOn(console, 'warn').mockImplementation(),
    log: vi.spyOn(console, 'log').mockImplementation(),
    
    restore() {
      this.error.mockRestore()
      this.warn.mockRestore()
      this.log.mockRestore()
    }
  }
}
```

---

## 推荐测试执行顺序

### 1. 开发期间 (TDD 方式)

```bash
# 只运行当前开发的测试
npm test -- embeddingService.dimension.test.ts --watch

# 开发完成后运行完整测试
npm test -- embeddingService.dimension.test.ts
```

### 2. Pre-commit Hook

```bash
# 运行所有维度相关测试
npm test -- --testPathPattern="dimension"

# 快速覆盖率检查
npm test -- --coverage --coveragePathIgnorePatterns="node_modules"
```

### 3. CI/CD Pipeline

```bash
# 完整测试套件 + 覆盖率报告
npm test -- --coverage --ci

# 检查覆盖率阈值
# Jest config:
# coverageThreshold: {
#   'src/services/documents/embeddingService.ts': {
#     branches: 90,
#     functions: 90,
#     lines: 90
#   }
# }
```

---

## 风险覆盖映射

| 风险 ID | 风险描述 | 覆盖测试场景 | 覆盖状态 |
|---------|---------|-------------|---------|
| TECH-001 | 配置验证逻辑冲突 | 4.7-UNIT-005, 006, 4.7-INT-001 | ✅ 完全覆盖 |
| TEST-001 | Mock 复杂度高 | 所有 UNIT 测试 + Fixtures | ✅ 通过 Fixtures 缓解 |
| TECH-002 | 部署环境兼容性 | 4.7-UNIT-018, 019, 4.7-INT-003 | ✅ 完全覆盖 |
| TECH-003 | 错误消息复杂度 | 4.7-UNIT-007, 008 | ✅ 完全覆盖 |
| PERF-001 | 启动时间 | 4.7-UNIT-020 (手动监控) | ⚠️ 需手动验证 |
| TEST-002 | Mock 维护成本 | Fixtures 和工厂函数 | ✅ 通过架构缓解 |
| TEST-003 | 覆盖率目标 | 4.7-UNIT-021 | ✅ 完全覆盖 |
| MNT-001 | 合并冲突 | N/A (流程管理) | N/A |

---

## 测试质量指标

### 覆盖率目标

| 文件 | 目标覆盖率 | 关键指标 |
|------|-----------|---------|
| embeddingService.ts | ≥ 90% | 维度验证逻辑 100% |
| queryVectorizer.ts | ≥ 90% | 维度验证逻辑 100% |
| validate-vector-config.ts | 100% | 所有函数和分支 |

### 测试可靠性

- ✅ 无 Flaky Tests (不稳定测试)
- ✅ 所有 Mock 都是确定性的
- ✅ 测试独立，无顺序依赖
- ✅ 快速执行 (< 5s 整体)

### 测试可维护性

- ✅ 使用共享 Fixtures
- ✅ Mock 工厂函数复用
- ✅ 清晰的测试命名
- ✅ 详细的测试文档

---

## Definition of Done - 测试视角

从测试角度，Story 4.7 的 DoD:

- [ ] 所有 P0 测试场景实现并通过 (10个)
- [ ] 所有 P1 测试场景实现并通过 (9个)
- [ ] 测试覆盖率达标:
  - [ ] embeddingService 维度代码 ≥ 90%
  - [ ] queryVectorizer 维度代码 ≥ 90%
  - [ ] validate-vector-config = 100%
- [ ] 所有集成测试通过 (3个)
- [ ] 测试 Fixtures 和 Mock 工厂创建
- [ ] JSDoc 文档完整 (AC5)
- [ ] Code Review 通过 (测试代码质量)
- [ ] CI/CD 测试通过

---

## 附录: 测试命令参考

```bash
# 运行特定测试文件
npm test -- embeddingService.dimension.test.ts
npm test -- queryVectorizer.dimension.test.ts
npm test -- validate-vector-config.test.ts

# 运行所有维度相关测试
npm test -- --testPathPattern="dimension"

# 覆盖率报告
npm test -- --coverage --collectCoverageFrom="src/services/documents/embeddingService.ts"
npm test -- --coverage --collectCoverageFrom="src/services/rag/queryVectorizer.ts"
npm test -- --coverage --collectCoverageFrom="src/lib/validate-vector-config.ts"

# Watch 模式 (开发时)
npm test -- --watch embeddingService.dimension.test.ts

# CI 模式
npm test -- --ci --coverage --maxWorkers=2
```

---

**文档版本**: 1.0  
**下次审阅**: Story 实施完成后  
**相关文档**:
- Risk Profile: `docs/qa/assessments/4.7-vector-dimension-validation-risk-20250115.md`
- Story: `docs/stories/4.7-vector-dimension-validation.md`
- Testing Strategy: `docs/testing/strategy.md`

