# Story 3.2: RAG向量检索 - 测试用例汇总

**Story**: 3.2 - RAG向量检索实现  
**日期**: 2025-01-08  
**状态**: 开发完成，测试进行中

---

## 📊 测试覆盖概览

| 测试类型 | 计划数量 | 已完成 | 通过率 | 优先级分布 |
|---------|---------|--------|--------|-----------|
| 单元测试 | 21 | 21 | 100% | P0: 8, P1: 13 |
| 集成测试 | 15 | 0 | - | P0: 9, P1: 6 |
| 性能测试 | 5 | 0 | - | P0: 3, P1: 2 |
| 人工评估 | 1 | 0 | - | P0: 1 (CRITICAL) |
| **总计** | **42** | **21** | **50%** | - |

---

## ✅ 已完成：单元测试 (21/21 通过)

### 1. QueryVectorizer 测试 (10个)

**测试文件**: `tests/unit/services/rag/queryVectorizer.test.ts`

| ID | 用例名称 | 优先级 | 状态 | 验证内容 |
|----|---------|--------|------|---------|
| UT-QV-001 | 应该成功向量化有效的查询问题 | P0 | ✅ | 正常流程，返回1024维向量 |
| UT-QV-002 | 应该拒绝空查询 | P1 | ✅ | 空字符串、纯空格被拒绝 |
| UT-QV-003 | 应该拒绝过长的查询（>1000字符） | P1 | ✅ | 边界条件验证 |
| UT-QV-004 | 应该接受1000字符的查询 | P1 | ✅ | 最大长度边界 |
| UT-QV-005 | 应该处理embedding API失败 | P1 | ✅ | API错误处理 |
| UT-QV-006 | 应该处理embedding API超时 | P0 | ✅ | 超时错误分类 |
| UT-QV-007 | 应该处理API配额超限 | P0 | ✅ | 配额错误处理 |
| UT-QV-008 | 应该验证向量维度 | P0 | ✅ | 维度不匹配检测 (1024维) |
| UT-QV-009 | 应该处理空的embedding响应 | P1 | ✅ | 空响应错误处理 |
| UT-QV-010 | 应该自动trim查询字符串 | P1 | ✅ | 输入规范化 |

**关键发现**:
- ✅ 所有测试使用 `EMBEDDING_DIMENSION` 常量（1024维）
- ✅ 错误处理完善，包含超时、配额、API失败等场景
- ✅ 输入验证覆盖边界条件

---

### 2. QueryCacheService 测试 (11个)

**测试文件**: `tests/unit/services/rag/queryCacheService.test.ts`

| ID | 用例名称 | 优先级 | 状态 | 验证内容 |
|----|---------|--------|------|---------|
| UT-QC-001 | 应该成功连接Redis | P1 | ✅ | Redis连接初始化 |
| UT-QC-002 | 应该生成一致的缓存键 | P1 | ✅ | MD5哈希一致性 |
| UT-QC-003 | 应该返回缓存命中结果 | P0 | ✅ | 缓存读取 |
| UT-QC-004 | 应该返回null当缓存未命中 | P0 | ✅ | 缓存miss处理 |
| UT-QC-005 | 应该设置30分钟TTL | P1 | ✅ | 缓存过期策略 |
| UT-QC-006 | 应该清除文档相关缓存 | P1 | ✅ | 批量失效逻辑 |
| UT-QC-007 | Redis不可用时优雅降级 | P0 | ✅ | 降级到无缓存模式 |
| UT-QC-008 | 应该规范化查询字符串 | P1 | ✅ | toLowerCase + trim |
| UT-QC-009 | 缓存写入失败不抛错 | P0 | ✅ | 写入失败降级 |
| UT-QC-010 | 应该序列化复杂对象 | P1 | ✅ | JSON序列化 |
| UT-QC-011 | 缓存键包含documentId | P1 | ✅ | 隔离不同文档 |

**关键发现**:
- ✅ Redis故障降级逻辑完善
- ✅ 缓存失败不影响主流程
- ✅ 缓存键设计合理（documentId + queryHash）

---

## ⏳ 待实现：集成测试 (0/15)

### 3. RAG检索API集成测试

**测试文件**: `tests/integration/api/rag-retrieval.test.ts` (框架已创建)

#### 3.1 核心功能测试 (P0)

| ID | 用例名称 | 优先级 | 状态 | 验证内容 |
|----|---------|--------|------|---------|
| IT-RAG-001 | 应该成功执行完整RAG检索流程 | P0 | ⏳ | 端到端检索 |
| IT-RAG-002 | 应该正确过滤低相似度结果 | P0 | ⏳ | minScore=0.3生效 |
| IT-RAG-003 | 应该返回Top-K数量的结果 | P0 | ⏳ | topK=5限制 |
| IT-RAG-004 | 应该验证文档权限 | P0 | ⏳ | 跨用户访问拒绝 |
| IT-RAG-005 | 应该拒绝访问未就绪的文档 | P0 | ⏳ | status != READY |

**前置条件**:
```bash
# 1. 测试数据库
docker run -d --name test-postgres \
  -e POSTGRES_PASSWORD=test \
  -p 5433:5432 \
  ankane/pgvector

# 2. 测试Redis
docker run -d --name test-redis \
  -p 6380:6379 redis:alpine

# 3. 测试数据
npm run seed:test-documents
```

**测试步骤示例** (IT-RAG-001):
```typescript
it('应该成功执行完整RAG检索流程', async () => {
  // 1. 准备：创建测试用户和文档
  const user = await createTestUser()
  const doc = await createTestDocument(user.id, {
    filename: 'test-react.pdf',
    chunks: 50,
    status: 'READY'
  })

  // 2. 执行：调用API
  const response = await request(app)
    .post('/api/chat/query')
    .set('Authorization', `Bearer ${user.token}`)
    .send({
      documentId: doc.id,
      question: '什么是React Hooks?',
      conversationId: null
    })

  // 3. 验证：响应格式和内容
  expect(response.status).toBe(200)
  expect(response.body.success).toBe(true)
  expect(response.body.retrieval).toMatchObject({
    chunks: expect.arrayContaining([
      expect.objectContaining({
        id: expect.any(String),
        content: expect.any(String),
        score: expect.any(Number),
        documentId: doc.id
      })
    ]),
    totalFound: expect.any(Number),
    cached: false,
    retrievalTime: expect.any(Number)
  })
  expect(response.body.retrieval.chunks.length).toBeGreaterThan(0)
  expect(response.body.retrieval.chunks.length).toBeLessThanOrEqual(5)
})
```

#### 3.2 缓存功能测试 (P1)

| ID | 用例名称 | 优先级 | 状态 | 验证内容 |
|----|---------|--------|------|---------|
| IT-RAG-006 | 应该正确处理缓存命中 | P1 | ⏳ | cached=true, 响应更快 |
| IT-RAG-007 | 不同查询应该缓存隔离 | P1 | ⏳ | 缓存键唯一性 |
| IT-RAG-008 | Redis故障时优雅降级 | P1 | ⏳ | 无缓存也能工作 |

#### 3.3 错误处理测试 (P0/P1)

| ID | 用例名称 | 优先级 | 状态 | 验证内容 |
|----|---------|--------|------|---------|
| IT-RAG-009 | 应该处理向量化失败 | P0 | ⏳ | 返回503错误 |
| IT-RAG-010 | 应该处理向量化超时 | P1 | ⏳ | 返回504错误 |
| IT-RAG-011 | 未找到相关内容时友好提示 | P0 | ⏳ | NO_RELEVANT_CONTENT |
| IT-RAG-012 | 应该处理API配额超限 | P1 | ⏳ | 返回429错误 |
| IT-RAG-013 | 应该处理数据库错误 | P1 | ⏳ | 返回500错误 |

#### 3.4 安全测试 (P0)

| ID | 用例名称 | 优先级 | 状态 | 验证内容 |
|----|---------|--------|------|---------|
| IT-RAG-014 | API密钥不应出现在响应中 | P0 | ⏳ | 响应不含sk-* |
| IT-RAG-015 | 查询内容应该脱敏 | P0 | ⏳ | 日志仅前50字符 |

---

## ⏳ 待实现：性能测试 (0/5)

### 4. 性能基准测试

**测试文件**: `tests/performance/rag-retrieval.benchmark.ts` (需创建)

| ID | 用例名称 | 优先级 | 目标 | 状态 | 验证内容 |
|----|---------|--------|------|------|---------|
| PT-RAG-001 | 向量化延迟分布 | P0 | P95 < 300ms | ⏳ | 100次采样 |
| PT-RAG-002 | 向量检索延迟分布 | P0 | P95 < 200ms | ⏳ | 100次采样 |
| PT-RAG-003 | 端到端延迟分布 | P0 | P95 < 500ms | ⏳ | 100次采样 |
| PT-RAG-004 | 并发性能测试 | P1 | 10并发无问题 | ⏳ | 延迟不线性增长 |
| PT-RAG-005 | 缓存命中率测试 | P1 | > 30% | ⏳ | 重复查询场景 |

**测试代码示例**:
```typescript
it('端到端延迟应该 < 500ms (P95)', async () => {
  const latencies: number[] = []
  const iterations = 100

  // 执行100次请求
  for (let i = 0; i < iterations; i++) {
    const start = performance.now()
    await request(app)
      .post('/api/chat/query')
      .set('Authorization', `Bearer ${testUser.token}`)
      .send({
        documentId: testDocument.id,
        question: `测试问题 ${i}`
      })
    latencies.push(performance.now() - start)
  }

  // 计算P95
  latencies.sort((a, b) => a - b)
  const p50 = latencies[Math.floor(iterations * 0.5)]
  const p95 = latencies[Math.floor(iterations * 0.95)]
  const p99 = latencies[Math.floor(iterations * 0.99)]

  console.log('延迟分布:', { p50, p95, p99 })

  // 验证目标
  expect(p95).toBeLessThan(500)
})
```

---

## 🎯 待实现：人工质量评估 (CRITICAL)

### 5. Top-5检索准确率评估

**目标**: >= 85%  
**优先级**: P0 (阻止上线)  
**预计时间**: 4小时

#### 5.1 测试文档准备 (3个)

| 文档ID | 类型 | 文件名 | 页数 | 主题 |
|-------|------|--------|------|------|
| DOC-1 | 技术文档 | react-official-guide.pdf | 50 | React Hooks, 组件, 状态管理 |
| DOC-2 | 业务文档 | product-requirements.docx | 30 | 产品功能, 用户需求, 定价 |
| DOC-3 | 学术文档 | ml-research-paper.pdf | 20 | 机器学习, 实验方法, 结果 |

#### 5.2 测试问题设计 (20个)

##### DOC-1: 技术文档 (7个问题)

| ID | 问题类型 | 测试问题 |
|----|---------|---------|
| Q1 | 事实性 | 什么是React Hooks？ |
| Q2 | 操作性 | 如何使用useState管理状态？ |
| Q3 | 比较性 | useEffect和useLayoutEffect的区别是什么？ |
| Q4 | 解释性 | 为什么需要useCallback优化性能？ |
| Q5 | 事实性 | React 18有哪些新特性？ |
| Q6 | 操作性 | 如何避免useEffect的无限循环？ |
| Q7 | 操作性 | 自定义Hook的最佳实践有哪些？ |

##### DOC-2: 业务文档 (7个问题)

| ID | 问题类型 | 测试问题 |
|----|---------|---------|
| Q8 | 事实性 | 产品的核心功能是什么？ |
| Q9 | 操作性 | 如何创建新用户账户？ |
| Q10 | 比较性 | 免费版和付费版有什么区别？ |
| Q11 | 解释性 | 为什么要实现这个功能？ |
| Q12 | 事实性 | 产品的目标用户是谁？ |
| Q13 | 操作性 | 如何升级到付费版？ |
| Q14 | 事实性 | 产品的价格是多少？ |

##### DOC-3: 学术文档 (6个问题)

| ID | 问题类型 | 测试问题 |
|----|---------|---------|
| Q15 | 事实性 | 研究的主要假设是什么？ |
| Q16 | 操作性 | 实验方法是如何设计的？ |
| Q17 | 比较性 | 这项研究与以往研究的不同在哪？ |
| Q18 | 解释性 | 为什么选择这种研究方法？ |
| Q19 | 事实性 | 实验的主要结果是什么？ |
| Q20 | 解释性 | 研究结果的意义是什么？ |

#### 5.3 评估标准

**每个chunk的评分**:
- ✅ **相关** (2分): chunk内容直接回答问题或提供关键信息
- ⚠️ **部分相关** (1分): chunk包含相关关键词但信息不完整
- ❌ **不相关** (0分): chunk与问题无关

**准确率计算**:
```
准确率 = (相关结果数 + 0.5 × 部分相关结果数) / 总结果数
```

**评估表格模板**:
```markdown
| 问题 | Chunk1 | Chunk2 | Chunk3 | Chunk4 | Chunk5 | 得分 | 准确率 |
|------|--------|--------|--------|--------|--------|------|--------|
| Q1   | ✅(2)  | ✅(2)  | ⚠️(1)  | ❌(0)  | ✅(2)  | 7    | 70%    |
| Q2   | ✅(2)  | ✅(2)  | ✅(2)  | ⚠️(1)  | ⚠️(1)  | 8    | 80%    |
| ...  | ...    | ...    | ...    | ...    | ...    | ...  | ...    |

最终准确率 = (总得分 / (20 × 10)) × 100%
```

#### 5.4 执行步骤

1. **准备阶段** (1小时)
   - 上传3个测试文档到系统
   - 等待向量化完成
   - 验证文档状态为READY

2. **执行阶段** (2小时)
   - 对每个问题执行检索
   - 记录返回的Top-5 chunks
   - 人工评估每个chunk的相关性

3. **分析阶段** (1小时)
   - 计算总体准确率
   - 分析失败案例
   - 识别改进方向
   - 撰写评估报告

#### 5.5 输出文档

**保存位置**: `docs/qa/assessments/3.2-quality-manual-{YYYYMMDD}.md`

**报告内容**:
```markdown
# Story 3.2 人工质量评估报告

## 评估概要
- 测试日期: {date}
- 评估人: {name}
- 测试文档: 3个
- 测试问题: 20个
- 总检索结果: 100个chunks (20 × 5)

## 评估结果
- 总得分: XX / 200
- 准确率: XX%
- 目标: >= 85%
- **结论**: ✅ 通过 / ❌ 未通过

## 详细评分表
[完整的20×5评分表格]

## 失败案例分析
[列出准确率 < 50%的问题及原因]

## 改进建议
1. ...
2. ...

## 结论和建议
[是否达标，是否需要调优]
```

---

## 📝 测试执行计划

### 阶段1: 快速修复 (已完成 ✅)

- ✅ 修复单元测试失败（维度问题）
- ✅ 实现查询内容脱敏
- ✅ 所有单元测试通过（21/21）

### 阶段2: 关键验证 (进行中 ⏳)

**优先级排序**:
1. 🔴 **人工质量评估** (P0, 4小时) - CRITICAL，阻止上线
2. 🔴 **集成测试P0场景** (P0, 1天) - 验证完整流程
3. 🟡 **性能基准测试** (P0, 2小时) - 建立基线

**预计完成时间**: 1.5-2天

### 阶段3: 完善覆盖 (可选)

- 集成测试P1场景
- 更多性能测试场景
- 故障注入测试

---

## 🎯 质量门控标准

根据 `docs/qa/gates/3.2-rag-vector-retrieval.yml`：

### PASS 条件
- ✅ 所有P0单元测试通过
- ✅ 人工质量评估 >= 85%
- ✅ P95延迟 < 500ms
- ✅ 无安全漏洞
- ✅ 集成测试P0场景通过

### CONCERNS 触发条件
- ⚠️ P1测试失败1-3个
- ⚠️ 人工质量评估 80-85%
- ⚠️ P95延迟 500-800ms
- ⚠️ 缓存命中率 20-30%

### FAIL 触发条件
- ❌ 任何P0测试失败
- ❌ 人工质量评估 < 80%
- ❌ P95延迟 > 1秒
- ❌ 安全漏洞发现
- ❌ API密钥泄露

---

## 📊 当前状态总结

**已完成**: ✅ 50% (21/42)
- 单元测试覆盖良好
- 基础功能验证完成
- 查询内容脱敏已实现

**阻止上线**: 🔴 3项
1. 人工质量评估未完成
2. 集成测试未实现
3. 性能基准测试未执行

**建议**: 
- 立即安排人工质量评估（最高优先级）
- 与QA协作配置测试环境
- 执行性能基准测试建立基线

**预计完成时间**: 1.5-2天
**建议重新审查时间**: 2025-01-10

---

**文档版本**: 1.0  
**最后更新**: 2025-01-08  
**维护人**: Dev Agent (James)
