# Story 3.2 RAG向量检索功能测试指南

## 测试概览

本文档提供Story 3.2 RAG向量检索功能的完整测试方案，包括单元测试、集成测试和手动测试方法。

---

## 方法一：单元测试（自动化）✅

### 运行所有RAG单元测试

```bash
npm test -- tests/unit/services/rag/
```

**预期结果：**
- ✅ 21个测试全部通过
- ✅ 覆盖查询向量化、缓存服务的核心逻辑
- ✅ 验证输入验证、错误处理、降级策略

### 单独测试各组件

```bash
# 测试查询向量化服务
npm test -- tests/unit/services/rag/queryVectorizer.test.ts

# 测试查询缓存服务
npm test -- tests/unit/services/rag/queryCacheService.test.ts
```

---

## 方法二：API手动测试（推荐）

### 前置条件

1. **启动开发服务器：**
```bash
npm run dev
```

2. **确保数据库已配置：**
   - PostgreSQL + pgvector扩展已启用
   - 数据库迁移已运行

3. **上传并处理测试文档：**
   - 登录系统
   - 上传一个测试文档（PDF/DOCX）
   - 等待文档状态变为 `READY`（已向量化）

### 测试步骤

#### Step 1: 获取认证Token

登录系统后，打开浏览器开发者工具，获取cookie中的认证信息。

#### Step 2: 测试RAG检索API

使用以下curl命令或Postman测试：

```bash
# 设置变量
DOCUMENT_ID="your-document-id"  # 从文档列表获取
QUESTION="文档的主要内容是什么？"

# 发送请求
curl -X POST http://localhost:3000/api/chat/query \
  -H "Content-Type: application/json" \
  -H "Cookie: your-session-cookie" \
  -d '{
    "documentId": "'$DOCUMENT_ID'",
    "question": "'$QUESTION'",
    "conversationId": null
  }'
```

#### Step 3: 验证响应

**成功响应示例：**
```json
{
  "success": true,
  "conversationId": "new",
  "retrieval": {
    "chunks": [
      {
        "id": "chunk-id-1",
        "content": "相关文档内容片段...",
        "score": 0.89,
        "chunkIndex": 0,
        "metadata": {
          "pageNumber": 1
        }
      },
      {
        "id": "chunk-id-2",
        "content": "另一个相关片段...",
        "score": 0.85,
        "chunkIndex": 5,
        "metadata": {
          "pageNumber": 2
        }
      }
    ],
    "totalFound": 5,
    "cached": false,
    "retrievalTime": 450
  },
  "message": "RAG检索完成。LLM回答生成将在Story 3.3实现。",
  "debug": {
    "totalTime": "452ms",
    "documentTitle": "test-document.pdf"
  }
}
```

#### Step 4: 测试缓存功能

```bash
# 第一次请求（cached: false）
curl -X POST http://localhost:3000/api/chat/query \
  -H "Content-Type: application/json" \
  -H "Cookie: your-session-cookie" \
  -d '{"documentId": "'$DOCUMENT_ID'", "question": "测试问题"}'

# 立即再次请求相同问题（cached: true）
curl -X POST http://localhost:3000/api/chat/query \
  -H "Content-Type: application/json" \
  -H "Cookie: your-session-cookie" \
  -d '{"documentId": "'$DOCUMENT_ID'", "question": "测试问题"}'
```

**验证点：**
- ✅ 第二次请求返回 `"cached": true`
- ✅ 第二次请求的 `retrievalTime` 明显更快

---

## 方法三：使用Postman测试

### 创建Postman Collection

1. **创建新Collection：** `RAG Retrieval Tests`

2. **配置环境变量：**
```json
{
  "base_url": "http://localhost:3000",
  "document_id": "your-test-document-id",
  "auth_cookie": "your-session-cookie"
}
```

3. **添加测试请求：**

#### 请求1: 基本检索测试
```
POST {{base_url}}/api/chat/query
Headers:
  Content-Type: application/json
  Cookie: {{auth_cookie}}
Body:
{
  "documentId": "{{document_id}}",
  "question": "文档的主要内容是什么？",
  "conversationId": null
}

Tests:
pm.test("Status code is 200", function () {
    pm.response.to.have.status(200);
});

pm.test("Response has retrieval data", function () {
    var jsonData = pm.response.json();
    pm.expect(jsonData.success).to.eql(true);
    pm.expect(jsonData.retrieval).to.exist;
    pm.expect(jsonData.retrieval.chunks).to.be.an('array');
});

pm.test("Chunks have required fields", function () {
    var jsonData = pm.response.json();
    var chunk = jsonData.retrieval.chunks[0];
    pm.expect(chunk).to.have.property('id');
    pm.expect(chunk).to.have.property('content');
    pm.expect(chunk).to.have.property('score');
    pm.expect(chunk.score).to.be.above(0.7);
});
```

#### 请求2: 测试缓存
```
POST {{base_url}}/api/chat/query
Headers:
  Content-Type: application/json
  Cookie: {{auth_cookie}}
Body:
{
  "documentId": "{{document_id}}",
  "question": "重复的测试问题",
  "conversationId": null
}

Tests:
pm.test("Cached flag exists", function () {
    var jsonData = pm.response.json();
    pm.expect(jsonData.retrieval.cached).to.exist;
});
```

#### 请求3: 测试错误处理
```
POST {{base_url}}/api/chat/query
Headers:
  Content-Type: application/json
  Cookie: {{auth_cookie}}
Body:
{
  "documentId": "non-existent-id",
  "question": "测试问题",
  "conversationId": null
}

Tests:
pm.test("Returns 404 for non-existent document", function () {
    pm.response.to.have.status(404);
});
```

---

## 方法四：前端集成测试

### 使用前端界面测试

1. **访问聊天页面：**
```
http://localhost:3000/chat
```

2. **选择已上传的文档**

3. **输入测试问题：**
   - "文档的主要内容是什么？"
   - "总结第一章的要点"
   - "关于XXX的详细信息"

4. **观察开发者工具：**
   - Network标签查看API请求
   - Console查看日志输出
   - 验证响应数据结构

---

## 方法五：性能测试

### 基准性能测试

```bash
# 创建性能测试脚本
cat > test-performance.sh << 'EOF'
#!/bin/bash

DOCUMENT_ID="your-document-id"
COOKIE="your-session-cookie"
ITERATIONS=10

echo "Running $ITERATIONS requests..."

for i in $(seq 1 $ITERATIONS); do
  START=$(date +%s%3N)
  
  curl -s -X POST http://localhost:3000/api/chat/query \
    -H "Content-Type: application/json" \
    -H "Cookie: $COOKIE" \
    -d "{\"documentId\": \"$DOCUMENT_ID\", \"question\": \"测试问题 $i\"}" \
    > /dev/null
  
  END=$(date +%s%3N)
  ELAPSED=$((END - START))
  
  echo "Request $i: ${ELAPSED}ms"
done
EOF

chmod +x test-performance.sh
./test-performance.sh
```

**性能目标：**
- ✅ P95延迟 < 500ms
- ✅ 向量化 < 300ms
- ✅ 检索 < 200ms

---

## 测试检查清单

### 功能测试 ✅

- [ ] **基本检索功能**
  - [ ] 成功返回相关文档片段
  - [ ] 返回Top-K个结果（默认5个）
  - [ ] 相似度分数正确（0-1之间）
  - [ ] 按相似度降序排序

- [ ] **过滤功能**
  - [ ] documentId过滤有效
  - [ ] userId权限验证有效
  - [ ] 相似度阈值过滤（minScore: 0.7）

- [ ] **缓存功能**
  - [ ] 首次请求cached=false
  - [ ] 重复请求cached=true
  - [ ] 缓存命中时响应更快
  - [ ] 不同问题缓存独立

- [ ] **错误处理**
  - [ ] 文档不存在返回404
  - [ ] 未授权返回401
  - [ ] 问题过长返回400
  - [ ] 问题为空返回400
  - [ ] 文档未准备好返回400
  - [ ] 未找到相关内容友好提示

### 性能测试 ⚡

- [ ] 端到端延迟 < 500ms (P95)
- [ ] 向量化耗时 < 300ms
- [ ] 向量检索耗时 < 200ms
- [ ] 缓存命中率 > 30%（重复查询场景）

### 边界测试 🔍

- [ ] 空查询被拒绝
- [ ] 超长查询（>1000字符）被拒绝
- [ ] 跨用户文档访问被拒绝
- [ ] 未向量化文档被拒绝
- [ ] 非READY状态文档被拒绝

---

## 常见问题排查

### 问题1: 返回404 - 文档不存在

**检查：**
```bash
# 1. 确认文档ID正确
# 2. 检查文档是否属于当前用户
# 3. 查看数据库
psql $DATABASE_URL -c "SELECT id, filename, status, user_id FROM documents WHERE id='your-document-id';"
```

### 问题2: 返回400 - 文档未准备好

**检查：**
```bash
# 检查文档状态
psql $DATABASE_URL -c "SELECT status FROM documents WHERE id='your-document-id';"

# 应该返回 'READY'
# 如果是 'PENDING' 或 'EMBEDDING'，需要等待处理完成
```

### 问题3: 返回空结果或低相关性

**检查：**
1. 文档是否已向量化？
2. 问题与文档内容是否相关？
3. 尝试更具体的问题
4. 检查相似度阈值设置

### 问题4: Redis缓存不工作

**检查环境变量：**
```bash
# 确认Redis配置
echo $UPSTASH_REDIS_REST_URL
echo $UPSTASH_REDIS_REST_TOKEN

# 如果未配置，系统会降级到无缓存模式（仍可正常工作）
```

### 问题5: 向量化失败

**检查LLM配置：**
```bash
# 确认LLM API配置
echo $LLM_PROVIDER
echo $OPENAI_API_KEY  # 或 $ZHIPU_API_KEY
```

---

## 下一步：Story 3.3准备

完成以上测试后，确认：
- ✅ RAG检索功能正常工作
- ✅ 返回相关文档片段
- ✅ 性能指标达标
- ✅ 错误处理完善

就可以进入Story 3.3：使用检索结果生成LLM回答！

---

## 测试数据建议

**好的测试问题示例：**
- ✅ "文档的主要内容是什么？"
- ✅ "总结第一章的要点"
- ✅ "关于XXX的详细解释"
- ✅ "文档中提到的关键概念有哪些？"

**不好的测试问题：**
- ❌ "你好" （过于简单）
- ❌ "aaa" （无意义）
- ❌ 完全不相关的问题

**建议准备3-5个不同类型的测试文档：**
1. 技术文档（PDF）
2. 产品说明书（DOCX）
3. 学术论文（PDF）
4. 业务报告（DOCX）
5. 用户手册（PDF）
